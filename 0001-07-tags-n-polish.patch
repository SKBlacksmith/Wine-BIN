From ca172d54b0e9f054c78876abb52d9e887e39210f Mon Sep 17 00:00:00 2001
From: SKBlacksmith <85839122+SKBlacksmith@users.noreply.github.com>
Date: Sat, 6 Nov 2021 06:37:32 -0400
Subject: [PATCH 1/1] 07-tags-n-polish

---
 Makefile.in                    |     2 +-
 configure                      | 14407 ++++++++++++++----------
 configure.ac                   |     2 +-
 dlls/ntdll/loader.c            |    15 +
 dlls/winevulkan/vk-1.2.197.xml | 18071 +++++++++++++++++++++++++++++++
 include/config.h.in            |    27 +-
 include/wine/server_protocol.h |   205 +-
 include/wine/vulkan.h          |    30 +-
 server/request.h               |    74 +
 server/trace.c                 |   143 +-
 tools/config.guess             |   265 +-
 tools/config.sub               |    79 +-
 12 files changed, 27257 insertions(+), 6063 deletions(-)
 create mode 100644 dlls/winevulkan/vk-1.2.197.xml

diff --git a/Makefile.in b/Makefile.in
index 42f161e3af9..c15c357bcec 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -119,7 +119,7 @@ install-manpages:: manpages
 # Rules for generated source files
 
 dlls/ntdll/unix/version.c: dummy
-	@version=`(GIT_DIR=$(srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || ($(RM) $@ && exit 1)
+	@version=`(echo "wine-6.21.r0.g20f1a677b66") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1  ( TkG Plain Esync )";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || ($(RM) $@ && exit 1)
 
 programs/winetest/build.rc: dummy
 	@build="STRINGTABLE { 1 \"`GIT_DIR=$(srcdir)/.git git rev-parse HEAD 2>/dev/null`\" }" && (echo $$build | cmp -s - $@) || echo $$build >$@ || (rm -f $@ && exit 1)
diff --git a/configure b/configure
index 31341acce5f..2026a5823d0 100755
--- a/configure
+++ b/configure
@@ -1,11 +1,12 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for Wine 6.21.
+# Generated by GNU Autoconf 2.71 for Wine 6.21.
 #
 # Report bugs to <wine-devel@winehq.org>.
 #
 #
-# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
+# Copyright (C) 1992-1996, 1998-2017, 2020-2021 Free Software Foundation,
+# Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -16,14 +17,16 @@
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+as_nop=:
+if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
-else
+else $as_nop
   case `(set -o) 2>/dev/null` in #(
   *posix*) :
     set -o posix ;; #(
@@ -33,46 +36,46 @@ esac
 fi
 
 
+
+# Reset variables that may have inherited troublesome values from
+# the environment.
+
+# IFS needs to be set, to space, tab, and newline, in precisely that order.
+# (If _AS_PATH_WALK were called with IFS unset, it would have the
+# side effect of setting IFS to empty, thus disabling word splitting.)
+# Quoting is to prevent editors from complaining about space-tab.
 as_nl='
 '
 export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
+IFS=" ""	$as_nl"
+
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# Ensure predictable behavior from utilities with locale-dependent output.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# We cannot yet rely on "unset" to work, but we need these variables
+# to be unset--not just set to an empty or harmless value--now, to
+# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
+# also avoids known problems related to "unset" and subshell syntax
+# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
+for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
+do eval test \${$as_var+y} \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+
+# Ensure that fds 0, 1, and 2 are open.
+if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
+if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
+if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi
 
 # The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
+if ${PATH_SEPARATOR+false} :; then
   PATH_SEPARATOR=:
   (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
     (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
@@ -81,13 +84,6 @@ if test "${PATH_SEPARATOR+set}" != set; then
 fi
 
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
 # Find who we are.  Look in the path if we contain no directory separator.
 as_myself=
 case $0 in #((
@@ -96,8 +92,12 @@ case $0 in #((
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
   done
 IFS=$as_save_IFS
 
@@ -109,30 +109,10 @@ if test "x$as_myself" = x; then
   as_myself=$0
 fi
 if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
   exit 1
 fi
 
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 # Use a proper internal environment variable to ensure we don't fall
   # into an infinite loop, continuously re-executing ourselves.
@@ -154,20 +134,22 @@ esac
 exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
 # Admittedly, this is quite paranoid, since all the known shells bail
 # out after a failed `exec'.
-$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
-as_fn_exit 255
+printf "%s\n" "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
   fi
   # We don't want this to propagate to other subprocesses.
           { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
-  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  as_bourne_compatible="as_nop=:
+if test \${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '\${1+\"\$@\"}'='\"\$@\"'
   setopt NO_GLOB_SUBST
-else
+else \$as_nop
   case \`(set -o) 2>/dev/null\` in #(
   *posix*) :
     set -o posix ;; #(
@@ -187,42 +169,53 @@ as_fn_success || { exitcode=1; echo as_fn_success failed.; }
 as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
 as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
 as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
-if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+if ( set x; as_fn_ret_success y && test x = \"\$1\" )
+then :
 
-else
+else \$as_nop
   exitcode=1; echo positional parameters were not saved.
 fi
 test x\$exitcode = x0 || exit 1
+blah=\$(echo \$(echo blah))
+test x\"\$blah\" = xblah || exit 1
 test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
   test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
 test \$(( 1 + 1 )) = 2 || exit 1"
-  if (eval "$as_required") 2>/dev/null; then :
+  if (eval "$as_required") 2>/dev/null
+then :
   as_have_required=yes
-else
+else $as_nop
   as_have_required=no
 fi
-  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null
+then :
 
-else
+else $as_nop
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 as_found=false
 for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
   as_found=:
   case $as_dir in #(
 	 /*)
 	   for as_base in sh bash ksh sh5; do
 	     # Try only shells that exist, to save several forks.
-	     as_shell=$as_dir/$as_base
+	     as_shell=$as_dir$as_base
 	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+		    as_run=a "$as_shell" -c "$as_bourne_compatible""$as_required" 2>/dev/null
+then :
   CONFIG_SHELL=$as_shell as_have_required=yes
-		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+		   if as_run=a "$as_shell" -c "$as_bourne_compatible""$as_suggested" 2>/dev/null
+then :
   break 2
 fi
 fi
@@ -230,14 +223,21 @@ fi
        esac
   as_found=false
 done
-$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
-	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
-  CONFIG_SHELL=$SHELL as_have_required=yes
-fi; }
 IFS=$as_save_IFS
+if $as_found
+then :
+
+else $as_nop
+  if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      as_run=a "$SHELL" -c "$as_bourne_compatible""$as_required" 2>/dev/null
+then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi
+fi
 
 
-      if test "x$CONFIG_SHELL" != x; then :
+      if test "x$CONFIG_SHELL" != x
+then :
   export CONFIG_SHELL
              # We cannot yet assume a decent shell, so we have to provide a
 # neutralization value for shells without unset; and this also
@@ -255,18 +255,19 @@ esac
 exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
 # Admittedly, this is quite paranoid, since all the known shells bail
 # out after a failed `exec'.
-$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+printf "%s\n" "$0: could not re-execute with $CONFIG_SHELL" >&2
 exit 255
 fi
 
-    if test x$as_have_required = xno; then :
-  $as_echo "$0: This script requires a shell more modern than all"
-  $as_echo "$0: the shells that I found on your system."
-  if test x${ZSH_VERSION+set} = xset ; then
-    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
-    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+    if test x$as_have_required = xno
+then :
+  printf "%s\n" "$0: This script requires a shell more modern than all"
+  printf "%s\n" "$0: the shells that I found on your system."
+  if test ${ZSH_VERSION+y} ; then
+    printf "%s\n" "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    printf "%s\n" "$0: be upgraded to zsh 4.3.4 or later."
   else
-    $as_echo "$0: Please tell bug-autoconf@gnu.org and
+    printf "%s\n" "$0: Please tell bug-autoconf@gnu.org and
 $0: wine-devel@winehq.org about your system, including any
 $0: error possibly output before this message. Then install
 $0: a modern shell, or manually run the script under such a
@@ -294,6 +295,7 @@ as_fn_unset ()
 }
 as_unset=as_fn_unset
 
+
 # as_fn_set_status STATUS
 # -----------------------
 # Set $? to STATUS, without forking.
@@ -311,6 +313,14 @@ as_fn_exit ()
   as_fn_set_status $1
   exit $1
 } # as_fn_exit
+# as_fn_nop
+# ---------
+# Do nothing but, unlike ":", preserve the value of $?.
+as_fn_nop ()
+{
+  return $?
+}
+as_nop=as_fn_nop
 
 # as_fn_mkdir_p
 # -------------
@@ -325,7 +335,7 @@ as_fn_mkdir_p ()
     as_dirs=
     while :; do
       case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
       *) as_qdir=$as_dir;;
       esac
       as_dirs="'$as_qdir' $as_dirs"
@@ -334,7 +344,7 @@ $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
 	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
+printf "%s\n" X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -373,12 +383,13 @@ as_fn_executable_p ()
 # advantage of any shell optimizations that allow amortized linear growth over
 # repeated appends, instead of the typical quadratic growth present in naive
 # implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
+then :
   eval 'as_fn_append ()
   {
     eval $1+=\$2
   }'
-else
+else $as_nop
   as_fn_append ()
   {
     eval $1=\$$1\$2
@@ -390,18 +401,27 @@ fi # as_fn_append
 # Perform arithmetic evaluation on the ARGs, and store the result in the
 # global $as_val. Take advantage of shells that can avoid forks. The arguments
 # must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
+then :
   eval 'as_fn_arith ()
   {
     as_val=$(( $* ))
   }'
-else
+else $as_nop
   as_fn_arith ()
   {
     as_val=`expr "$@" || test $? -eq 1`
   }
 fi # as_fn_arith
 
+# as_fn_nop
+# ---------
+# Do nothing but, unlike ":", preserve the value of $?.
+as_fn_nop ()
+{
+  return $?
+}
+as_nop=as_fn_nop
 
 # as_fn_error STATUS ERROR [LINENO LOG_FD]
 # ----------------------------------------
@@ -413,9 +433,9 @@ as_fn_error ()
   as_status=$1; test $as_status -eq 0 && as_status=1
   if test "$4"; then
     as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $2" >&2
+  printf "%s\n" "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -442,7 +462,7 @@ as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
+printf "%s\n" X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
@@ -486,7 +506,7 @@ as_cr_alnum=$as_cr_Letters$as_cr_digits
       s/-\n.*//
     ' >$as_me.lineno &&
   chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+    { printf "%s\n" "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
   # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
   # already done that, so ensure we don't try to do so again and fall
@@ -500,6 +520,10 @@ as_cr_alnum=$as_cr_Letters$as_cr_digits
   exit
 }
 
+
+# Determine whether it's possible to make 'echo' print without a newline.
+# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
+# for compatibility with existing Makefiles.
 ECHO_C= ECHO_N= ECHO_T=
 case `echo -n x` in #(((((
 -n*)
@@ -513,6 +537,13 @@ case `echo -n x` in #(((((
   ECHO_N='-n';;
 esac
 
+# For backward compatibility with old third-party macros, we provide
+# the shell variables $as_echo and $as_echo_n.  New code should use
+# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
+as_echo='printf %s\n'
+as_echo_n='printf %s'
+
+
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
   rm -f conf$$.dir/conf$$.file
@@ -588,40 +619,36 @@ PACKAGE_URL='https://www.winehq.org'
 ac_unique_file="server/atom.c"
 # Factoring default headers for most tests.
 ac_includes_default="\
-#include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
+#include <stddef.h>
+#ifdef HAVE_STDIO_H
+# include <stdio.h>
 #endif
-#ifdef STDC_HEADERS
+#ifdef HAVE_STDLIB_H
 # include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
 #endif
 #ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-#  include <memory.h>
-# endif
 # include <string.h>
 #endif
-#ifdef HAVE_STRINGS_H
-# include <strings.h>
-#endif
 #ifdef HAVE_INTTYPES_H
 # include <inttypes.h>
 #endif
 #ifdef HAVE_STDINT_H
 # include <stdint.h>
 #endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif"
 
+ac_header_c_list=
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
 ALL_VARS_RULES
@@ -630,6 +657,8 @@ LDAP_CFLAGS
 RT_LIBS
 TOOLSEXT
 MSVCRTFLAGS
+GCRYPT_LIBS
+GCRYPT_CFLAGS
 VKD3D_SHADER_LIBS
 VKD3D_SHADER_CFLAGS
 VKD3D_LIBS
@@ -687,6 +716,7 @@ X_EXTRA_LIBS
 X_LIBS
 X_PRE_LIBS
 X_CFLAGS
+CPP
 XMKMF
 PTHREAD_LIBS
 ZLIB_PE_LIBS
@@ -738,7 +768,6 @@ CORESERVICES_LIBS
 APPLICATIONSERVICES_LIBS
 IOKIT_LIBS
 COREFOUNDATION_LIBS
-OBJCPP
 ac_ct_OBJC
 OBJCFLAGS
 OBJC
@@ -760,7 +789,6 @@ EXTRACFLAGS
 LDEXECFLAGS
 LDDLLFLAGS
 DLLFLAGS
-CPP
 OPENGL_LIBS
 I386_LIBS
 ICOTOOL
@@ -859,6 +887,7 @@ with_dbus
 with_float_abi
 with_fontconfig
 with_freetype
+with_gcrypt
 with_gettext
 with_gettextpo
 with_gphoto
@@ -894,6 +923,7 @@ with_xfixes
 with_xinerama
 with_xinput
 with_xinput2
+with_xpresent
 with_xrandr
 with_xrender
 with_xshape
@@ -1925,10 +1955,8 @@ CPPFLAGS
 CXX
 CXXFLAGS
 CCC
-CPP
 OBJC
 OBJCFLAGS
-OBJCPP
 FAUDIO_PE_CFLAGS
 FAUDIO_PE_LIBS
 GSM_PE_CFLAGS
@@ -1952,6 +1980,7 @@ XSLT_PE_LIBS
 ZLIB_PE_CFLAGS
 ZLIB_PE_LIBS
 XMKMF
+CPP
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -1998,6 +2027,8 @@ VKD3D_CFLAGS
 VKD3D_LIBS
 VKD3D_SHADER_CFLAGS
 VKD3D_SHADER_LIBS
+GCRYPT_CFLAGS
+GCRYPT_LIBS
 LDAP_CFLAGS
 LDAP_LIBS'
 
@@ -2068,8 +2099,6 @@ do
   *)    ac_optarg=yes ;;
   esac
 
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
   case $ac_dashdash$ac_option in
   --)
     ac_dashdash=yes ;;
@@ -2110,9 +2139,9 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "enable_$ac_useropt"
@@ -2136,9 +2165,9 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "enable_$ac_useropt"
@@ -2349,9 +2378,9 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "with_$ac_useropt"
@@ -2365,9 +2394,9 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "with_$ac_useropt"
@@ -2411,9 +2440,9 @@ Try \`$0 --help' for more information"
 
   *)
     # FIXME: should be removed in autoconf 3.0.
-    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+      printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
     : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
     ;;
 
@@ -2429,7 +2458,7 @@ if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
     fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
-    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+    *)     printf "%s\n" "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
 
@@ -2493,7 +2522,7 @@ $as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_myself" : 'X\(//\)[^/]' \| \
 	 X"$as_myself" : 'X\(//\)$' \| \
 	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_myself" |
+printf "%s\n" X"$as_myself" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -2650,6 +2679,7 @@ Optional Packages:
   --with-float-abi=abi    specify the ABI (soft|softfp|hard) for ARM platforms
   --without-fontconfig    do not use fontconfig
   --without-freetype      do not use the FreeType library
+  --without-gcrypt        do not use libgcrypt
   --without-gettext       do not use gettext
   --with-gettextpo        use the GetTextPO library to rebuild po files
   --without-gphoto        do not use gphoto (Digital Camera support)
@@ -2686,6 +2716,7 @@ Optional Packages:
   --without-xinerama      do not use Xinerama (legacy multi-monitor support)
   --without-xinput        do not use the Xinput extension
   --without-xinput2       do not use the Xinput 2 extension
+  --without-xpresent      do not use the Xpresent extension
   --without-xrandr        do not use Xrandr (multi-monitor support)
   --without-xrender       do not use the Xrender extension
   --without-xshape        do not use the Xshape extension
@@ -2705,10 +2736,8 @@ Some influential environment variables:
               you have headers in a nonstandard directory <include dir>
   CXX         C++ compiler command
   CXXFLAGS    C++ compiler flags
-  CPP         C preprocessor
   OBJC        Objective C compiler command
   OBJCFLAGS   Objective C compiler flags
-  OBJCPP      Objective C preprocessor
   FAUDIO_PE_CFLAGS
               C compiler flags for the PE faudio, overriding the bundled
               version
@@ -2756,6 +2785,7 @@ Some influential environment variables:
   ZLIB_PE_LIBS
               Linker flags for the PE zlib, overriding the bundled version
   XMKMF       Path to xmkmf, Makefile generator for X Window System
+  CPP         C preprocessor
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -2825,6 +2855,9 @@ Some influential environment variables:
               C compiler flags for libvkd3d-shader, overriding pkg-config
   VKD3D_SHADER_LIBS
               Linker flags for libvkd3d-shader, overriding pkg-config
+  GCRYPT_CFLAGS
+              C compiler flags for libgcrypt, overriding pkg-config
+  GCRYPT_LIBS Linker flags for libgcrypt, overriding pkg-config
   LDAP_CFLAGS C compiler flags for openldap, overriding pkg-config
   LDAP_LIBS   Linker flags for openldap, overriding pkg-config
 
@@ -2848,9 +2881,9 @@ if test "$ac_init_help" = "recursive"; then
 case "$ac_dir" in
 .) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
 *)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  ac_dir_suffix=/`printf "%s\n" "$ac_dir" | sed 's|^\.[\\/]||'`
   # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  ac_top_builddir_sub=`printf "%s\n" "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
   case $ac_top_builddir_sub in
   "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
   *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
@@ -2878,7 +2911,8 @@ esac
 ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
 
     cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
+    # Check for configure.gnu first; this name is used for a wrapper for
+    # Metaconfig's "Configure" on case-insensitive file systems.
     if test -f "$ac_srcdir/configure.gnu"; then
       echo &&
       $SHELL "$ac_srcdir/configure.gnu" --help=recursive
@@ -2886,7 +2920,7 @@ ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
       echo &&
       $SHELL "$ac_srcdir/configure" --help=recursive
     else
-      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+      printf "%s\n" "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi || ac_status=$?
     cd "$ac_pwd" || { ac_status=$?; break; }
   done
@@ -2896,9 +2930,9 @@ test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
 Wine configure 6.21
-generated by GNU Autoconf 2.69
+generated by GNU Autoconf 2.71
 
-Copyright (C) 2012 Free Software Foundation, Inc.
+Copyright (C) 2021 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -2915,14 +2949,14 @@ fi
 ac_fn_c_try_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
+  rm -f conftest.$ac_objext conftest.beam
   if { { ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compile") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
@@ -2930,14 +2964,15 @@ $as_echo "$ac_try_echo"; } >&5
     cat conftest.er1 >&5
     mv -f conftest.er1 conftest.err
   fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
+       } && test -s conftest.$ac_objext
+then :
   ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
@@ -2953,14 +2988,14 @@ fi
 ac_fn_cxx_try_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
+  rm -f conftest.$ac_objext conftest.beam
   if { { ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compile") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
@@ -2968,14 +3003,15 @@ $as_echo "$ac_try_echo"; } >&5
     cat conftest.er1 >&5
     mv -f conftest.er1 conftest.err
   fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } && {
 	 test -z "$ac_cxx_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
+       } && test -s conftest.$ac_objext
+then :
   ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
@@ -2991,14 +3027,14 @@ fi
 ac_fn_c_try_link ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
+  rm -f conftest.$ac_objext conftest.beam conftest$ac_exeext
   if { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
@@ -3006,17 +3042,18 @@ $as_echo "$ac_try_echo"; } >&5
     cat conftest.er1 >&5
     mv -f conftest.er1 conftest.err
   fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
 	 test -x conftest$ac_exeext
-       }; then :
+       }
+then :
   ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
@@ -3031,176 +3068,6 @@ fi
 
 } # ac_fn_c_try_link
 
-# ac_fn_c_try_cpp LINENO
-# ----------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } > conftest.i && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_cpp
-
-# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists, giving a warning if it cannot be compiled using
-# the include files in INCLUDES and setting the cache variable VAR
-# accordingly.
-ac_fn_c_check_header_mongrel ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if eval \${$3+:} false; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
-$as_echo_n "checking $2 usability... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_header_compiler=yes
-else
-  ac_header_compiler=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
-$as_echo_n "checking $2 presence... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <$2>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  ac_header_preproc=yes
-else
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
-  yes:no: )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-( $as_echo "## ------------------------------------ ##
-## Report this to wine-devel@winehq.org ##
-## ------------------------------------ ##"
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=\$ac_header_compiler"
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_header_mongrel
-
-# ac_fn_c_try_run LINENO
-# ----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_c_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_run
-
 # ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
 # -------------------------------------------------------
 # Tests whether HEADER exists and can be compiled using the include files in
@@ -3208,26 +3075,28 @@ fi
 ac_fn_c_check_header_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $4
 #include <$2>
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   eval "$3=yes"
-else
+else $as_nop
   eval "$3=no"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_header_compile
@@ -3238,14 +3107,14 @@ $as_echo "$ac_res" >&6; }
 ac_fn_objc_try_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
+  rm -f conftest.$ac_objext conftest.beam
   if { { ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compile") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
@@ -3253,14 +3122,15 @@ $as_echo "$ac_try_echo"; } >&5
     cat conftest.er1 >&5
     mv -f conftest.er1 conftest.err
   fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } && {
 	 test -z "$ac_objc_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
+       } && test -s conftest.$ac_objext
+then :
   ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
@@ -3270,133 +3140,38 @@ fi
 
 } # ac_fn_objc_try_compile
 
-# ac_fn_objc_try_cpp LINENO
-# -------------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_objc_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } > conftest.i && {
-	 test -z "$ac_objc_preproc_warn_flag$ac_objc_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_objc_try_cpp
-
-# ac_fn_objc_check_header_mongrel LINENO HEADER VAR INCLUDES
+# ac_fn_objc_check_header_compile LINENO HEADER VAR INCLUDES
 # ----------------------------------------------------------
-# Tests whether HEADER exists, giving a warning if it cannot be compiled using
-# the include files in INCLUDES and setting the cache variable VAR
-# accordingly.
-ac_fn_objc_check_header_mongrel ()
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_objc_check_header_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if eval \${$3+:} false; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
-$as_echo_n "checking $2 usability... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $4
 #include <$2>
 _ACEOF
-if ac_fn_objc_try_compile "$LINENO"; then :
-  ac_header_compiler=yes
-else
-  ac_header_compiler=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
-$as_echo_n "checking $2 presence... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <$2>
-_ACEOF
-if ac_fn_objc_try_cpp "$LINENO"; then :
-  ac_header_preproc=yes
-else
-  ac_header_preproc=no
+if ac_fn_objc_try_compile "$LINENO"
+then :
+  eval "$3=yes"
+else $as_nop
+  eval "$3=no"
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_objc_preproc_warn_flag in #((
-  yes:no: )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-( $as_echo "## ------------------------------------ ##
-## Report this to wine-devel@winehq.org ##
-## ------------------------------------ ##"
-     ) | sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=\$ac_header_compiler"
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-fi
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
-} # ac_fn_objc_check_header_mongrel
+} # ac_fn_objc_check_header_compile
 
 # ac_fn_c_check_func LINENO FUNC VAR
 # ----------------------------------
@@ -3404,11 +3179,12 @@ fi
 ac_fn_c_check_func ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 /* Define $2 to an innocuous variant, in case <limits.h> declares $2.
@@ -3416,16 +3192,9 @@ else
 #define $2 innocuous_$2
 
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+   which can conflict with char $2 (); below.  */
 
+#include <limits.h>
 #undef $2
 
 /* Override any GCC internal prototype to avoid an error.
@@ -3443,61 +3212,102 @@ choke me
 #endif
 
 int
-main ()
+main (void)
 {
 return $2 ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   eval "$3=yes"
-else
+else $as_nop
   eval "$3=no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
 eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_func
 
-# ac_fn_c_check_member LINENO AGGR MEMBER VAR INCLUDES
-# ----------------------------------------------------
-# Tries to find if the field MEMBER exists in type AGGR, after including
-# INCLUDES, setting cache variable VAR accordingly.
-ac_fn_c_check_member ()
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
-$as_echo_n "checking for $2.$3... " >&6; }
-if eval \${$4+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$5
-int
-main ()
-{
-static $2 ac_aggr;
-if (ac_aggr.$3)
-return 0;
-  ;
-  return 0;
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } > conftest.i && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }
+then :
+  ac_retval=0
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_check_member LINENO AGGR MEMBER VAR INCLUDES
+# ----------------------------------------------------
+# Tries to find if the field MEMBER exists in type AGGR, after including
+# INCLUDES, setting cache variable VAR accordingly.
+ac_fn_c_check_member ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
+printf %s "checking for $2.$3... " >&6; }
+if eval test \${$4+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$5
+int
+main (void)
+{
+static $2 ac_aggr;
+if (ac_aggr.$3)
+return 0;
+  ;
+  return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   eval "$4=yes"
-else
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $5
 int
-main ()
+main (void)
 {
 static $2 ac_aggr;
 if (sizeof ac_aggr.$3)
@@ -3506,18 +3316,19 @@ return 0;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   eval "$4=yes"
-else
+else $as_nop
   eval "$4=no"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 eval ac_res=\$$4
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_member
@@ -3529,17 +3340,18 @@ $as_echo "$ac_res" >&6; }
 ac_fn_c_check_type ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   eval "$3=no"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $4
 int
-main ()
+main (void)
 {
 if (sizeof ($2))
 	 return 0;
@@ -3547,12 +3359,13 @@ if (sizeof ($2))
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $4
 int
-main ()
+main (void)
 {
 if (sizeof (($2)))
 	    return 0;
@@ -3560,29 +3373,50 @@ if (sizeof (($2)))
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-else
+else $as_nop
   eval "$3=yes"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_type
+ac_configure_args_raw=
+for ac_arg
+do
+  case $ac_arg in
+  *\'*)
+    ac_arg=`printf "%s\n" "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+  esac
+  as_fn_append ac_configure_args_raw " '$ac_arg'"
+done
+
+case $ac_configure_args_raw in
+  *$as_nl*)
+    ac_safe_unquote= ;;
+  *)
+    ac_unsafe_z='|&;<>()$`\\"*?[ ''	' # This string ends in space, tab.
+    ac_unsafe_a="$ac_unsafe_z#~"
+    ac_safe_unquote="s/ '\\([^$ac_unsafe_a][^$ac_unsafe_z]*\\)'/ \\1/g"
+    ac_configure_args_raw=`      printf "%s\n" "$ac_configure_args_raw" | sed "$ac_safe_unquote"`;;
+esac
+
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by Wine $as_me 6.21, which was
-generated by GNU Autoconf 2.69.  Invocation command line was
+generated by GNU Autoconf 2.71.  Invocation command line was
 
-  $ $0 $@
+  $ $0$ac_configure_args_raw
 
 _ACEOF
 exec 5>>config.log
@@ -3615,8 +3449,12 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    $as_echo "PATH: $as_dir"
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    printf "%s\n" "PATH: $as_dir"
   done
 IFS=$as_save_IFS
 
@@ -3651,7 +3489,7 @@ do
     | -silent | --silent | --silen | --sile | --sil)
       continue ;;
     *\'*)
-      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+      ac_arg=`printf "%s\n" "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
     case $ac_pass in
     1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
@@ -3686,11 +3524,13 @@ done
 # WARNING: Use '\'' to represent an apostrophe within the trap.
 # WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
 trap 'exit_status=$?
+  # Sanitize IFS.
+  IFS=" ""	$as_nl"
   # Save into config.log some information that might help in debugging.
   {
     echo
 
-    $as_echo "## ---------------- ##
+    printf "%s\n" "## ---------------- ##
 ## Cache variables. ##
 ## ---------------- ##"
     echo
@@ -3701,8 +3541,8 @@ trap 'exit_status=$?
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      *_cv_*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+printf "%s\n" "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
@@ -3726,7 +3566,7 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
 )
     echo
 
-    $as_echo "## ----------------- ##
+    printf "%s\n" "## ----------------- ##
 ## Output variables. ##
 ## ----------------- ##"
     echo
@@ -3734,14 +3574,14 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
     do
       eval ac_val=\$$ac_var
       case $ac_val in
-      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      *\'\''*) ac_val=`printf "%s\n" "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
       esac
-      $as_echo "$ac_var='\''$ac_val'\''"
+      printf "%s\n" "$ac_var='\''$ac_val'\''"
     done | sort
     echo
 
     if test -n "$ac_subst_files"; then
-      $as_echo "## ------------------- ##
+      printf "%s\n" "## ------------------- ##
 ## File substitutions. ##
 ## ------------------- ##"
       echo
@@ -3749,15 +3589,15 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       do
 	eval ac_val=\$$ac_var
 	case $ac_val in
-	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	*\'\''*) ac_val=`printf "%s\n" "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
 	esac
-	$as_echo "$ac_var='\''$ac_val'\''"
+	printf "%s\n" "$ac_var='\''$ac_val'\''"
       done | sort
       echo
     fi
 
     if test -s confdefs.h; then
-      $as_echo "## ----------- ##
+      printf "%s\n" "## ----------- ##
 ## confdefs.h. ##
 ## ----------- ##"
       echo
@@ -3765,8 +3605,8 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       echo
     fi
     test "$ac_signal" != 0 &&
-      $as_echo "$as_me: caught signal $ac_signal"
-    $as_echo "$as_me: exit $exit_status"
+      printf "%s\n" "$as_me: caught signal $ac_signal"
+    printf "%s\n" "$as_me: exit $exit_status"
   } >&5
   rm -f core *.core core.conftest.* &&
     rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
@@ -3780,63 +3620,48 @@ ac_signal=0
 # confdefs.h avoids OS command line length limits that DEFS can exceed.
 rm -f -r conftest* confdefs.h
 
-$as_echo "/* confdefs.h */" > confdefs.h
+printf "%s\n" "/* confdefs.h */" > confdefs.h
 
 # Predefined preprocessor variables.
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
+printf "%s\n" "#define PACKAGE_NAME \"$PACKAGE_NAME\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
+printf "%s\n" "#define PACKAGE_TARNAME \"$PACKAGE_TARNAME\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
+printf "%s\n" "#define PACKAGE_VERSION \"$PACKAGE_VERSION\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
+printf "%s\n" "#define PACKAGE_STRING \"$PACKAGE_STRING\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
+printf "%s\n" "#define PACKAGE_BUGREPORT \"$PACKAGE_BUGREPORT\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_URL "$PACKAGE_URL"
-_ACEOF
+printf "%s\n" "#define PACKAGE_URL \"$PACKAGE_URL\"" >>confdefs.h
 
 
 # Let the site file select an alternate cache file if it wants to.
 # Prefer an explicitly selected file to automatically selected ones.
-ac_site_file1=NONE
-ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  # We do not want a PATH search for config.site.
-  case $CONFIG_SITE in #((
-    -*)  ac_site_file1=./$CONFIG_SITE;;
-    */*) ac_site_file1=$CONFIG_SITE;;
-    *)   ac_site_file1=./$CONFIG_SITE;;
-  esac
+  ac_site_files="$CONFIG_SITE"
 elif test "x$prefix" != xNONE; then
-  ac_site_file1=$prefix/share/config.site
-  ac_site_file2=$prefix/etc/config.site
+  ac_site_files="$prefix/share/config.site $prefix/etc/config.site"
 else
-  ac_site_file1=$ac_default_prefix/share/config.site
-  ac_site_file2=$ac_default_prefix/etc/config.site
+  ac_site_files="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
 fi
-for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+
+for ac_site_file in $ac_site_files
 do
-  test "x$ac_site_file" = xNONE && continue
-  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
-$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+  case $ac_site_file in #(
+  */*) :
+     ;; #(
+  *) :
+    ac_site_file=./$ac_site_file ;;
+esac
+  if test -f "$ac_site_file" && test -r "$ac_site_file"; then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+printf "%s\n" "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
     . "$ac_site_file" \
-      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+      || { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "failed to load site script $ac_site_file
 See \`config.log' for more details" "$LINENO" 5; }
   fi
@@ -3846,482 +3671,1161 @@ if test -r "$cache_file"; then
   # Some versions of bash will fail to source /dev/null (special files
   # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
   if test /dev/null != "$cache_file" && test -f "$cache_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
-$as_echo "$as_me: loading cache $cache_file" >&6;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+printf "%s\n" "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
       [\\/]* | ?:[\\/]* ) . "$cache_file";;
       *)                      . "./$cache_file";;
     esac
   fi
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
-$as_echo "$as_me: creating cache $cache_file" >&6;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+printf "%s\n" "$as_me: creating cache $cache_file" >&6;}
   >$cache_file
 fi
 
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	# differences in whitespace do not lead to failure.
-	ac_old_val_w=`echo x $ac_old_val`
-	ac_new_val_w=`echo x $ac_new_val`
-	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
-$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	  ac_cache_corrupted=:
-	else
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
-$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
-	  eval $ac_var=\$ac_old_val
-	fi
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
-$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
-$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
-$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
-fi
-## -------------------- ##
-## Main body of script. ##
-## -------------------- ##
+# Test code for whether the C compiler supports C89 (global declarations)
+ac_c_conftest_c89_globals='
+/* Does the compiler advertise C89 conformance?
+   Do not test the value of __STDC__, because some compilers set it to 0
+   while being otherwise adequately conformant. */
+#if !defined __STDC__
+# error "Compiler does not advertise C89 conformance"
+#endif
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+#include <stddef.h>
+#include <stdarg.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7 src/conf.sh.  */
+struct buf { int x; };
+struct buf * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
 
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not \xHH hex character constants.
+   These do not provoke an error unfortunately, instead are silently treated
+   as an "x".  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously \x00 != x always comes out true, for an
+   array size at least.  It is necessary to write \x00 == 0 to get something
+   that is true only with -std.  */
+int osf4_cc_array ['\''\x00'\'' == 0 ? 1 : -1];
 
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) '\''x'\''
+int xlc6_cc_array[FOO(a) == '\''x'\'' ? 1 : -1];
 
-ac_config_headers="$ac_config_headers include/config.h"
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, int *(*)(struct buf *, struct stat *, int),
+               int, int);'
 
-ac_aux_dir=
-for ac_dir in tools "$srcdir"/tools; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error $? "cannot find install-sh, install.sh, or shtool in tools \"$srcdir\"/tools" "$LINENO" 5
-fi
+# Test code for whether the C compiler supports C89 (body of main).
+ac_c_conftest_c89_main='
+ok |= (argc == 0 || f (e, argv, 0) != argv[0] || f (e, argv, 1) != argv[1]);
+'
 
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+# Test code for whether the C compiler supports C99 (global declarations)
+ac_c_conftest_c99_globals='
+// Does the compiler advertise C99 conformance?
+#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L
+# error "Compiler does not advertise C99 conformance"
+#endif
 
+#include <stdbool.h>
+extern int puts (const char *);
+extern int printf (const char *, ...);
+extern int dprintf (int, const char *, ...);
+extern void *malloc (size_t);
+
+// Check varargs macros.  These examples are taken from C99 6.10.3.5.
+// dprintf is used instead of fprintf to avoid needing to declare
+// FILE and stderr.
+#define debug(...) dprintf (2, __VA_ARGS__)
+#define showlist(...) puts (#__VA_ARGS__)
+#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))
+static void
+test_varargs_macros (void)
+{
+  int x = 1234;
+  int y = 5678;
+  debug ("Flag");
+  debug ("X = %d\n", x);
+  showlist (The first, second, and third items.);
+  report (x>y, "x is %d but y is %d", x, y);
+}
 
+// Check long long types.
+#define BIG64 18446744073709551615ull
+#define BIG32 4294967295ul
+#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)
+#if !BIG_OK
+  #error "your preprocessor is broken"
+#endif
+#if BIG_OK
+#else
+  #error "your preprocessor is broken"
+#endif
+static long long int bignum = -9223372036854775807LL;
+static unsigned long long int ubignum = BIG64;
 
-libwine_version="1.0"
+struct incomplete_array
+{
+  int datasize;
+  double data[];
+};
 
+struct named_init {
+  int number;
+  const wchar_t *name;
+  double average;
+};
 
+typedef const char *ccp;
 
-# Check whether --enable-win16 was given.
-if test "${enable_win16+set}" = set; then :
-  enableval=$enable_win16;
-fi
+static inline int
+test_restrict (ccp restrict text)
+{
+  // See if C++-style comments work.
+  // Iterate through items via the restricted pointer.
+  // Also check for declarations in for loops.
+  for (unsigned int i = 0; *(text+i) != '\''\0'\''; ++i)
+    continue;
+  return 0;
+}
 
-# Check whether --enable-win64 was given.
-if test "${enable_win64+set}" = set; then :
-  enableval=$enable_win64;
-fi
+// Check varargs and va_copy.
+static bool
+test_varargs (const char *format, ...)
+{
+  va_list args;
+  va_start (args, format);
+  va_list args_copy;
+  va_copy (args_copy, args);
 
-# Check whether --enable-tests was given.
-if test "${enable_tests+set}" = set; then :
-  enableval=$enable_tests;
-fi
+  const char *str = "";
+  int number = 0;
+  float fnumber = 0;
 
-# Check whether --enable-build-id was given.
-if test "${enable_build_id+set}" = set; then :
-  enableval=$enable_build_id;
-fi
+  while (*format)
+    {
+      switch (*format++)
+	{
+	case '\''s'\'': // string
+	  str = va_arg (args_copy, const char *);
+	  break;
+	case '\''d'\'': // int
+	  number = va_arg (args_copy, int);
+	  break;
+	case '\''f'\'': // float
+	  fnumber = va_arg (args_copy, double);
+	  break;
+	default:
+	  break;
+	}
+    }
+  va_end (args_copy);
+  va_end (args);
 
-# Check whether --enable-maintainer-mode was given.
-if test "${enable_maintainer_mode+set}" = set; then :
-  enableval=$enable_maintainer_mode;
-fi
+  return *str && number && fnumber;
+}
+'
 
-# Check whether --enable-silent-rules was given.
-if test "${enable_silent_rules+set}" = set; then :
-  enableval=$enable_silent_rules;
-fi
+# Test code for whether the C compiler supports C99 (body of main).
+ac_c_conftest_c99_main='
+  // Check bool.
+  _Bool success = false;
+  success |= (argc != 0);
+
+  // Check restrict.
+  if (test_restrict ("String literal") == 0)
+    success = true;
+  char *restrict newvar = "Another string";
+
+  // Check varargs.
+  success &= test_varargs ("s, d'\'' f .", "string", 65, 34.234);
+  test_varargs_macros ();
+
+  // Check flexible array members.
+  struct incomplete_array *ia =
+    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));
+  ia->datasize = 10;
+  for (int i = 0; i < ia->datasize; ++i)
+    ia->data[i] = i * 1.234;
+
+  // Check named initializers.
+  struct named_init ni = {
+    .number = 34,
+    .name = L"Test wide string",
+    .average = 543.34343,
+  };
+
+  ni.number = 58;
+
+  int dynamic_array[ni.number];
+  dynamic_array[0] = argv[0][0];
+  dynamic_array[ni.number - 1] = 543;
+
+  // work around unused variable warnings
+  ok |= (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == '\''x'\''
+	 || dynamic_array[ni.number - 1] != 543);
+'
 
-# Check whether --enable-werror was given.
-if test "${enable_werror+set}" = set; then :
-  enableval=$enable_werror;
-fi
+# Test code for whether the C compiler supports C11 (global declarations)
+ac_c_conftest_c11_globals='
+// Does the compiler advertise C11 conformance?
+#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L
+# error "Compiler does not advertise C11 conformance"
+#endif
 
+// Check _Alignas.
+char _Alignas (double) aligned_as_double;
+char _Alignas (0) no_special_alignment;
+extern char aligned_as_int;
+char _Alignas (0) _Alignas (int) aligned_as_int;
 
+// Check _Alignof.
+enum
+{
+  int_alignment = _Alignof (int),
+  int_array_alignment = _Alignof (int[100]),
+  char_alignment = _Alignof (char)
+};
+_Static_assert (0 < -_Alignof (int), "_Alignof is signed");
 
-# Check whether --with-alsa was given.
-if test "${with_alsa+set}" = set; then :
-  withval=$with_alsa;
-fi
+// Check _Noreturn.
+int _Noreturn does_not_return (void) { for (;;) continue; }
 
+// Check _Static_assert.
+struct test_static_assert
+{
+  int x;
+  _Static_assert (sizeof (int) <= sizeof (long int),
+                  "_Static_assert does not work in struct");
+  long int y;
+};
+
+// Check UTF-8 literals.
+#define u8 syntax error!
+char const utf8_literal[] = u8"happens to be ASCII" "another string";
+
+// Check duplicate typedefs.
+typedef long *long_ptr;
+typedef long int *long_ptr;
+typedef long_ptr long_ptr;
+
+// Anonymous structures and unions -- taken from C11 6.7.2.1 Example 1.
+struct anonymous
+{
+  union {
+    struct { int i; int j; };
+    struct { int k; long int l; } w;
+  };
+  int m;
+} v1;
+'
 
-# Check whether --with-capi was given.
-if test "${with_capi+set}" = set; then :
-  withval=$with_capi;
-fi
+# Test code for whether the C compiler supports C11 (body of main).
+ac_c_conftest_c11_main='
+  _Static_assert ((offsetof (struct anonymous, i)
+		   == offsetof (struct anonymous, w.k)),
+		  "Anonymous union alignment botch");
+  v1.i = 2;
+  v1.w.k = 5;
+  ok |= v1.i != 5;
+'
 
+# Test code for whether the C compiler supports C11 (complete).
+ac_c_conftest_c11_program="${ac_c_conftest_c89_globals}
+${ac_c_conftest_c99_globals}
+${ac_c_conftest_c11_globals}
 
-# Check whether --with-coreaudio was given.
-if test "${with_coreaudio+set}" = set; then :
-  withval=$with_coreaudio; if test "x$withval" = "xno"; then ac_cv_header_CoreAudio_CoreAudio_h=no; fi
-fi
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  ${ac_c_conftest_c99_main}
+  ${ac_c_conftest_c11_main}
+  return ok;
+}
+"
 
+# Test code for whether the C compiler supports C99 (complete).
+ac_c_conftest_c99_program="${ac_c_conftest_c89_globals}
+${ac_c_conftest_c99_globals}
 
-# Check whether --with-cups was given.
-if test "${with_cups+set}" = set; then :
-  withval=$with_cups;
-fi
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  ${ac_c_conftest_c99_main}
+  return ok;
+}
+"
 
+# Test code for whether the C compiler supports C89 (complete).
+ac_c_conftest_c89_program="${ac_c_conftest_c89_globals}
 
-# Check whether --with-dbus was given.
-if test "${with_dbus+set}" = set; then :
-  withval=$with_dbus;
-fi
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  return ok;
+}
+"
 
+# Test code for whether the C++ compiler supports C++98 (global declarations)
+ac_cxx_conftest_cxx98_globals='
+// Does the compiler advertise C++98 conformance?
+#if !defined __cplusplus || __cplusplus < 199711L
+# error "Compiler does not advertise C++98 conformance"
+#endif
 
-# Check whether --with-float-abi was given.
-if test "${with_float_abi+set}" = set; then :
-  withval=$with_float_abi;
-fi
+// These inclusions are to reject old compilers that
+// lack the unsuffixed header files.
+#include <cstdlib>
+#include <exception>
 
+// <cassert> and <cstring> are *not* freestanding headers in C++98.
+extern void assert (int);
+namespace std {
+  extern int strcmp (const char *, const char *);
+}
 
-# Check whether --with-fontconfig was given.
-if test "${with_fontconfig+set}" = set; then :
-  withval=$with_fontconfig;
-fi
+// Namespaces, exceptions, and templates were all added after "C++ 2.0".
+using std::exception;
+using std::strcmp;
 
+namespace {
 
-# Check whether --with-freetype was given.
-if test "${with_freetype+set}" = set; then :
-  withval=$with_freetype;
-fi
+void test_exception_syntax()
+{
+  try {
+    throw "test";
+  } catch (const char *s) {
+    // Extra parentheses suppress a warning when building autoconf itself,
+    // due to lint rules shared with more typical C programs.
+    assert (!(strcmp) (s, "test"));
+  }
+}
 
+template <typename T> struct test_template
+{
+  T const val;
+  explicit test_template(T t) : val(t) {}
+  template <typename U> T add(U u) { return static_cast<T>(u) + val; }
+};
 
-# Check whether --with-gettext was given.
-if test "${with_gettext+set}" = set; then :
-  withval=$with_gettext;
-fi
+} // anonymous namespace
+'
 
+# Test code for whether the C++ compiler supports C++98 (body of main)
+ac_cxx_conftest_cxx98_main='
+  assert (argc);
+  assert (! argv[0]);
+{
+  test_exception_syntax ();
+  test_template<double> tt (2.0);
+  assert (tt.add (4) == 6.0);
+  assert (true && !false);
+}
+'
 
-# Check whether --with-gettextpo was given.
-if test "${with_gettextpo+set}" = set; then :
-  withval=$with_gettextpo; if test "x$withval" = "xno"; then ac_cv_header_gettext_po_h=no; fi
-fi
+# Test code for whether the C++ compiler supports C++11 (global declarations)
+ac_cxx_conftest_cxx11_globals='
+// Does the compiler advertise C++ 2011 conformance?
+#if !defined __cplusplus || __cplusplus < 201103L
+# error "Compiler does not advertise C++11 conformance"
+#endif
 
+namespace cxx11test
+{
+  constexpr int get_val() { return 20; }
 
-# Check whether --with-gphoto was given.
-if test "${with_gphoto+set}" = set; then :
-  withval=$with_gphoto;
-fi
+  struct testinit
+  {
+    int i;
+    double d;
+  };
 
+  class delegate
+  {
+  public:
+    delegate(int n) : n(n) {}
+    delegate(): delegate(2354) {}
 
-# Check whether --with-gnutls was given.
-if test "${with_gnutls+set}" = set; then :
-  withval=$with_gnutls;
-fi
+    virtual int getval() { return this->n; };
+  protected:
+    int n;
+  };
+
+  class overridden : public delegate
+  {
+  public:
+    overridden(int n): delegate(n) {}
+    virtual int getval() override final { return this->n * 2; }
+  };
+
+  class nocopy
+  {
+  public:
+    nocopy(int i): i(i) {}
+    nocopy() = default;
+    nocopy(const nocopy&) = delete;
+    nocopy & operator=(const nocopy&) = delete;
+  private:
+    int i;
+  };
+
+  // for testing lambda expressions
+  template <typename Ret, typename Fn> Ret eval(Fn f, Ret v)
+  {
+    return f(v);
+  }
+
+  // for testing variadic templates and trailing return types
+  template <typename V> auto sum(V first) -> V
+  {
+    return first;
+  }
+  template <typename V, typename... Args> auto sum(V first, Args... rest) -> V
+  {
+    return first + sum(rest...);
+  }
+}
+'
+
+# Test code for whether the C++ compiler supports C++11 (body of main)
+ac_cxx_conftest_cxx11_main='
+{
+  // Test auto and decltype
+  auto a1 = 6538;
+  auto a2 = 48573953.4;
+  auto a3 = "String literal";
+
+  int total = 0;
+  for (auto i = a3; *i; ++i) { total += *i; }
+
+  decltype(a2) a4 = 34895.034;
+}
+{
+  // Test constexpr
+  short sa[cxx11test::get_val()] = { 0 };
+}
+{
+  // Test initializer lists
+  cxx11test::testinit il = { 4323, 435234.23544 };
+}
+{
+  // Test range-based for
+  int array[] = {9, 7, 13, 15, 4, 18, 12, 10, 5, 3,
+                 14, 19, 17, 8, 6, 20, 16, 2, 11, 1};
+  for (auto &x : array) { x += 23; }
+}
+{
+  // Test lambda expressions
+  using cxx11test::eval;
+  assert (eval ([](int x) { return x*2; }, 21) == 42);
+  double d = 2.0;
+  assert (eval ([&](double x) { return d += x; }, 3.0) == 5.0);
+  assert (d == 5.0);
+  assert (eval ([=](double x) mutable { return d += x; }, 4.0) == 9.0);
+  assert (d == 5.0);
+}
+{
+  // Test use of variadic templates
+  using cxx11test::sum;
+  auto a = sum(1);
+  auto b = sum(1, 2);
+  auto c = sum(1.0, 2.0, 3.0);
+}
+{
+  // Test constructor delegation
+  cxx11test::delegate d1;
+  cxx11test::delegate d2();
+  cxx11test::delegate d3(45);
+}
+{
+  // Test override and final
+  cxx11test::overridden o1(55464);
+}
+{
+  // Test nullptr
+  char *c = nullptr;
+}
+{
+  // Test template brackets
+  test_template<::test_template<int>> v(test_template<int>(12));
+}
+{
+  // Unicode literals
+  char const *utf8 = u8"UTF-8 string \u2500";
+  char16_t const *utf16 = u"UTF-8 string \u2500";
+  char32_t const *utf32 = U"UTF-32 string \u2500";
+}
+'
+
+# Test code for whether the C compiler supports C++11 (complete).
+ac_cxx_conftest_cxx11_program="${ac_cxx_conftest_cxx98_globals}
+${ac_cxx_conftest_cxx11_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_cxx_conftest_cxx98_main}
+  ${ac_cxx_conftest_cxx11_main}
+  return ok;
+}
+"
+
+# Test code for whether the C compiler supports C++98 (complete).
+ac_cxx_conftest_cxx98_program="${ac_cxx_conftest_cxx98_globals}
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_cxx_conftest_cxx98_main}
+  return ok;
+}
+"
+
+as_fn_append ac_header_c_list " stdio.h stdio_h HAVE_STDIO_H"
+as_fn_append ac_header_c_list " stdlib.h stdlib_h HAVE_STDLIB_H"
+as_fn_append ac_header_c_list " string.h string_h HAVE_STRING_H"
+as_fn_append ac_header_c_list " inttypes.h inttypes_h HAVE_INTTYPES_H"
+as_fn_append ac_header_c_list " stdint.h stdint_h HAVE_STDINT_H"
+as_fn_append ac_header_c_list " strings.h strings_h HAVE_STRINGS_H"
+as_fn_append ac_header_c_list " sys/stat.h sys_stat_h HAVE_SYS_STAT_H"
+as_fn_append ac_header_c_list " sys/types.h sys_types_h HAVE_SYS_TYPES_H"
+as_fn_append ac_header_c_list " unistd.h unistd_h HAVE_UNISTD_H"
+
+# Auxiliary files required by this configure script.
+ac_aux_files="config.guess config.sub"
+
+# Locations in which to look for auxiliary files.
+ac_aux_dir_candidates="${srcdir}/tools"
+
+# Search for a directory containing all of the required auxiliary files,
+# $ac_aux_files, from the $PATH-style list $ac_aux_dir_candidates.
+# If we don't find one directory that contains all the files we need,
+# we report the set of missing files from the *first* directory in
+# $ac_aux_dir_candidates and give up.
+ac_missing_aux_files=""
+ac_first_candidate=:
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: looking for aux files: $ac_aux_files" >&5
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in $ac_aux_dir_candidates
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+  as_found=:
+
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}:  trying $as_dir" >&5
+  ac_aux_dir_found=yes
+  ac_install_sh=
+  for ac_aux in $ac_aux_files
+  do
+    # As a special case, if "install-sh" is required, that requirement
+    # can be satisfied by any of "install-sh", "install.sh", or "shtool",
+    # and $ac_install_sh is set appropriately for whichever one is found.
+    if test x"$ac_aux" = x"install-sh"
+    then
+      if test -f "${as_dir}install-sh"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}install-sh found" >&5
+        ac_install_sh="${as_dir}install-sh -c"
+      elif test -f "${as_dir}install.sh"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}install.sh found" >&5
+        ac_install_sh="${as_dir}install.sh -c"
+      elif test -f "${as_dir}shtool"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}shtool found" >&5
+        ac_install_sh="${as_dir}shtool install -c"
+      else
+        ac_aux_dir_found=no
+        if $ac_first_candidate; then
+          ac_missing_aux_files="${ac_missing_aux_files} install-sh"
+        else
+          break
+        fi
+      fi
+    else
+      if test -f "${as_dir}${ac_aux}"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}${ac_aux} found" >&5
+      else
+        ac_aux_dir_found=no
+        if $ac_first_candidate; then
+          ac_missing_aux_files="${ac_missing_aux_files} ${ac_aux}"
+        else
+          break
+        fi
+      fi
+    fi
+  done
+  if test "$ac_aux_dir_found" = yes; then
+    ac_aux_dir="$as_dir"
+    break
+  fi
+  ac_first_candidate=false
+
+  as_found=false
+done
+IFS=$as_save_IFS
+if $as_found
+then :
+
+else $as_nop
+  as_fn_error $? "cannot find required auxiliary files:$ac_missing_aux_files" "$LINENO" 5
+fi
+
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+if test -f "${ac_aux_dir}config.guess"; then
+  ac_config_guess="$SHELL ${ac_aux_dir}config.guess"
+fi
+if test -f "${ac_aux_dir}config.sub"; then
+  ac_config_sub="$SHELL ${ac_aux_dir}config.sub"
+fi
+if test -f "$ac_aux_dir/configure"; then
+  ac_configure="$SHELL ${ac_aux_dir}configure"
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+printf "%s\n" "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+printf "%s\n" "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+printf "%s\n" "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+printf "%s\n" "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+printf "%s\n" "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+printf "%s\n" "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`printf "%s\n" "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+printf "%s\n" "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`${MAKE-make} distclean' and/or \`rm $cache_file'
+	    and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+ac_config_headers="$ac_config_headers include/config.h"
+
+
+
+libwine_version="1.0"
+
+
+
+# Check whether --enable-win16 was given.
+if test ${enable_win16+y}
+then :
+  enableval=$enable_win16;
+fi
+
+# Check whether --enable-win64 was given.
+if test ${enable_win64+y}
+then :
+  enableval=$enable_win64;
+fi
+
+# Check whether --enable-tests was given.
+if test ${enable_tests+y}
+then :
+  enableval=$enable_tests;
+fi
+
+# Check whether --enable-build-id was given.
+if test ${enable_build_id+y}
+then :
+  enableval=$enable_build_id;
+fi
+
+# Check whether --enable-maintainer-mode was given.
+if test ${enable_maintainer_mode+y}
+then :
+  enableval=$enable_maintainer_mode;
+fi
+
+# Check whether --enable-silent-rules was given.
+if test ${enable_silent_rules+y}
+then :
+  enableval=$enable_silent_rules;
+fi
+
+# Check whether --enable-werror was given.
+if test ${enable_werror+y}
+then :
+  enableval=$enable_werror;
+fi
+
+
+
+# Check whether --with-alsa was given.
+if test ${with_alsa+y}
+then :
+  withval=$with_alsa;
+fi
+
+
+# Check whether --with-capi was given.
+if test ${with_capi+y}
+then :
+  withval=$with_capi;
+fi
+
+
+# Check whether --with-coreaudio was given.
+if test ${with_coreaudio+y}
+then :
+  withval=$with_coreaudio; if test "x$withval" = "xno"; then ac_cv_header_CoreAudio_CoreAudio_h=no; fi
+fi
+
+
+# Check whether --with-cups was given.
+if test ${with_cups+y}
+then :
+  withval=$with_cups;
+fi
+
+
+# Check whether --with-dbus was given.
+if test ${with_dbus+y}
+then :
+  withval=$with_dbus;
+fi
+
+
+# Check whether --with-float-abi was given.
+if test ${with_float_abi+y}
+then :
+  withval=$with_float_abi;
+fi
+
+
+# Check whether --with-fontconfig was given.
+if test ${with_fontconfig+y}
+then :
+  withval=$with_fontconfig;
+fi
+
+
+# Check whether --with-freetype was given.
+if test ${with_freetype+y}
+then :
+  withval=$with_freetype;
+fi
+
+
+# Check whether --with-gcrypt was given.
+if test ${with_gcrypt+y}
+then :
+  withval=$with_gcrypt;
+fi
+
+
+# Check whether --with-gettext was given.
+if test ${with_gettext+y}
+then :
+  withval=$with_gettext;
+fi
+
+
+# Check whether --with-gettextpo was given.
+if test ${with_gettextpo+y}
+then :
+  withval=$with_gettextpo; if test "x$withval" = "xno"; then ac_cv_header_gettext_po_h=no; fi
+fi
+
+
+# Check whether --with-gphoto was given.
+if test ${with_gphoto+y}
+then :
+  withval=$with_gphoto;
+fi
+
+
+# Check whether --with-gnutls was given.
+if test ${with_gnutls+y}
+then :
+  withval=$with_gnutls;
+fi
 
 
 # Check whether --with-gssapi was given.
-if test "${with_gssapi+set}" = set; then :
+if test ${with_gssapi+y}
+then :
   withval=$with_gssapi;
 fi
 
 
 # Check whether --with-gstreamer was given.
-if test "${with_gstreamer+set}" = set; then :
+if test ${with_gstreamer+y}
+then :
   withval=$with_gstreamer;
 fi
 
 
 # Check whether --with-hal was given.
-if test "${with_hal+set}" = set; then :
+if test ${with_hal+y}
+then :
   withval=$with_hal;
 fi
 
 
 # Check whether --with-inotify was given.
-if test "${with_inotify+set}" = set; then :
+if test ${with_inotify+y}
+then :
   withval=$with_inotify;
 fi
 
 
 # Check whether --with-krb5 was given.
-if test "${with_krb5+set}" = set; then :
+if test ${with_krb5+y}
+then :
   withval=$with_krb5;
 fi
 
 
 # Check whether --with-ldap was given.
-if test "${with_ldap+set}" = set; then :
+if test ${with_ldap+y}
+then :
   withval=$with_ldap; if test "x$withval" = "xno"; then ac_cv_header_ldap_h=no; ac_cv_header_lber_h=no; fi
 fi
 
 
 # Check whether --with-mingw was given.
-if test "${with_mingw+set}" = set; then :
+if test ${with_mingw+y}
+then :
   withval=$with_mingw;
 fi
 
 
 # Check whether --with-netapi was given.
-if test "${with_netapi+set}" = set; then :
+if test ${with_netapi+y}
+then :
   withval=$with_netapi;
 fi
 
 
 # Check whether --with-openal was given.
-if test "${with_openal+set}" = set; then :
+if test ${with_openal+y}
+then :
   withval=$with_openal; if test "x$withval" = "xno"; then ac_cv_header_AL_al_h=no; ac_cv_header_OpenAL_al_h=no; fi
 fi
 
 
 # Check whether --with-opencl was given.
-if test "${with_opencl+set}" = set; then :
+if test ${with_opencl+y}
+then :
   withval=$with_opencl; if test "x$withval" = "xno"; then ac_cv_header_CL_cl_h=no; ac_cv_header_OpenCL_opencl_h=no; fi
 fi
 
 
 # Check whether --with-opengl was given.
-if test "${with_opengl+set}" = set; then :
+if test ${with_opengl+y}
+then :
   withval=$with_opengl;
 fi
 
 
 # Check whether --with-osmesa was given.
-if test "${with_osmesa+set}" = set; then :
+if test ${with_osmesa+y}
+then :
   withval=$with_osmesa;
 fi
 
 
 # Check whether --with-oss was given.
-if test "${with_oss+set}" = set; then :
+if test ${with_oss+y}
+then :
   withval=$with_oss;
 fi
 
 
 # Check whether --with-pcap was given.
-if test "${with_pcap+set}" = set; then :
+if test ${with_pcap+y}
+then :
   withval=$with_pcap; if test "x$withval" = "xno"; then ac_cv_header_pcap_pcap_h=no; fi
 fi
 
 
 # Check whether --with-pthread was given.
-if test "${with_pthread+set}" = set; then :
+if test ${with_pthread+y}
+then :
   withval=$with_pthread; if test "x$withval" = "xno"; then ac_cv_header_pthread_h=no; fi
 fi
 
 
 # Check whether --with-pulse was given.
-if test "${with_pulse+set}" = set; then :
+if test ${with_pulse+y}
+then :
   withval=$with_pulse;
 fi
 
 
 # Check whether --with-quicktime was given.
-if test "${with_quicktime+set}" = set; then :
+if test ${with_quicktime+y}
+then :
   withval=$with_quicktime;
 fi
 
 
 # Check whether --with-sane was given.
-if test "${with_sane+set}" = set; then :
+if test ${with_sane+y}
+then :
   withval=$with_sane;
 fi
 
 
 # Check whether --with-sdl was given.
-if test "${with_sdl+set}" = set; then :
+if test ${with_sdl+y}
+then :
   withval=$with_sdl;
 fi
 
 
 # Check whether --with-udev was given.
-if test "${with_udev+set}" = set; then :
+if test ${with_udev+y}
+then :
   withval=$with_udev;
 fi
 
 
 # Check whether --with-unwind was given.
-if test "${with_unwind+set}" = set; then :
+if test ${with_unwind+y}
+then :
   withval=$with_unwind;
 fi
 
 
 # Check whether --with-usb was given.
-if test "${with_usb+set}" = set; then :
+if test ${with_usb+y}
+then :
   withval=$with_usb;
 fi
 
 
 # Check whether --with-v4l2 was given.
-if test "${with_v4l2+set}" = set; then :
+if test ${with_v4l2+y}
+then :
   withval=$with_v4l2;
 fi
 
 
 # Check whether --with-vkd3d was given.
-if test "${with_vkd3d+set}" = set; then :
+if test ${with_vkd3d+y}
+then :
   withval=$with_vkd3d;
 fi
 
 
 # Check whether --with-vulkan was given.
-if test "${with_vulkan+set}" = set; then :
+if test ${with_vulkan+y}
+then :
   withval=$with_vulkan;
 fi
 
 
 # Check whether --with-xcomposite was given.
-if test "${with_xcomposite+set}" = set; then :
+if test ${with_xcomposite+y}
+then :
   withval=$with_xcomposite; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi
 fi
 
 
 # Check whether --with-xcursor was given.
-if test "${with_xcursor+set}" = set; then :
+if test ${with_xcursor+y}
+then :
   withval=$with_xcursor; if test "x$withval" = "xno"; then ac_cv_header_X11_Xcursor_Xcursor_h=no; fi
 fi
 
 
 # Check whether --with-xfixes was given.
-if test "${with_xfixes+set}" = set; then :
+if test ${with_xfixes+y}
+then :
   withval=$with_xfixes; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xfixes_h=no; fi
 fi
 
 
 # Check whether --with-xinerama was given.
-if test "${with_xinerama+set}" = set; then :
+if test ${with_xinerama+y}
+then :
   withval=$with_xinerama; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xinerama_h=no; fi
 fi
 
 
 # Check whether --with-xinput was given.
-if test "${with_xinput+set}" = set; then :
+if test ${with_xinput+y}
+then :
   withval=$with_xinput; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput_h=no; fi
 fi
 
 
 # Check whether --with-xinput2 was given.
-if test "${with_xinput2+set}" = set; then :
+if test ${with_xinput2+y}
+then :
   withval=$with_xinput2; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput2_h=no; fi
 fi
 
 
+# Check whether --with-xpresent was given.
+if test ${with_xpresent+y}
+then :
+  withval=$with_xpresent; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xpresent_h=no; fi
+fi
+
+
 # Check whether --with-xrandr was given.
-if test "${with_xrandr+set}" = set; then :
+if test ${with_xrandr+y}
+then :
   withval=$with_xrandr; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrandr_h=no; fi
 fi
 
 
 # Check whether --with-xrender was given.
-if test "${with_xrender+set}" = set; then :
+if test ${with_xrender+y}
+then :
   withval=$with_xrender; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrender_h=no; fi
 fi
 
 
 # Check whether --with-xshape was given.
-if test "${with_xshape+set}" = set; then :
+if test ${with_xshape+y}
+then :
   withval=$with_xshape; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_shape_h=no; fi
 fi
 
 
 # Check whether --with-xshm was given.
-if test "${with_xshm+set}" = set; then :
+if test ${with_xshm+y}
+then :
   withval=$with_xshm; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XShm_h=no; fi
 fi
 
 
 # Check whether --with-xxf86vm was given.
-if test "${with_xxf86vm+set}" = set; then :
+if test ${with_xxf86vm+y}
+then :
   withval=$with_xxf86vm; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi
 fi
 
 
 
 # Check whether --with-wine-tools was given.
-if test "${with_wine_tools+set}" = set; then :
+if test ${with_wine_tools+y}
+then :
   withval=$with_wine_tools;
 fi
 
 
 # Check whether --with-wine64 was given.
-if test "${with_wine64+set}" = set; then :
+if test ${with_wine64+y}
+then :
   withval=$with_wine64;
 fi
 
 
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
-$as_echo_n "checking build system type... " >&6; }
-if ${ac_cv_build+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+
+
+  # Make sure we can run config.sub.
+$SHELL "${ac_aux_dir}config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL ${ac_aux_dir}config.sub" "$LINENO" 5
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+printf %s "checking build system type... " >&6; }
+if test ${ac_cv_build+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_build_alias=$build_alias
 test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+  ac_build_alias=`$SHELL "${ac_aux_dir}config.guess"`
 test "x$ac_build_alias" = x &&
   as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+ac_cv_build=`$SHELL "${ac_aux_dir}config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL ${ac_aux_dir}config.sub $ac_build_alias failed" "$LINENO" 5
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
-$as_echo "$ac_cv_build" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+printf "%s\n" "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
 *) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
@@ -4340,21 +4844,22 @@ IFS=$ac_save_IFS
 case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
-$as_echo_n "checking host system type... " >&6; }
-if ${ac_cv_host+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+printf %s "checking host system type... " >&6; }
+if test ${ac_cv_host+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test "x$host_alias" = x; then
   ac_cv_host=$ac_cv_build
 else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+  ac_cv_host=`$SHELL "${ac_aux_dir}config.sub" $host_alias` ||
+    as_fn_error $? "$SHELL ${ac_aux_dir}config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
-$as_echo "$ac_cv_host" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+printf "%s\n" "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
 *) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
@@ -4375,13 +4880,14 @@ case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+printf %s "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
 set x ${MAKE-make}
-ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+ac_make=`printf "%s\n" "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if eval test \${ac_cv_prog_make_${ac_make}_set+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat >conftest.make <<\_ACEOF
 SHELL = /bin/sh
 all:
@@ -4397,28 +4903,38 @@ esac
 rm -f conftest.make
 fi
 if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
   SET_MAKE=
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -4426,11 +4942,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -4441,11 +4961,11 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -4454,11 +4974,12 @@ if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
@@ -4466,11 +4987,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -4481,11 +5006,11 @@ fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_CC" = x; then
@@ -4493,8 +5018,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
@@ -4507,11 +5032,12 @@ if test -z "$CC"; then
           if test -n "$ac_tool_prefix"; then
     # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -4519,11 +5045,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -4534,11 +5064,11 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -4547,11 +5077,12 @@ fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -4560,15 +5091,19 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    if test "$as_dir$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
      fi
     ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -4584,18 +5119,18 @@ if test $ac_prog_rejected = yes; then
     # However, it has the same basename, so the bogon will be chosen
     # first if we set CC to just the basename; use the full file name.
     shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+    ac_cv_prog_CC="$as_dir$ac_word${1+' '}$@"
   fi
 fi
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -4606,11 +5141,12 @@ if test -z "$CC"; then
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -4618,11 +5154,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -4633,11 +5173,11 @@ fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -4650,11 +5190,12 @@ if test -z "$CC"; then
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
@@ -4662,11 +5203,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -4677,11 +5222,11 @@ fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -4693,34 +5238,138 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}clang", so it can be a program name with args.
+set dummy ${ac_tool_prefix}clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "clang", so it can be a program name with args.
+set dummy clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
   fi
+else
+  CC="$ac_cv_prog_CC"
 fi
 
 fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+test -z "$CC" && { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "no acceptable C compiler found in \$PATH
 See \`config.log' for more details" "$LINENO" 5; }
 
 # Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
+for ac_option in --version -v -V -qversion -version; do
   { { ac_try="$ac_compiler $ac_option >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
@@ -4730,7 +5379,7 @@ $as_echo "$ac_try_echo"; } >&5
     cat conftest.er1 >&5
   fi
   rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
 done
 
@@ -4738,7 +5387,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
@@ -4750,9 +5399,9 @@ ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
-$as_echo_n "checking whether the C compiler works... " >&6; }
-ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+printf %s "checking whether the C compiler works... " >&6; }
+ac_link_default=`printf "%s\n" "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
 
 # The possible output files:
 ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
@@ -4773,11 +5422,12 @@ case "(($ac_try" in
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link_default") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
   # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
 # So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
 # in a Makefile.  We should not override ac_cv_exeext if it was cached,
@@ -4794,7 +5444,7 @@ do
 	# certainly right.
 	break;;
     *.* )
-	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	if test ${ac_cv_exeext+y} && test "$ac_cv_exeext" != no;
 	then :; else
 	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
 	fi
@@ -4810,44 +5460,46 @@ do
 done
 test "$ac_cv_exeext" = no && ac_cv_exeext=
 
-else
+else $as_nop
   ac_file=''
 fi
-if test -z "$ac_file"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-$as_echo "$as_me: failed program was:" >&5
+if test -z "$ac_file"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "C compiler cannot create executables
 See \`config.log' for more details" "$LINENO" 5; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
-$as_echo_n "checking for C compiler default output file name... " >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
-$as_echo "$ac_file" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+printf %s "checking for C compiler default output file name... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+printf "%s\n" "$ac_file" >&6; }
 ac_exeext=$ac_cv_exeext
 
 rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
 ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
-$as_echo_n "checking for suffix of executables... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+printf %s "checking for suffix of executables... " >&6; }
 if { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
   # If both `conftest.exe' and `conftest' are `present' (well, observable)
 # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
 # work properly (i.e., refer to `conftest.exe'), while it won't with
@@ -4861,15 +5513,15 @@ for ac_file in conftest.exe conftest conftest.*; do
     * ) break;;
   esac
 done
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+else $as_nop
+  { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest conftest$ac_cv_exeext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
-$as_echo "$ac_cv_exeext" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+printf "%s\n" "$ac_cv_exeext" >&6; }
 
 rm -f conftest.$ac_ext
 EXEEXT=$ac_cv_exeext
@@ -4878,7 +5530,7 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdio.h>
 int
-main ()
+main (void)
 {
 FILE *f = fopen ("conftest.out", "w");
  return ferror (f) || fclose (f) != 0;
@@ -4890,8 +5542,8 @@ _ACEOF
 ac_clean_files="$ac_clean_files conftest.out"
 # Check that the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
-$as_echo_n "checking whether we are cross compiling... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+printf %s "checking whether we are cross compiling... " >&6; }
 if test "$cross_compiling" != yes; then
   { { ac_try="$ac_link"
 case "(($ac_try" in
@@ -4899,10 +5551,10 @@ case "(($ac_try" in
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
   if { ac_try='./conftest$ac_cv_exeext'
   { { case "(($ac_try" in
@@ -4910,39 +5562,40 @@ $as_echo "$ac_try_echo"; } >&5
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_try") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; }; then
     cross_compiling=no
   else
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot run C compiled programs.
+	{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details" "$LINENO" 5; }
     fi
   fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
-$as_echo "$cross_compiling" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+printf "%s\n" "$cross_compiling" >&6; }
 
 rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
 ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
-$as_echo_n "checking for suffix of object files... " >&6; }
-if ${ac_cv_objext+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+printf %s "checking for suffix of object files... " >&6; }
+if test ${ac_cv_objext+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
@@ -4956,11 +5609,12 @@ case "(($ac_try" in
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compile") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
   for ac_file in conftest.o conftest.obj conftest.*; do
   test -f "$ac_file" || continue;
   case $ac_file in
@@ -4969,31 +5623,32 @@ $as_echo "$ac_try_echo"; } >&5
        break;;
   esac
 done
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "cannot compute suffix of object files: cannot compile
 See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
-$as_echo "$ac_cv_objext" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+printf "%s\n" "$ac_cv_objext" >&6; }
 OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C" >&5
+printf %s "checking whether the compiler supports GNU C... " >&6; }
+if test ${ac_cv_c_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 #ifndef __GNUC__
        choke me
@@ -5003,29 +5658,33 @@ main ()
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_compiler_gnu=yes
-else
+else $as_nop
   ac_compiler_gnu=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_c_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
 if test $ac_compiler_gnu = yes; then
   GCC=yes
 else
   GCC=
 fi
-ac_test_CFLAGS=${CFLAGS+set}
+ac_test_CFLAGS=${CFLAGS+y}
 ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+printf %s "checking whether $CC accepts -g... " >&6; }
+if test ${ac_cv_prog_cc_g+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_save_c_werror_flag=$ac_c_werror_flag
    ac_c_werror_flag=yes
    ac_cv_prog_cc_g=no
@@ -5034,57 +5693,60 @@ else
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_g=yes
-else
+else $as_nop
   CFLAGS=""
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-else
+else $as_nop
   ac_c_werror_flag=$ac_save_c_werror_flag
 	 CFLAGS="-g"
 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_g=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
    ac_c_werror_flag=$ac_save_c_werror_flag
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+printf "%s\n" "$ac_cv_prog_cc_g" >&6; }
+if test $ac_test_CFLAGS; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
   if test "$GCC" = yes; then
@@ -5099,94 +5761,144 @@ else
     CFLAGS=
   fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if ${ac_cv_prog_cc_c89+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
+ac_prog_cc_stdc=no
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features" >&5
+printf %s "checking for $CC option to enable C11 features... " >&6; }
+if test ${ac_cv_prog_cc_c11+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c11=no
 ac_save_CC=$CC
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-struct stat;
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+$ac_c_conftest_c11_program
+_ACEOF
+for ac_arg in '' -std=gnu11
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c11=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c11" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+fi
 
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+if test "x$ac_cv_prog_cc_c11" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c11" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11" >&5
+printf "%s\n" "$ac_cv_prog_cc_c11" >&6; }
+     CC="$CC $ac_cv_prog_cc_c11"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11
+  ac_prog_cc_stdc=c11
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features" >&5
+printf %s "checking for $CC option to enable C99 features... " >&6; }
+if test ${ac_cv_prog_cc_c99+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c99=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c99_program
+_ACEOF
+for ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c99=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c99" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+fi
 
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
+if test "x$ac_cv_prog_cc_c99" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c99" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99" >&5
+printf "%s\n" "$ac_cv_prog_cc_c99" >&6; }
+     CC="$CC $ac_cv_prog_cc_c99"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99
+  ac_prog_cc_stdc=c99
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features" >&5
+printf %s "checking for $CC option to enable C89 features... " >&6; }
+if test ${ac_cv_prog_cc_c89+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c89_program
 _ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
 do
   CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
+  if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_c89=$ac_arg
 fi
-rm -f core conftest.err conftest.$ac_objext
+rm -f core conftest.err conftest.$ac_objext conftest.beam
   test "x$ac_cv_prog_cc_c89" != "xno" && break
 done
 rm -f conftest.$ac_ext
 CC=$ac_save_CC
-
 fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
 
+if test "x$ac_cv_prog_cc_c89" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c89" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+printf "%s\n" "$ac_cv_prog_cc_c89" >&6; }
+     CC="$CC $ac_cv_prog_cc_c89"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89
+  ac_prog_cc_stdc=c89
+fi
 fi
 
 ac_ext=c
@@ -5195,6 +5907,12 @@ ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
+
+
+
+
+
+
 ac_ext=cpp
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -5205,15 +5923,16 @@ if test -z "$CXX"; then
     CXX=$CCC
   else
     if test -n "$ac_tool_prefix"; then
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC clang++
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CXX+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CXX"; then
   ac_cv_prog_CXX="$CXX" # Let the user override the test.
 else
@@ -5221,11 +5940,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -5236,11 +5959,11 @@ fi
 fi
 CXX=$ac_cv_prog_CXX
 if test -n "$CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
-$as_echo "$CXX" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
+printf "%s\n" "$CXX" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -5249,15 +5972,16 @@ fi
 fi
 if test -z "$CXX"; then
   ac_ct_CXX=$CXX
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC clang++
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CXX+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CXX"; then
   ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
 else
@@ -5265,11 +5989,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CXX="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -5280,11 +6008,11 @@ fi
 fi
 ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
 if test -n "$ac_ct_CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
-$as_echo "$ac_ct_CXX" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
+printf "%s\n" "$ac_ct_CXX" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -5296,8 +6024,8 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CXX=$ac_ct_CXX
@@ -5307,7 +6035,7 @@ fi
   fi
 fi
 # Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
 for ac_option in --version -v -V -qversion; do
@@ -5317,7 +6045,7 @@ case "(($ac_try" in
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
@@ -5327,20 +6055,21 @@ $as_echo "$ac_try_echo"; } >&5
     cat conftest.er1 >&5
   fi
   rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
 done
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C++ compiler" >&5
-$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
-if ${ac_cv_cxx_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C++" >&5
+printf %s "checking whether the compiler supports GNU C++... " >&6; }
+if test ${ac_cv_cxx_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 #ifndef __GNUC__
        choke me
@@ -5350,29 +6079,33 @@ main ()
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"
+then :
   ac_compiler_gnu=yes
-else
+else $as_nop
   ac_compiler_gnu=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
-$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_cxx_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
 if test $ac_compiler_gnu = yes; then
   GXX=yes
 else
   GXX=
 fi
-ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_test_CXXFLAGS=${CXXFLAGS+y}
 ac_save_CXXFLAGS=$CXXFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
-$as_echo_n "checking whether $CXX accepts -g... " >&6; }
-if ${ac_cv_prog_cxx_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
+printf %s "checking whether $CXX accepts -g... " >&6; }
+if test ${ac_cv_prog_cxx_g+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_save_cxx_werror_flag=$ac_cxx_werror_flag
    ac_cxx_werror_flag=yes
    ac_cv_prog_cxx_g=no
@@ -5381,57 +6114,60 @@ else
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"
+then :
   ac_cv_prog_cxx_g=yes
-else
+else $as_nop
   CXXFLAGS=""
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"
+then :
 
-else
+else $as_nop
   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
 	 CXXFLAGS="-g"
 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
+if ac_fn_cxx_try_compile "$LINENO"
+then :
   ac_cv_prog_cxx_g=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
    ac_cxx_werror_flag=$ac_save_cxx_werror_flag
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
-$as_echo "$ac_cv_prog_cxx_g" >&6; }
-if test "$ac_test_CXXFLAGS" = set; then
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
+printf "%s\n" "$ac_cv_prog_cxx_g" >&6; }
+if test $ac_test_CXXFLAGS; then
   CXXFLAGS=$ac_save_CXXFLAGS
 elif test $ac_cv_prog_cxx_g = yes; then
   if test "$GXX" = yes; then
@@ -5446,6 +6182,100 @@ else
     CXXFLAGS=
   fi
 fi
+ac_prog_cxx_stdcxx=no
+if test x$ac_prog_cxx_stdcxx = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CXX option to enable C++11 features" >&5
+printf %s "checking for $CXX option to enable C++11 features... " >&6; }
+if test ${ac_cv_prog_cxx_11+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cxx_11=no
+ac_save_CXX=$CXX
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_cxx_conftest_cxx11_program
+_ACEOF
+for ac_arg in '' -std=gnu++11 -std=gnu++0x -std=c++11 -std=c++0x -qlanglvl=extended0x -AA
+do
+  CXX="$ac_save_CXX $ac_arg"
+  if ac_fn_cxx_try_compile "$LINENO"
+then :
+  ac_cv_prog_cxx_cxx11=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cxx_cxx11" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CXX=$ac_save_CXX
+fi
+
+if test "x$ac_cv_prog_cxx_cxx11" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cxx_cxx11" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_cxx11" >&5
+printf "%s\n" "$ac_cv_prog_cxx_cxx11" >&6; }
+     CXX="$CXX $ac_cv_prog_cxx_cxx11"
+fi
+  ac_cv_prog_cxx_stdcxx=$ac_cv_prog_cxx_cxx11
+  ac_prog_cxx_stdcxx=cxx11
+fi
+fi
+if test x$ac_prog_cxx_stdcxx = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CXX option to enable C++98 features" >&5
+printf %s "checking for $CXX option to enable C++98 features... " >&6; }
+if test ${ac_cv_prog_cxx_98+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cxx_98=no
+ac_save_CXX=$CXX
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_cxx_conftest_cxx98_program
+_ACEOF
+for ac_arg in '' -std=gnu++98 -std=c++98 -qlanglvl=extended -AA
+do
+  CXX="$ac_save_CXX $ac_arg"
+  if ac_fn_cxx_try_compile "$LINENO"
+then :
+  ac_cv_prog_cxx_cxx98=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cxx_cxx98" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CXX=$ac_save_CXX
+fi
+
+if test "x$ac_cv_prog_cxx_cxx98" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cxx_cxx98" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_cxx98" >&5
+printf "%s\n" "$ac_cv_prog_cxx_cxx98" >&6; }
+     CXX="$CXX $ac_cv_prog_cxx_cxx98"
+fi
+  ac_cv_prog_cxx_stdcxx=$ac_cv_prog_cxx_cxx98
+  ac_prog_cxx_stdcxx=cxx98
+fi
+fi
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -5455,11 +6285,12 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}cpp", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cpp; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CPPBIN+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CPPBIN+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CPPBIN"; then
   ac_cv_prog_CPPBIN="$CPPBIN" # Let the user override the test.
 else
@@ -5467,11 +6298,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CPPBIN="${ac_tool_prefix}cpp"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -5482,11 +6317,11 @@ fi
 fi
 CPPBIN=$ac_cv_prog_CPPBIN
 if test -n "$CPPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPPBIN" >&5
-$as_echo "$CPPBIN" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CPPBIN" >&5
+printf "%s\n" "$CPPBIN" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -5495,11 +6330,12 @@ if test -z "$ac_cv_prog_CPPBIN"; then
   ac_ct_CPPBIN=$CPPBIN
   # Extract the first word of "cpp", so it can be a program name with args.
 set dummy cpp; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CPPBIN+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CPPBIN+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CPPBIN"; then
   ac_cv_prog_ac_ct_CPPBIN="$ac_ct_CPPBIN" # Let the user override the test.
 else
@@ -5507,11 +6343,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CPPBIN="cpp"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -5522,11 +6362,11 @@ fi
 fi
 ac_ct_CPPBIN=$ac_cv_prog_ac_ct_CPPBIN
 if test -n "$ac_ct_CPPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CPPBIN" >&5
-$as_echo "$ac_ct_CPPBIN" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CPPBIN" >&5
+printf "%s\n" "$ac_ct_CPPBIN" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_CPPBIN" = x; then
@@ -5534,8 +6374,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CPPBIN=$ac_ct_CPPBIN
@@ -5545,18 +6385,17 @@ else
 fi
 
 
-cat >>confdefs.h <<_ACEOF
-#define EXEEXT "$ac_exeext"
-_ACEOF
+printf "%s\n" "#define EXEEXT \"$ac_exeext\"" >>confdefs.h
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ld", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ld; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_LD+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_LD+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$LD"; then
   ac_cv_prog_LD="$LD" # Let the user override the test.
 else
@@ -5564,11 +6403,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_LD="${ac_tool_prefix}ld"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -5579,11 +6422,11 @@ fi
 fi
 LD=$ac_cv_prog_LD
 if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+printf "%s\n" "$LD" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -5592,11 +6435,12 @@ if test -z "$ac_cv_prog_LD"; then
   ac_ct_LD=$LD
   # Extract the first word of "ld", so it can be a program name with args.
 set dummy ld; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_LD+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_LD+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_LD"; then
   ac_cv_prog_ac_ct_LD="$ac_ct_LD" # Let the user override the test.
 else
@@ -5604,11 +6448,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_LD="ld"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -5619,11 +6467,11 @@ fi
 fi
 ac_ct_LD=$ac_cv_prog_ac_ct_LD
 if test -n "$ac_ct_LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LD" >&5
-$as_echo "$ac_ct_LD" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LD" >&5
+printf "%s\n" "$ac_ct_LD" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_LD" = x; then
@@ -5631,8 +6479,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     LD=$ac_ct_LD
@@ -5660,32 +6508,34 @@ case $host in
       CC="$CC -m32"
       CXX="$CXX -m32"
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC works" >&5
-$as_echo_n "checking whether $CC works... " >&6; }
-if ${wine_cv_cc_m32+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC works" >&5
+printf %s "checking whether $CC works... " >&6; }
+if test ${wine_cv_cc_m32+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_cc_m32=yes
-else
+else $as_nop
   wine_cv_cc_m32=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_cc_m32" >&5
-$as_echo "$wine_cv_cc_m32" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_cc_m32" >&5
+printf "%s\n" "$wine_cv_cc_m32" >&6; }
       test $wine_cv_cc_m32 != no || as_fn_error $? "Cannot build a 32-bit program, you need to install 32-bit development libraries." "$LINENO" 5
       host_cpu="i386"
       notice_platform="32-bit "
@@ -5697,31 +6547,33 @@ $as_echo "$wine_cv_cc_m32" >&6; }
     else
       if test "x${GCC}" = "xyes"
       then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC supports __builtin_ms_va_list" >&5
-$as_echo_n "checking whether $CC supports __builtin_ms_va_list... " >&6; }
-if ${wine_cv_builtin_ms_va_list+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports __builtin_ms_va_list" >&5
+printf %s "checking whether $CC supports __builtin_ms_va_list... " >&6; }
+if test ${wine_cv_builtin_ms_va_list+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdarg.h>
 int
-main ()
+main (void)
 {
 void func(__builtin_ms_va_list *args);
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   wine_cv_builtin_ms_va_list=yes
-else
+else $as_nop
   wine_cv_builtin_ms_va_list=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_builtin_ms_va_list" >&5
-$as_echo "$wine_cv_builtin_ms_va_list" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_builtin_ms_va_list" >&5
+printf "%s\n" "$wine_cv_builtin_ms_va_list" >&6; }
         test $wine_cv_builtin_ms_va_list != no || as_fn_error $? "You need gcc >= 4.4 or clang >= 3.8 to build Wine as 64-bit." "$LINENO" 5
       fi
       CC="$CC -m64"
@@ -5735,32 +6587,34 @@ $as_echo "$wine_cv_builtin_ms_va_list" >&6; }
     fi
     ;;
   arm*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC supports Thumb-2" >&5
-$as_echo_n "checking whether $CC supports Thumb-2... " >&6; }
-if ${wine_cv_thumb2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports Thumb-2" >&5
+printf %s "checking whether $CC supports Thumb-2... " >&6; }
+if test ${wine_cv_thumb2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 asm(".syntax unified\n\t.thumb\n\tldm r0,{r0-r8}");
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_thumb2=yes
-else
+else $as_nop
   wine_cv_thumb2=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_thumb2" >&5
-$as_echo "$wine_cv_thumb2" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_thumb2" >&5
+printf "%s\n" "$wine_cv_thumb2" >&6; }
     if test x"$wine_cv_thumb2" = xyes
     then
         CFLAGS="$CFLAGS -mthumb"
@@ -5780,32 +6634,34 @@ $as_echo "$wine_cv_thumb2" >&6; }
             float_abi=softfp
             saved_CFLAGS=$CFLAGS
             CFLAGS="$CFLAGS -mfloat-abi=$float_abi"
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -mfloat-abi=$float_abi" >&5
-$as_echo_n "checking whether $CC supports -mfloat-abi=$float_abi... " >&6; }
-if ${wine_cv_float_abi+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -mfloat-abi=$float_abi" >&5
+printf %s "checking whether $CC supports -mfloat-abi=$float_abi... " >&6; }
+if test ${wine_cv_float_abi+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 asm("vmrs r2,fpscr");
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_float_abi=yes
-else
+else $as_nop
   wine_cv_float_abi=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_float_abi" >&5
-$as_echo "$wine_cv_float_abi" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_float_abi" >&5
+printf "%s\n" "$wine_cv_float_abi" >&6; }
             if test $wine_cv_float_abi = no
             then
                 float_abi=soft
@@ -5819,31 +6675,33 @@ $as_echo "$wine_cv_float_abi" >&6; }
     TARGETFLAGS="$TARGETFLAGS -mfloat-abi=$float_abi"
     ;;
   aarch64*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC supports __builtin_ms_va_list" >&5
-$as_echo_n "checking whether $CC supports __builtin_ms_va_list... " >&6; }
-if ${wine_cv_builtin_ms_va_list+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports __builtin_ms_va_list" >&5
+printf %s "checking whether $CC supports __builtin_ms_va_list... " >&6; }
+if test ${wine_cv_builtin_ms_va_list+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdarg.h>
 int
-main ()
+main (void)
 {
 void func(__builtin_ms_va_list *args);
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   wine_cv_builtin_ms_va_list=yes
-else
+else $as_nop
   wine_cv_builtin_ms_va_list=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_builtin_ms_va_list" >&5
-$as_echo "$wine_cv_builtin_ms_va_list" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_builtin_ms_va_list" >&5
+printf "%s\n" "$wine_cv_builtin_ms_va_list" >&6; }
     test $wine_cv_builtin_ms_va_list != no || as_fn_error $? "You need clang >= 5.0 to build Wine for arm64." "$LINENO" 5
     enable_wow64=${enable_wow64:-yes}
     enable_wow64win=${enable_wow64win:-yes}
@@ -5868,11 +6726,12 @@ then
 --enable-win64 should be used in the 64-bit build tree, --with-wine64 in the 32-bit Wow64 build tree." "$LINENO" 5
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for the directory containing the Wine tools" >&5
-$as_echo_n "checking for the directory containing the Wine tools... " >&6; }
-if ${wine_cv_toolsdir+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for the directory containing the Wine tools" >&5
+printf %s "checking for the directory containing the Wine tools... " >&6; }
+if test ${wine_cv_toolsdir+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   wine_cv_toolsdir="$with_wine_tools"
    if test -z "$with_wine_tools"; then
      if test "$cross_compiling" = "yes"; then
@@ -5882,8 +6741,8 @@ else
      fi
    fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_toolsdir" >&5
-$as_echo "$wine_cv_toolsdir" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_toolsdir" >&5
+printf "%s\n" "$wine_cv_toolsdir" >&6; }
 if test -z "$wine_cv_toolsdir"; then
     wine_makedep=tools/makedep
     TOOLSDIR="."
@@ -5906,11 +6765,12 @@ for ac_prog in flex
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_FLEX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_FLEX+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$FLEX"; then
   ac_cv_prog_FLEX="$FLEX" # Let the user override the test.
 else
@@ -5918,11 +6778,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_FLEX="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -5933,11 +6797,11 @@ fi
 fi
 FLEX=$ac_cv_prog_FLEX
 if test -n "$FLEX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $FLEX" >&5
-$as_echo "$FLEX" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $FLEX" >&5
+printf "%s\n" "$FLEX" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -5949,11 +6813,12 @@ if test "$FLEX" = "none"
 then
   as_fn_error $? "no suitable flex found. Please install the 'flex' package." "$LINENO" 5
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether flex is recent enough" >&5
-$as_echo_n "checking whether flex is recent enough... " >&6; }
-if ${wine_cv_recent_flex+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether flex is recent enough" >&5
+printf %s "checking whether flex is recent enough... " >&6; }
+if test ${wine_cv_recent_flex+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat >conftest.l <<EOF
 %top{
 #include "prediluvian.h"
@@ -5967,19 +6832,20 @@ EOF
       wine_cv_recent_flex=no
     fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_recent_flex" >&5
-$as_echo "$wine_cv_recent_flex" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_recent_flex" >&5
+printf "%s\n" "$wine_cv_recent_flex" >&6; }
 test $wine_cv_recent_flex != no || as_fn_error $? "Your flex version is too old. Please install flex version 2.5.33 or newer." "$LINENO" 5
 
 for ac_prog in bison
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_BISON+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_BISON+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$BISON"; then
   ac_cv_prog_BISON="$BISON" # Let the user override the test.
 else
@@ -5987,11 +6853,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_BISON="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6002,11 +6872,11 @@ fi
 fi
 BISON=$ac_cv_prog_BISON
 if test -n "$BISON"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $BISON" >&5
-$as_echo "$BISON" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $BISON" >&5
+printf "%s\n" "$BISON" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6018,11 +6888,12 @@ if test "$BISON" = "none"
 then
   as_fn_error $? "no suitable bison found. Please install the 'bison' package." "$LINENO" 5
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether bison is recent enough" >&5
-$as_echo_n "checking whether bison is recent enough... " >&6; }
-if ${wine_cv_recent_bison+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether bison is recent enough" >&5
+printf %s "checking whether bison is recent enough... " >&6; }
+if test ${wine_cv_recent_bison+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat >conftest.y <<EOF
 %define parse.error verbose
 %%
@@ -6035,8 +6906,8 @@ EOF
       wine_cv_recent_bison=no
     fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_recent_bison" >&5
-$as_echo "$wine_cv_recent_bison" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_recent_bison" >&5
+printf "%s\n" "$wine_cv_recent_bison" >&6; }
 test $wine_cv_recent_bison != no || as_fn_error $? "Your bison version is too old. Please install bison version 3.0 or newer." "$LINENO" 5
 
 if test -n "$ac_tool_prefix"; then
@@ -6044,11 +6915,12 @@ if test -n "$ac_tool_prefix"; then
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AR+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_AR+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$AR"; then
   ac_cv_prog_AR="$AR" # Let the user override the test.
 else
@@ -6056,11 +6928,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_AR="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6071,11 +6947,11 @@ fi
 fi
 AR=$ac_cv_prog_AR
 if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+printf "%s\n" "$AR" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6088,11 +6964,12 @@ if test -z "$AR"; then
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_AR+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_AR+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_AR"; then
   ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
 else
@@ -6100,11 +6977,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_AR="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6115,11 +6996,11 @@ fi
 fi
 ac_ct_AR=$ac_cv_prog_ac_ct_AR
 if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
-$as_echo "$ac_ct_AR" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+printf "%s\n" "$ac_ct_AR" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6131,8 +7012,8 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     AR=$ac_ct_AR
@@ -6142,11 +7023,12 @@ fi
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_STRIP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_STRIP+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$STRIP"; then
   ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
 else
@@ -6154,11 +7036,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6169,11 +7055,11 @@ fi
 fi
 STRIP=$ac_cv_prog_STRIP
 if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+printf "%s\n" "$STRIP" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6182,11 +7068,12 @@ if test -z "$ac_cv_prog_STRIP"; then
   ac_ct_STRIP=$STRIP
   # Extract the first word of "strip", so it can be a program name with args.
 set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_STRIP+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_STRIP"; then
   ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
 else
@@ -6194,11 +7081,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6209,11 +7100,11 @@ fi
 fi
 ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
 if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+printf "%s\n" "$ac_ct_STRIP" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_STRIP" = x; then
@@ -6221,8 +7112,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     STRIP=$ac_ct_STRIP
@@ -6234,11 +7125,12 @@ fi
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_RANLIB+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$RANLIB"; then
   ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
 else
@@ -6246,11 +7138,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6261,11 +7157,11 @@ fi
 fi
 RANLIB=$ac_cv_prog_RANLIB
 if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+printf "%s\n" "$RANLIB" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6274,11 +7170,12 @@ if test -z "$ac_cv_prog_RANLIB"; then
   ac_ct_RANLIB=$RANLIB
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_RANLIB+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_RANLIB"; then
   ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
 else
@@ -6286,11 +7183,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6301,11 +7202,11 @@ fi
 fi
 ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
 if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+printf "%s\n" "$ac_ct_RANLIB" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_RANLIB" = x; then
@@ -6313,8 +7214,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     RANLIB=$ac_ct_RANLIB
@@ -6323,22 +7224,23 @@ else
   RANLIB="$ac_cv_prog_RANLIB"
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
-$as_echo_n "checking whether ln -s works... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
+printf %s "checking whether ln -s works... " >&6; }
 LN_S=$as_ln_s
 if test "$LN_S" = "ln -s"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
-$as_echo "no, using $LN_S" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
+printf "%s\n" "no, using $LN_S" >&6; }
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if ${ac_cv_path_GREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+printf %s "checking for grep that handles long lines and -e... " >&6; }
+if test ${ac_cv_path_GREP+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -z "$GREP"; then
   ac_path_GREP_found=false
   # Loop through the user's path and test for each of PROGNAME-LIST
@@ -6346,10 +7248,15 @@ else
 for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_prog in grep ggrep
+   do
     for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      ac_path_GREP="$as_dir$ac_prog$ac_exec_ext"
       as_fn_executable_p "$ac_path_GREP" || continue
 # Check for GNU ac_path_GREP and select it if it is found.
   # Check for GNU $ac_path_GREP
@@ -6358,13 +7265,13 @@ case `"$ac_path_GREP" --version 2>&1` in
   ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
 *)
   ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
+  printf %s 0123456789 >"conftest.in"
   while :
   do
     cat "conftest.in" "conftest.in" >"conftest.tmp"
     mv "conftest.tmp" "conftest.in"
     cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
+    printf "%s\n" 'GREP' >> "conftest.nl"
     "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
     as_fn_arith $ac_count + 1 && ac_count=$as_val
@@ -6392,16 +7299,17 @@ else
 fi
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+printf "%s\n" "$ac_cv_path_GREP" >&6; }
  GREP="$ac_cv_path_GREP"
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if ${ac_cv_path_EGREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+printf %s "checking for egrep... " >&6; }
+if test ${ac_cv_path_EGREP+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
    then ac_cv_path_EGREP="$GREP -E"
    else
@@ -6412,10 +7320,15 @@ else
 for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_prog in egrep
+   do
     for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      ac_path_EGREP="$as_dir$ac_prog$ac_exec_ext"
       as_fn_executable_p "$ac_path_EGREP" || continue
 # Check for GNU ac_path_EGREP and select it if it is found.
   # Check for GNU $ac_path_EGREP
@@ -6424,13 +7337,13 @@ case `"$ac_path_EGREP" --version 2>&1` in
   ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
 *)
   ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
+  printf %s 0123456789 >"conftest.in"
   while :
   do
     cat "conftest.in" "conftest.in" >"conftest.tmp"
     mv "conftest.tmp" "conftest.in"
     cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
+    printf "%s\n" 'EGREP' >> "conftest.nl"
     "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
     as_fn_arith $ac_count + 1 && ac_count=$as_val
@@ -6459,18 +7372,19 @@ fi
 
    fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+printf "%s\n" "$ac_cv_path_EGREP" >&6; }
  EGREP="$ac_cv_path_EGREP"
 
 
 # Extract the first word of "ldconfig", so it can be a program name with args.
 set dummy ldconfig; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_LDCONFIG+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_LDCONFIG+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   case $LDCONFIG in
   [\\/]* | ?:[\\/]*)
   ac_cv_path_LDCONFIG="$LDCONFIG" # Let the user override the test with a path.
@@ -6480,11 +7394,15 @@ else
 for as_dir in /sbin /usr/sbin $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_LDCONFIG="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_LDCONFIG="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6497,11 +7415,11 @@ esac
 fi
 LDCONFIG=$ac_cv_path_LDCONFIG
 if test -n "$LDCONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LDCONFIG" >&5
-$as_echo "$LDCONFIG" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $LDCONFIG" >&5
+printf "%s\n" "$LDCONFIG" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6509,11 +7427,12 @@ for ac_prog in msgfmt
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_MSGFMT+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_MSGFMT+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$MSGFMT"; then
   ac_cv_prog_MSGFMT="$MSGFMT" # Let the user override the test.
 else
@@ -6521,11 +7440,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_MSGFMT="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6536,11 +7459,11 @@ fi
 fi
 MSGFMT=$ac_cv_prog_MSGFMT
 if test -n "$MSGFMT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MSGFMT" >&5
-$as_echo "$MSGFMT" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $MSGFMT" >&5
+printf "%s\n" "$MSGFMT" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6548,14 +7471,16 @@ fi
 done
 test -n "$MSGFMT" || MSGFMT="false"
 
-if ${ac_tool_prefix+:} false; then :
+if test ${ac_tool_prefix+y}
+then :
   # Extract the first word of "${ac_tool_prefix}pkg-config", so it can be a program name with args.
 set dummy ${ac_tool_prefix}pkg-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_PKG_CONFIG+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_PKG_CONFIG+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$PKG_CONFIG"; then
   ac_cv_prog_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test.
 else
@@ -6563,11 +7488,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_PKG_CONFIG="${ac_tool_prefix}pkg-config"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6578,27 +7507,30 @@ fi
 fi
 PKG_CONFIG=$ac_cv_prog_PKG_CONFIG
 if test -n "$PKG_CONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
-$as_echo "$PKG_CONFIG" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+printf "%s\n" "$PKG_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 fi
-if ${ac_cv_prog_PKG_CONFIG:+false} :; then :
-  if test "x$cross_compiling" = xyes; then :
+if ${ac_cv_prog_PKG_CONFIG:+false} :
+then :
+  if test "x$cross_compiling" = xyes
+then :
 
-else
+else $as_nop
   { ac_cv_prog_PKG_CONFIG=; unset ac_cv_prog_PKG_CONFIG;}
      # Extract the first word of "pkg-config", so it can be a program name with args.
 set dummy pkg-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_PKG_CONFIG+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_PKG_CONFIG+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$PKG_CONFIG"; then
   ac_cv_prog_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test.
 else
@@ -6606,11 +7538,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_PKG_CONFIG="pkg-config"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6621,16 +7557,16 @@ fi
 fi
 PKG_CONFIG=$ac_cv_prog_PKG_CONFIG
 if test -n "$PKG_CONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
-$as_echo "$PKG_CONFIG" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+printf "%s\n" "$PKG_CONFIG" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 fi
-else
+else $as_nop
   PKG_CONFIG=$ac_cv_prog_PKG_CONFIG
 fi
 
@@ -6646,11 +7582,12 @@ else
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_FONTFORGE+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_FONTFORGE+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$FONTFORGE"; then
   ac_cv_prog_FONTFORGE="$FONTFORGE" # Let the user override the test.
 else
@@ -6658,11 +7595,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_FONTFORGE="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6673,11 +7614,11 @@ fi
 fi
 FONTFORGE=$ac_cv_prog_FONTFORGE
 if test -n "$FONTFORGE"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $FONTFORGE" >&5
-$as_echo "$FONTFORGE" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $FONTFORGE" >&5
+printf "%s\n" "$FONTFORGE" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6689,11 +7630,12 @@ test -n "$FONTFORGE" || FONTFORGE="false"
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RSVG+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_RSVG+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$RSVG"; then
   ac_cv_prog_RSVG="$RSVG" # Let the user override the test.
 else
@@ -6701,11 +7643,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_RSVG="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6716,11 +7662,11 @@ fi
 fi
 RSVG=$ac_cv_prog_RSVG
 if test -n "$RSVG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RSVG" >&5
-$as_echo "$RSVG" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $RSVG" >&5
+printf "%s\n" "$RSVG" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6732,11 +7678,12 @@ test -n "$RSVG" || RSVG="false"
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CONVERT+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CONVERT+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CONVERT"; then
   ac_cv_prog_CONVERT="$CONVERT" # Let the user override the test.
 else
@@ -6744,11 +7691,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CONVERT="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6759,11 +7710,11 @@ fi
 fi
 CONVERT=$ac_cv_prog_CONVERT
 if test -n "$CONVERT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CONVERT" >&5
-$as_echo "$CONVERT" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CONVERT" >&5
+printf "%s\n" "$CONVERT" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6775,11 +7726,12 @@ test -n "$CONVERT" || CONVERT="false"
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ICOTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ICOTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ICOTOOL"; then
   ac_cv_prog_ICOTOOL="$ICOTOOL" # Let the user override the test.
 else
@@ -6787,11 +7739,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ICOTOOL="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -6802,11 +7758,11 @@ fi
 fi
 ICOTOOL=$ac_cv_prog_ICOTOOL
 if test -n "$ICOTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ICOTOOL" >&5
-$as_echo "$ICOTOOL" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ICOTOOL" >&5
+printf "%s\n" "$ICOTOOL" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -6821,8 +7777,8 @@ test -n "$ICOTOOL" || ICOTOOL="false"
   then
     as_fn_error $? "You need imagemagick to rebuild icons in maintainer mode." "$LINENO" 5
   else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for recent enough imagemagick" >&5
-$as_echo_n "checking for recent enough imagemagick... " >&6; }
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for recent enough imagemagick" >&5
+printf %s "checking for recent enough imagemagick... " >&6; }
     convert_version=`convert --version | head -n1`
     if test "x$convert_version" != "x"
     then
@@ -6835,12 +7791,12 @@ $as_echo_n "checking for recent enough imagemagick... " >&6; }
     fi
     if test "$CONVERT" = false
     then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no ($convert_version_major.$convert_version_minor)" >&5
-$as_echo "no ($convert_version_major.$convert_version_minor)" >&6; }
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no ($convert_version_major.$convert_version_minor)" >&5
+printf "%s\n" "no ($convert_version_major.$convert_version_minor)" >&6; }
       as_fn_error $? "You need imagemagick version 6.6 or newer to rebuild icons in maintainer mode." "$LINENO" 5
     else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes ($convert_version_major.$convert_version_minor)" >&5
-$as_echo "yes ($convert_version_major.$convert_version_minor)" >&6; }
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes ($convert_version_major.$convert_version_minor)" >&5
+printf "%s\n" "yes ($convert_version_major.$convert_version_minor)" >&6; }
     fi
   fi
 
@@ -6848,8 +7804,8 @@ $as_echo "yes ($convert_version_major.$convert_version_minor)" >&6; }
   then
     as_fn_error $? "You need icotool to rebuild icons in maintainer mode." "$LINENO" 5
   else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for recent enough icotool" >&5
-$as_echo_n "checking for recent enough icotool... " >&6; }
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for recent enough icotool" >&5
+printf %s "checking for recent enough icotool... " >&6; }
     icotool_version=`icotool --version | head -n1`
     if test "x$icotool_version" != "x"
     then
@@ -6863,12 +7819,12 @@ $as_echo_n "checking for recent enough icotool... " >&6; }
     fi
     if test "$ICOTOOL" = false
     then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no ($icotool_version_major.$icotool_version_minor)" >&5
-$as_echo "no ($icotool_version_major.$icotool_version_minor)" >&6; }
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no ($icotool_version_major.$icotool_version_minor)" >&5
+printf "%s\n" "no ($icotool_version_major.$icotool_version_minor)" >&6; }
       as_fn_error $? "You need icotool version 0.29.0 or newer to rebuild icons in maintainer mode." "$LINENO" 5
     else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes ($icotool_version_major.$icotool_version_minor)" >&5
-$as_echo "yes ($icotool_version_major.$icotool_version_minor)" >&6; }
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes ($icotool_version_major.$icotool_version_minor)" >&5
+printf "%s\n" "yes ($icotool_version_major.$icotool_version_minor)" >&6; }
     fi
   fi
 
@@ -6881,11 +7837,12 @@ fi
 test "x$with_gettext" != xno || MSGFMT=false
 if test "$MSGFMT" != "false"
 then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether msgfmt supports contexts" >&5
-$as_echo_n "checking whether msgfmt supports contexts... " >&6; }
-if ${wine_cv_msgfmt_contexts+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether msgfmt supports contexts" >&5
+printf %s "checking whether msgfmt supports contexts... " >&6; }
+if test ${wine_cv_msgfmt_contexts+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat >conftest.po <<EOF
 # comment
 msgctxt "ctxt"
@@ -6899,11 +7856,12 @@ EOF
     wine_cv_msgfmt_contexts=no
   fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_msgfmt_contexts" >&5
-$as_echo "$wine_cv_msgfmt_contexts" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_msgfmt_contexts" >&5
+printf "%s\n" "$wine_cv_msgfmt_contexts" >&6; }
   test $wine_cv_msgfmt_contexts != no || MSGFMT=false
 fi
-if test "$MSGFMT" = false; then :
+if test "$MSGFMT" = false
+then :
   case "x$with_gettext" in
   x)   as_fn_append wine_warnings "|gettext tools not found (or too old), translations won't be built." ;;
   xno) ;;
@@ -6914,11 +7872,12 @@ enable_po=${enable_po:-no}
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for i386_set_ldt in -li386" >&5
-$as_echo_n "checking for i386_set_ldt in -li386... " >&6; }
-if ${ac_cv_lib_i386_i386_set_ldt+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for i386_set_ldt in -li386" >&5
+printf %s "checking for i386_set_ldt in -li386... " >&6; }
+if test ${ac_cv_lib_i386_i386_set_ldt+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-li386  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -6927,30 +7886,29 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char i386_set_ldt ();
 int
-main ()
+main (void)
 {
 return i386_set_ldt ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_i386_i386_set_ldt=yes
-else
+else $as_nop
   ac_cv_lib_i386_i386_set_ldt=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_i386_i386_set_ldt" >&5
-$as_echo "$ac_cv_lib_i386_i386_set_ldt" >&6; }
-if test "x$ac_cv_lib_i386_i386_set_ldt" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_i386_i386_set_ldt" >&5
+printf "%s\n" "$ac_cv_lib_i386_i386_set_ldt" >&6; }
+if test "x$ac_cv_lib_i386_i386_set_ldt" = xyes
+then :
   I386_LIBS="-li386"
 
 fi
@@ -6961,17 +7919,19 @@ OPENGL_LIBS=""
 
 
 # Check whether --enable-largefile was given.
-if test "${enable_largefile+set}" = set; then :
+if test ${enable_largefile+y}
+then :
   enableval=$enable_largefile;
 fi
 
 if test "$enable_largefile" != no; then
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
-$as_echo_n "checking for special C compiler options needed for large files... " >&6; }
-if ${ac_cv_sys_largefile_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
+printf %s "checking for special C compiler options needed for large files... " >&6; }
+if test ${ac_cv_sys_largefile_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_cv_sys_largefile_CC=no
      if test "$GCC" != yes; then
        ac_save_CC=$CC
@@ -6985,44 +7945,47 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-	 if ac_fn_c_try_compile "$LINENO"; then :
+	 if ac_fn_c_try_compile "$LINENO"
+then :
   break
 fi
-rm -f core conftest.err conftest.$ac_objext
+rm -f core conftest.err conftest.$ac_objext conftest.beam
 	 CC="$CC -n32"
-	 if ac_fn_c_try_compile "$LINENO"; then :
+	 if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_sys_largefile_CC=' -n32'; break
 fi
-rm -f core conftest.err conftest.$ac_objext
+rm -f core conftest.err conftest.$ac_objext conftest.beam
 	 break
        done
        CC=$ac_save_CC
        rm -f conftest.$ac_ext
     fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC" >&5
-$as_echo "$ac_cv_sys_largefile_CC" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC" >&5
+printf "%s\n" "$ac_cv_sys_largefile_CC" >&6; }
   if test "$ac_cv_sys_largefile_CC" != no; then
     CC=$CC$ac_cv_sys_largefile_CC
   fi
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
-$as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
-if ${ac_cv_sys_file_offset_bits+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+printf %s "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
+if test ${ac_cv_sys_file_offset_bits+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   while :; do
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -7031,22 +7994,23 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_sys_file_offset_bits=no; break
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #define _FILE_OFFSET_BITS 64
@@ -7055,43 +8019,43 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_sys_file_offset_bits=64; break
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   ac_cv_sys_file_offset_bits=unknown
   break
 done
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits" >&5
-$as_echo "$ac_cv_sys_file_offset_bits" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits" >&5
+printf "%s\n" "$ac_cv_sys_file_offset_bits" >&6; }
 case $ac_cv_sys_file_offset_bits in #(
   no | unknown) ;;
   *)
-cat >>confdefs.h <<_ACEOF
-#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
-_ACEOF
+printf "%s\n" "#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits" >>confdefs.h
 ;;
 esac
 rm -rf conftest*
   if test $ac_cv_sys_file_offset_bits = unknown; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
-$as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
-if ${ac_cv_sys_large_files+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
+printf %s "checking for _LARGE_FILES value needed for large files... " >&6; }
+if test ${ac_cv_sys_large_files+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   while :; do
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -7100,22 +8064,23 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_sys_large_files=no; break
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #define _LARGE_FILES 1
@@ -7124,555 +8089,1317 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 31 << 31) - 1 + ((off_t) 1 << 31 << 31))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_sys_large_files=1; break
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   ac_cv_sys_large_files=unknown
   break
 done
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files" >&5
-$as_echo "$ac_cv_sys_large_files" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files" >&5
+printf "%s\n" "$ac_cv_sys_large_files" >&6; }
 case $ac_cv_sys_large_files in #(
   no | unknown) ;;
   *)
-cat >>confdefs.h <<_ACEOF
-#define _LARGE_FILES $ac_cv_sys_large_files
-_ACEOF
+printf "%s\n" "#define _LARGE_FILES $ac_cv_sys_large_files" >>confdefs.h
 ;;
 esac
 rm -rf conftest*
   fi
+fi
+
+
+ac_header= ac_cache=
+for ac_item in $ac_header_c_list
+do
+  if test $ac_cache; then
+    ac_fn_c_check_header_compile "$LINENO" $ac_header ac_cv_header_$ac_cache "$ac_includes_default"
+    if eval test \"x\$ac_cv_header_$ac_cache\" = xyes; then
+      printf "%s\n" "#define $ac_item 1" >> confdefs.h
+    fi
+    ac_header= ac_cache=
+  elif test $ac_header; then
+    ac_cache=$ac_item
+  else
+    ac_header=$ac_item
+  fi
+done
+
 
 
+
+
+
+
+
+if test $ac_cv_header_stdlib_h = yes && test $ac_cv_header_string_h = yes
+then :
+
+printf "%s\n" "#define STDC_HEADERS 1" >>confdefs.h
+
 fi
+ac_fn_c_check_header_compile "$LINENO" "AL/al.h" "ac_cv_header_AL_al_h" "$ac_includes_default"
+if test "x$ac_cv_header_AL_al_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_AL_AL_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "ApplicationServices/ApplicationServices.h" "ac_cv_header_ApplicationServices_ApplicationServices_h" "$ac_includes_default"
+if test "x$ac_cv_header_ApplicationServices_ApplicationServices_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_APPLICATIONSERVICES_APPLICATIONSERVICES_H 1" >>confdefs.h
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
 fi
-if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+ac_fn_c_check_header_compile "$LINENO" "CL/cl.h" "ac_cv_header_CL_cl_h" "$ac_includes_default"
+if test "x$ac_cv_header_CL_cl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CL_CL_H 1" >>confdefs.h
 
-else
-  # Broken: fails on valid input.
-continue
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
+ac_fn_c_check_header_compile "$LINENO" "Carbon/Carbon.h" "ac_cv_header_Carbon_Carbon_h" "$ac_includes_default"
+if test "x$ac_cv_header_Carbon_Carbon_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CARBON_CARBON_H 1" >>confdefs.h
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
+ac_fn_c_check_header_compile "$LINENO" "CoreAudio/CoreAudio.h" "ac_cv_header_CoreAudio_CoreAudio_h" "$ac_includes_default"
+if test "x$ac_cv_header_CoreAudio_CoreAudio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_COREAUDIO_COREAUDIO_H 1" >>confdefs.h
 
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
 fi
+ac_fn_c_check_header_compile "$LINENO" "DiskArbitration/DiskArbitration.h" "ac_cv_header_DiskArbitration_DiskArbitration_h" "$ac_includes_default"
+if test "x$ac_cv_header_DiskArbitration_DiskArbitration_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_DISKARBITRATION_DISKARBITRATION_H 1" >>confdefs.h
 
-    done
-    ac_cv_prog_CPP=$CPP
+fi
+ac_fn_c_check_header_compile "$LINENO" "EGL/egl.h" "ac_cv_header_EGL_egl_h" "$ac_includes_default"
+if test "x$ac_cv_header_EGL_egl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_EGL_EGL_H 1" >>confdefs.h
 
 fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
+ac_fn_c_check_header_compile "$LINENO" "IOKit/IOKitLib.h" "ac_cv_header_IOKit_IOKitLib_h" "$ac_includes_default"
+if test "x$ac_cv_header_IOKit_IOKitLib_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_IOKIT_IOKITLIB_H 1" >>confdefs.h
+
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+ac_fn_c_check_header_compile "$LINENO" "IOKit/hid/IOHIDLib.h" "ac_cv_header_IOKit_hid_IOHIDLib_h" "$ac_includes_default"
+if test "x$ac_cv_header_IOKit_hid_IOHIDLib_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_IOKIT_HID_IOHIDLIB_H 1" >>confdefs.h
 
-else
-  # Broken: fails on valid input.
-continue
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
+ac_fn_c_check_header_compile "$LINENO" "OpenAL/al.h" "ac_cv_header_OpenAL_al_h" "$ac_includes_default"
+if test "x$ac_cv_header_OpenAL_al_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_OPENAL_AL_H 1" >>confdefs.h
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
+ac_fn_c_check_header_compile "$LINENO" "CL/opencl.h" "ac_cv_header_OpenCL_opencl_h" "$ac_includes_default"
+if test "x$ac_cv_header_OpenCL_opencl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_OPENCL_OPENCL_H 1" >>confdefs.h
 
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
+fi
+ac_fn_c_check_header_compile "$LINENO" "QuickTime/ImageCompression.h" "ac_cv_header_QuickTime_ImageCompression_h" "$ac_includes_default"
+if test "x$ac_cv_header_QuickTime_ImageCompression_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_QUICKTIME_IMAGECOMPRESSION_H 1" >>confdefs.h
 
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
 fi
+ac_fn_c_check_header_compile "$LINENO" "Security/Security.h" "ac_cv_header_Security_Security_h" "$ac_includes_default"
+if test "x$ac_cv_header_Security_Security_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SECURITY_SECURITY_H 1" >>confdefs.h
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+fi
+ac_fn_c_check_header_compile "$LINENO" "SystemConfiguration/SCDynamicStoreCopyDHCPInfo.h" "ac_cv_header_SystemConfiguration_SCDynamicStoreCopyDHCPInfo_h" "$ac_includes_default"
+if test "x$ac_cv_header_SystemConfiguration_SCDynamicStoreCopyDHCPInfo_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYSTEMCONFIGURATION_SCDYNAMICSTORECOPYDHCPINFO_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "SystemConfiguration/SCNetworkConfiguration.h" "ac_cv_header_SystemConfiguration_SCNetworkConfiguration_h" "$ac_includes_default"
+if test "x$ac_cv_header_SystemConfiguration_SCNetworkConfiguration_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYSTEMCONFIGURATION_SCNETWORKCONFIGURATION_H 1" >>confdefs.h
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if ${ac_cv_header_stdc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
+fi
+ac_fn_c_check_header_compile "$LINENO" "alias.h" "ac_cv_header_alias_h" "$ac_includes_default"
+if test "x$ac_cv_header_alias_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ALIAS_H 1" >>confdefs.h
 
-int
-main ()
-{
+fi
+ac_fn_c_check_header_compile "$LINENO" "arpa/inet.h" "ac_cv_header_arpa_inet_h" "$ac_includes_default"
+if test "x$ac_cv_header_arpa_inet_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ARPA_INET_H 1" >>confdefs.h
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_fn_c_check_header_compile "$LINENO" "arpa/nameser.h" "ac_cv_header_arpa_nameser_h" "$ac_includes_default"
+if test "x$ac_cv_header_arpa_nameser_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ARPA_NAMESER_H 1" >>confdefs.h
 
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
+fi
+ac_fn_c_check_header_compile "$LINENO" "asm/types.h" "ac_cv_header_asm_types_h" "$ac_includes_default"
+if test "x$ac_cv_header_asm_types_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ASM_TYPES_H 1" >>confdefs.h
 
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
+fi
+ac_fn_c_check_header_compile "$LINENO" "asm/user.h" "ac_cv_header_asm_user_h" "$ac_includes_default"
+if test "x$ac_cv_header_asm_user_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ASM_USER_H 1" >>confdefs.h
 
-else
-  ac_cv_header_stdc=no
 fi
-rm -f conftest*
+ac_fn_c_check_header_compile "$LINENO" "dirent.h" "ac_cv_header_dirent_h" "$ac_includes_default"
+if test "x$ac_cv_header_dirent_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_DIRENT_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "elf.h" "ac_cv_header_elf_h" "$ac_includes_default"
+if test "x$ac_cv_header_elf_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ELF_H 1" >>confdefs.h
 
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
+fi
+ac_fn_c_check_header_compile "$LINENO" "float.h" "ac_cv_header_float_h" "$ac_includes_default"
+if test "x$ac_cv_header_float_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_FLOAT_H 1" >>confdefs.h
 
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
+fi
+ac_fn_c_check_header_compile "$LINENO" "gettext-po.h" "ac_cv_header_gettext_po_h" "$ac_includes_default"
+if test "x$ac_cv_header_gettext_po_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETTEXT_PO_H 1" >>confdefs.h
 
-else
-  ac_cv_header_stdc=no
 fi
-rm -f conftest*
+ac_fn_c_check_header_compile "$LINENO" "ieeefp.h" "ac_cv_header_ieeefp_h" "$ac_includes_default"
+if test "x$ac_cv_header_ieeefp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_IEEEFP_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "libproc.h" "ac_cv_header_libproc_h" "$ac_includes_default"
+if test "x$ac_cv_header_libproc_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBPROC_H 1" >>confdefs.h
 
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
+fi
+ac_fn_c_check_header_compile "$LINENO" "link.h" "ac_cv_header_link_h" "$ac_includes_default"
+if test "x$ac_cv_header_link_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINK_H 1" >>confdefs.h
 
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/cdrom.h" "ac_cv_header_linux_cdrom_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_cdrom_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_CDROM_H 1" >>confdefs.h
 
-else
-  ac_cv_header_stdc=no
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
+ac_fn_c_check_header_compile "$LINENO" "linux/filter.h" "ac_cv_header_linux_filter_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_filter_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_FILTER_H 1" >>confdefs.h
+
 fi
+ac_fn_c_check_header_compile "$LINENO" "linux/hdreg.h" "ac_cv_header_linux_hdreg_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_hdreg_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_HDREG_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "linux/hidraw.h" "ac_cv_header_linux_hidraw_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_hidraw_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_HIDRAW_H 1" >>confdefs.h
+
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
+ac_fn_c_check_header_compile "$LINENO" "linux/input.h" "ac_cv_header_linux_input_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_input_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_INPUT_H 1" >>confdefs.h
 
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/ioctl.h" "ac_cv_header_linux_ioctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_ioctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_IOCTL_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "linux/joystick.h" "ac_cv_header_linux_joystick_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_joystick_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_JOYSTICK_H 1" >>confdefs.h
 
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/major.h" "ac_cv_header_linux_major_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_major_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_MAJOR_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "linux/param.h" "ac_cv_header_linux_param_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_param_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_PARAM_H 1" >>confdefs.h
 
-done
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/serial.h" "ac_cv_header_linux_serial_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_serial_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_SERIAL_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/types.h" "ac_cv_header_linux_types_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_types_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_TYPES_H 1" >>confdefs.h
 
-for ac_header in \
-	AL/al.h \
-	ApplicationServices/ApplicationServices.h \
-	CL/cl.h \
-	Carbon/Carbon.h \
-	CoreAudio/CoreAudio.h \
-	DiskArbitration/DiskArbitration.h \
-	EGL/egl.h \
-	IOKit/IOKitLib.h \
-	IOKit/hid/IOHIDLib.h \
-	OpenAL/al.h \
-	OpenCL/opencl.h \
-	QuickTime/ImageCompression.h \
-	Security/Security.h \
-	SystemConfiguration/SCDynamicStoreCopyDHCPInfo.h \
-	SystemConfiguration/SCNetworkConfiguration.h \
-	alias.h \
-	arpa/inet.h \
-	arpa/nameser.h \
-	asm/types.h \
-	asm/user.h \
-	dirent.h \
-	elf.h \
-	float.h \
-	gettext-po.h \
-	ieeefp.h \
-	libproc.h \
-	link.h \
-	linux/cdrom.h \
-	linux/filter.h \
-	linux/hdreg.h \
-	linux/hidraw.h \
-	linux/input.h \
-	linux/ioctl.h \
-	linux/joystick.h \
-	linux/major.h \
-	linux/param.h \
-	linux/serial.h \
-	linux/types.h \
-	linux/ucdrom.h \
-	lwp.h \
-	mach-o/loader.h \
-	mach/mach.h \
-	machine/cpu.h \
-	machine/sysarch.h \
-	mntent.h \
-	netdb.h \
-	netinet/in.h \
-	netinet/in_systm.h \
-	netinet/tcp.h \
-	netinet/tcp_fsm.h \
-	pcap/pcap.h \
-	port.h \
-	pthread.h \
-	pwd.h \
-	sasl/sasl.h \
-	sched.h \
-	scsi/scsi.h \
-	scsi/scsi_ioctl.h \
-	scsi/sg.h \
-	stdint.h \
-	sys/attr.h \
-	sys/auxv.h \
-	sys/cdio.h \
-	sys/epoll.h \
-	sys/event.h \
-	sys/eventfd.h \
-	sys/filio.h \
-	sys/ioctl.h \
-	sys/ipc.h \
-	sys/link.h \
-	sys/mman.h \
-	sys/modem.h \
-	sys/mtio.h \
-	sys/param.h \
-	sys/prctl.h \
-	sys/protosw.h \
-	sys/ptrace.h \
-	sys/queue.h \
-	sys/random.h \
-	sys/resource.h \
-	sys/scsiio.h \
-	sys/shm.h \
-	sys/signal.h \
-	sys/socket.h \
-	sys/socketvar.h \
-	sys/sockio.h \
-	sys/statvfs.h \
-	sys/strtio.h \
-	sys/syscall.h \
-	sys/sysinfo.h \
-	sys/time.h \
-	sys/timeout.h \
-	sys/times.h \
-	sys/uio.h \
-	sys/user.h \
-	sys/utsname.h \
-	sys/vnode.h \
-	sys/wait.h \
-	syscall.h \
-	termios.h \
-	unistd.h \
-	utime.h \
-	valgrind/memcheck.h \
-	valgrind/valgrind.h
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/ucdrom.h" "ac_cv_header_linux_ucdrom_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_ucdrom_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_UCDROM_H 1" >>confdefs.h
 
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+fi
+ac_fn_c_check_header_compile "$LINENO" "lwp.h" "ac_cv_header_lwp_h" "$ac_includes_default"
+if test "x$ac_cv_header_lwp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LWP_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "mach-o/loader.h" "ac_cv_header_mach_o_loader_h" "$ac_includes_default"
+if test "x$ac_cv_header_mach_o_loader_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACH_O_LOADER_H 1" >>confdefs.h
 
-done
+fi
+ac_fn_c_check_header_compile "$LINENO" "mach/mach.h" "ac_cv_header_mach_mach_h" "$ac_includes_default"
+if test "x$ac_cv_header_mach_mach_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACH_MACH_H 1" >>confdefs.h
 
-ac_fn_c_check_header_mongrel "$LINENO" "sys/mkdev.h" "ac_cv_header_sys_mkdev_h" "$ac_includes_default"
-if test "x$ac_cv_header_sys_mkdev_h" = xyes; then :
+fi
+ac_fn_c_check_header_compile "$LINENO" "machine/cpu.h" "ac_cv_header_machine_cpu_h" "$ac_includes_default"
+if test "x$ac_cv_header_machine_cpu_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACHINE_CPU_H 1" >>confdefs.h
 
-$as_echo "#define MAJOR_IN_MKDEV 1" >>confdefs.h
+fi
+ac_fn_c_check_header_compile "$LINENO" "machine/sysarch.h" "ac_cv_header_machine_sysarch_h" "$ac_includes_default"
+if test "x$ac_cv_header_machine_sysarch_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACHINE_SYSARCH_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "mntent.h" "ac_cv_header_mntent_h" "$ac_includes_default"
+if test "x$ac_cv_header_mntent_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MNTENT_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "netdb.h" "ac_cv_header_netdb_h" "$ac_includes_default"
+if test "x$ac_cv_header_netdb_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETDB_H 1" >>confdefs.h
 
-if test $ac_cv_header_sys_mkdev_h = no; then
-  ac_fn_c_check_header_mongrel "$LINENO" "sys/sysmacros.h" "ac_cv_header_sys_sysmacros_h" "$ac_includes_default"
-if test "x$ac_cv_header_sys_sysmacros_h" = xyes; then :
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/in.h" "ac_cv_header_netinet_in_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_in_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IN_H 1" >>confdefs.h
 
-$as_echo "#define MAJOR_IN_SYSMACROS 1" >>confdefs.h
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/in_systm.h" "ac_cv_header_netinet_in_systm_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_in_systm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IN_SYSTM_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/tcp.h" "ac_cv_header_netinet_tcp_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_tcp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_TCP_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/tcp_fsm.h" "ac_cv_header_netinet_tcp_fsm_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_tcp_fsm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_TCP_FSM_H 1" >>confdefs.h
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stat file-mode macros are broken" >&5
-$as_echo_n "checking whether stat file-mode macros are broken... " >&6; }
-if ${ac_cv_header_stat_broken+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/stat.h>
+ac_fn_c_check_header_compile "$LINENO" "pcap/pcap.h" "ac_cv_header_pcap_pcap_h" "$ac_includes_default"
+if test "x$ac_cv_header_pcap_pcap_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PCAP_PCAP_H 1" >>confdefs.h
 
-#if defined S_ISBLK && defined S_IFDIR
-extern char c1[S_ISBLK (S_IFDIR) ? -1 : 1];
-#endif
+fi
+ac_fn_c_check_header_compile "$LINENO" "port.h" "ac_cv_header_port_h" "$ac_includes_default"
+if test "x$ac_cv_header_port_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PORT_H 1" >>confdefs.h
 
-#if defined S_ISBLK && defined S_IFCHR
-extern char c2[S_ISBLK (S_IFCHR) ? -1 : 1];
-#endif
+fi
+ac_fn_c_check_header_compile "$LINENO" "pthread.h" "ac_cv_header_pthread_h" "$ac_includes_default"
+if test "x$ac_cv_header_pthread_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PTHREAD_H 1" >>confdefs.h
 
-#if defined S_ISLNK && defined S_IFREG
-extern char c3[S_ISLNK (S_IFREG) ? -1 : 1];
-#endif
+fi
+ac_fn_c_check_header_compile "$LINENO" "pwd.h" "ac_cv_header_pwd_h" "$ac_includes_default"
+if test "x$ac_cv_header_pwd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PWD_H 1" >>confdefs.h
 
-#if defined S_ISSOCK && defined S_IFREG
-extern char c4[S_ISSOCK (S_IFREG) ? -1 : 1];
-#endif
+fi
+ac_fn_c_check_header_compile "$LINENO" "sasl/sasl.h" "ac_cv_header_sasl_sasl_h" "$ac_includes_default"
+if test "x$ac_cv_header_sasl_sasl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SASL_SASL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sched.h" "ac_cv_header_sched_h" "$ac_includes_default"
+if test "x$ac_cv_header_sched_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCHED_H 1" >>confdefs.h
 
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stat_broken=no
-else
-  ac_cv_header_stat_broken=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_fn_c_check_header_compile "$LINENO" "scsi/scsi.h" "ac_cv_header_scsi_scsi_h" "$ac_includes_default"
+if test "x$ac_cv_header_scsi_scsi_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCSI_SCSI_H 1" >>confdefs.h
+
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stat_broken" >&5
-$as_echo "$ac_cv_header_stat_broken" >&6; }
-if test $ac_cv_header_stat_broken = yes; then
+ac_fn_c_check_header_compile "$LINENO" "scsi/scsi_ioctl.h" "ac_cv_header_scsi_scsi_ioctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_scsi_scsi_ioctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCSI_SCSI_IOCTL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "scsi/sg.h" "ac_cv_header_scsi_sg_h" "$ac_includes_default"
+if test "x$ac_cv_header_scsi_sg_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCSI_SG_H 1" >>confdefs.h
 
-$as_echo "#define STAT_MACROS_BROKEN 1" >>confdefs.h
+fi
+ac_fn_c_check_header_compile "$LINENO" "stdint.h" "ac_cv_header_stdint_h" "$ac_includes_default"
+if test "x$ac_cv_header_stdint_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_STDINT_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "sys/attr.h" "ac_cv_header_sys_attr_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_attr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_ATTR_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/auxv.h" "ac_cv_header_sys_auxv_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_auxv_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_AUXV_H 1" >>confdefs.h
 
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/cdio.h" "ac_cv_header_sys_cdio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_cdio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_CDIO_H 1" >>confdefs.h
 
-for ac_header in sys/conf.h sys/mount.h sys/statfs.h sys/user.h sys/vfs.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#include <sys/types.h>
-     #ifdef HAVE_SYS_PARAM_H
-     # include <sys/param.h>
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/epoll.h" "ac_cv_header_sys_epoll_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_epoll_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EPOLL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/event.h" "ac_cv_header_sys_event_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_event_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EVENT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/eventfd.h" "ac_cv_header_sys_eventfd_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_eventfd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EVENTFD_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/filio.h" "ac_cv_header_sys_filio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_filio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_FILIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/ioctl.h" "ac_cv_header_sys_ioctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_ioctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_IOCTL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/ipc.h" "ac_cv_header_sys_ipc_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_ipc_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_IPC_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/link.h" "ac_cv_header_sys_link_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_link_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_LINK_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/mman.h" "ac_cv_header_sys_mman_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_mman_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_MMAN_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/modem.h" "ac_cv_header_sys_modem_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_modem_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_MODEM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/mtio.h" "ac_cv_header_sys_mtio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_mtio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_MTIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/param.h" "ac_cv_header_sys_param_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_param_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_PARAM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/prctl.h" "ac_cv_header_sys_prctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_prctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_PRCTL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/protosw.h" "ac_cv_header_sys_protosw_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_protosw_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_PROTOSW_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/ptrace.h" "ac_cv_header_sys_ptrace_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_ptrace_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_PTRACE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/queue.h" "ac_cv_header_sys_queue_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_queue_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_QUEUE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/random.h" "ac_cv_header_sys_random_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_random_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_RANDOM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/resource.h" "ac_cv_header_sys_resource_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_resource_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_RESOURCE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/scsiio.h" "ac_cv_header_sys_scsiio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_scsiio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SCSIIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/shm.h" "ac_cv_header_sys_shm_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_shm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SHM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/signal.h" "ac_cv_header_sys_signal_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_signal_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SIGNAL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/socket.h" "ac_cv_header_sys_socket_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_socket_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SOCKET_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/socketvar.h" "ac_cv_header_sys_socketvar_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_socketvar_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SOCKETVAR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/sockio.h" "ac_cv_header_sys_sockio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_sockio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SOCKIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/statvfs.h" "ac_cv_header_sys_statvfs_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_statvfs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_STATVFS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/strtio.h" "ac_cv_header_sys_strtio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_strtio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_STRTIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/syscall.h" "ac_cv_header_sys_syscall_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_syscall_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SYSCALL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/sysinfo.h" "ac_cv_header_sys_sysinfo_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_sysinfo_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SYSINFO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/time.h" "ac_cv_header_sys_time_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_time_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_TIME_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/timeout.h" "ac_cv_header_sys_timeout_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_timeout_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_TIMEOUT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/times.h" "ac_cv_header_sys_times_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_times_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_TIMES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/uio.h" "ac_cv_header_sys_uio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_uio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/user.h" "ac_cv_header_sys_user_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_user_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_USER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/utsname.h" "ac_cv_header_sys_utsname_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_utsname_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UTSNAME_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/vnode.h" "ac_cv_header_sys_vnode_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_vnode_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_VNODE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/wait.h" "ac_cv_header_sys_wait_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_wait_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_WAIT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "syscall.h" "ac_cv_header_syscall_h" "$ac_includes_default"
+if test "x$ac_cv_header_syscall_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYSCALL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "termios.h" "ac_cv_header_termios_h" "$ac_includes_default"
+if test "x$ac_cv_header_termios_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_TERMIOS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "unistd.h" "ac_cv_header_unistd_h" "$ac_includes_default"
+if test "x$ac_cv_header_unistd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_UNISTD_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "utime.h" "ac_cv_header_utime_h" "$ac_includes_default"
+if test "x$ac_cv_header_utime_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_UTIME_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "valgrind/memcheck.h" "ac_cv_header_valgrind_memcheck_h" "$ac_includes_default"
+if test "x$ac_cv_header_valgrind_memcheck_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_VALGRIND_MEMCHECK_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "valgrind/valgrind.h" "ac_cv_header_valgrind_valgrind_h" "$ac_includes_default"
+if test "x$ac_cv_header_valgrind_valgrind_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_VALGRIND_VALGRIND_H 1" >>confdefs.h
+
+fi
+
+ac_fn_c_check_header_compile "$LINENO" "sys/mkdev.h" "ac_cv_header_sys_mkdev_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_mkdev_h" = xyes
+then :
+
+printf "%s\n" "#define MAJOR_IN_MKDEV 1" >>confdefs.h
+
+fi
+
+if test $ac_cv_header_sys_mkdev_h = no; then
+  ac_fn_c_check_header_compile "$LINENO" "sys/sysmacros.h" "ac_cv_header_sys_sysmacros_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_sysmacros_h" = xyes
+then :
+
+printf "%s\n" "#define MAJOR_IN_SYSMACROS 1" >>confdefs.h
+
+fi
+
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether stat file-mode macros are broken" >&5
+printf %s "checking whether stat file-mode macros are broken... " >&6; }
+if test ${ac_cv_header_stat_broken+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#if defined S_ISBLK && defined S_IFDIR
+extern char c1[S_ISBLK (S_IFDIR) ? -1 : 1];
+#endif
+
+#if defined S_ISBLK && defined S_IFCHR
+extern char c2[S_ISBLK (S_IFCHR) ? -1 : 1];
+#endif
+
+#if defined S_ISLNK && defined S_IFREG
+extern char c3[S_ISLNK (S_IFREG) ? -1 : 1];
+#endif
+
+#if defined S_ISSOCK && defined S_IFREG
+extern char c4[S_ISSOCK (S_IFREG) ? -1 : 1];
+#endif
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_header_stat_broken=no
+else $as_nop
+  ac_cv_header_stat_broken=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stat_broken" >&5
+printf "%s\n" "$ac_cv_header_stat_broken" >&6; }
+if test $ac_cv_header_stat_broken = yes; then
+
+printf "%s\n" "#define STAT_MACROS_BROKEN 1" >>confdefs.h
+
+fi
+
+
+
+ac_fn_c_check_header_compile "$LINENO" "sys/conf.h" "ac_cv_header_sys_conf_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_conf_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_CONF_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/mount.h" "ac_cv_header_sys_mount_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_mount_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_MOUNT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/statfs.h" "ac_cv_header_sys_statfs_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_statfs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_STATFS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/user.h" "ac_cv_header_sys_user_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_user_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_USER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/vfs.h" "ac_cv_header_sys_vfs_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_vfs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_VFS_H 1" >>confdefs.h
+
+fi
+
+
+saved_sysctl_h_CFLAGS=$CFLAGS
+test "x${GCC}" != xyes || CFLAGS="$CFLAGS -Werror"
+ac_fn_c_check_header_compile "$LINENO" "sys/sysctl.h" "ac_cv_header_sys_sysctl_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_sysctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SYSCTL_H 1" >>confdefs.h
+
+fi
+
+CFLAGS=$saved_sysctl_h_CFLAGS
+
+ac_fn_c_check_header_compile "$LINENO" "netinet/ip.h" "ac_cv_header_netinet_ip_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_ip_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if.h" "ac_cv_header_net_if_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if_arp.h" "ac_cv_header_net_if_arp_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_arp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_ARP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if_dl.h" "ac_cv_header_net_if_dl_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_dl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_DL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if_types.h" "ac_cv_header_net_if_types_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_types_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_TYPES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/route.h" "ac_cv_header_net_route_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_route_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_ROUTE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/if_ether.h" "ac_cv_header_netinet_if_ether_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_if_ether_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IF_ETHER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/if_inarp.h" "ac_cv_header_netinet_if_inarp_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_if_inarp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IF_INARP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/in_pcb.h" "ac_cv_header_netinet_in_pcb_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_in_pcb_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IN_PCB_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/ip_icmp.h" "ac_cv_header_netinet_ip_icmp_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_ip_icmp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IP_ICMP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/ip_var.h" "ac_cv_header_netinet_ip_var_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_ip_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IP_VAR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/udp.h" "ac_cv_header_netinet_udp_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_udp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_UDP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netipx/ipx.h" "ac_cv_header_netipx_ipx_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netipx_ipx_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETIPX_IPX_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/un.h" "ac_cv_header_sys_un_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_un_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UN_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "netinet/tcp_timer.h" "ac_cv_header_netinet_tcp_timer_h" "#include <sys/types.h>
+     #ifdef HAVE_ALIAS_H
+     # include <alias.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_SYS_TIMEOUT_H
+     # include <sys/timeout.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_TIMER_H
+     #include <netinet/tcp_timer.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_tcp_timer_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_TCP_TIMER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/udp_var.h" "ac_cv_header_netinet_udp_var_h" "#include <sys/types.h>
+     #ifdef HAVE_ALIAS_H
+     # include <alias.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_SYS_TIMEOUT_H
+     # include <sys/timeout.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
      #endif
-"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-saved_sysctl_h_CFLAGS=$CFLAGS
-test "x${GCC}" != xyes || CFLAGS="$CFLAGS -Werror"
-for ac_header in sys/sysctl.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "sys/sysctl.h" "ac_cv_header_sys_sysctl_h" "#include <sys/types.h>
-     #ifdef HAVE_SYS_PARAM_H
-     # include <sys/param.h>
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_TIMER_H
+     #include <netinet/tcp_timer.h>
      #endif
 "
-if test "x$ac_cv_header_sys_sysctl_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_SYS_SYSCTL_H 1
-_ACEOF
+if test "x$ac_cv_header_netinet_udp_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_UDP_VAR_H 1" >>confdefs.h
 
 fi
-
-done
-
-CFLAGS=$saved_sysctl_h_CFLAGS
-
-for ac_header in \
-	netinet/ip.h \
-	net/if.h \
-	net/if_arp.h \
-	net/if_dl.h \
-	net/if_types.h \
-	net/route.h \
-	netinet/if_ether.h \
-	netinet/if_inarp.h \
-	netinet/in_pcb.h \
-	netinet/ip_icmp.h \
-	netinet/ip_var.h \
-	netinet/udp.h \
-	netipx/ipx.h \
-	sys/un.h \
-
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#include <sys/types.h>
+ac_fn_c_check_header_compile "$LINENO" "netinet/icmp_var.h" "ac_cv_header_netinet_icmp_var_h" "#include <sys/types.h>
+     #ifdef HAVE_ALIAS_H
+     # include <alias.h>
+     #endif
      #ifdef HAVE_SYS_SOCKET_H
      # include <sys/socket.h>
      #endif
      #ifdef HAVE_SYS_SOCKETVAR_H
      # include <sys/socketvar.h>
      #endif
-     #ifdef HAVE_NET_ROUTE_H
-     # include <net/route.h>
+     #ifdef HAVE_SYS_TIMEOUT_H
+     # include <sys/timeout.h>
      #endif
      #ifdef HAVE_NETINET_IN_H
      # include <netinet/in.h>
@@ -7680,27 +9407,31 @@ ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#include <s
      #ifdef HAVE_NETINET_IN_SYSTM_H
      # include <netinet/in_systm.h>
      #endif
-     #ifdef HAVE_NET_IF_H
-     # include <net/if.h>
-     #endif
      #ifdef HAVE_NETINET_IP_H
      # include <netinet/ip.h>
      #endif
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_TIMER_H
+     #include <netinet/tcp_timer.h>
+     #endif
 "
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+if test "x$ac_cv_header_netinet_icmp_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_ICMP_VAR_H 1" >>confdefs.h
 
 fi
-
-done
-
-
-for ac_header in netinet/tcp_timer.h netinet/udp_var.h netinet/icmp_var.h netinet/tcp_var.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#include <sys/types.h>
+ac_fn_c_check_header_compile "$LINENO" "netinet/tcp_var.h" "ac_cv_header_netinet_tcp_var_h" "#include <sys/types.h>
      #ifdef HAVE_ALIAS_H
      # include <alias.h>
      #endif
@@ -7738,20 +9469,30 @@ ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#include <s
      #include <netinet/tcp_timer.h>
      #endif
 "
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+if test "x$ac_cv_header_netinet_tcp_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_TCP_VAR_H 1" >>confdefs.h
 
 fi
 
-done
 
+ac_fn_c_check_header_compile "$LINENO" "linux/ipx.h" "ac_cv_header_linux_ipx_h" "#include <sys/types.h>
+     #ifdef HAVE_ASM_TYPES_H
+     # include <asm/types.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_LINUX_TYPES_H
+     # include <linux/types.h>
+     #endif
+"
+if test "x$ac_cv_header_linux_ipx_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_IPX_H 1" >>confdefs.h
 
-for ac_header in linux/ipx.h linux/irda.h linux/rtnetlink.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#include <sys/types.h>
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/irda.h" "ac_cv_header_linux_irda_h" "#include <sys/types.h>
      #ifdef HAVE_ASM_TYPES_H
      # include <asm/types.h>
      #endif
@@ -7762,19 +9503,30 @@ ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#include <s
      # include <linux/types.h>
      #endif
 "
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+if test "x$ac_cv_header_linux_irda_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_IRDA_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "linux/rtnetlink.h" "ac_cv_header_linux_rtnetlink_h" "#include <sys/types.h>
+     #ifdef HAVE_ASM_TYPES_H
+     # include <asm/types.h>
+     #endif
+     #ifdef HAVE_SYS_SOCKET_H
+     # include <sys/socket.h>
+     #endif
+     #ifdef HAVE_LINUX_TYPES_H
+     # include <linux/types.h>
+     #endif
+"
+if test "x$ac_cv_header_linux_rtnetlink_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_RTNETLINK_H 1" >>confdefs.h
 
-done
+fi
 
 
-for ac_header in resolv.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "resolv.h" "ac_cv_header_resolv_h" "#include <sys/types.h>
+ac_fn_c_check_header_compile "$LINENO" "resolv.h" "ac_cv_header_resolv_h" "#include <sys/types.h>
      #ifdef HAVE_SYS_SOCKET_H
      # include <sys/socket.h>
      #endif
@@ -7785,80 +9537,55 @@ do :
      # include <arpa/nameser.h>
      #endif
 "
-if test "x$ac_cv_header_resolv_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_RESOLV_H 1
-_ACEOF
+if test "x$ac_cv_header_resolv_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_RESOLV_H 1" >>confdefs.h
 
 fi
 
-done
-
 
-for ac_header in ifaddrs.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "ifaddrs.h" "ac_cv_header_ifaddrs_h" "#include <sys/types.h>
+ac_fn_c_check_header_compile "$LINENO" "ifaddrs.h" "ac_cv_header_ifaddrs_h" "#include <sys/types.h>
 "
-if test "x$ac_cv_header_ifaddrs_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_IFADDRS_H 1
-_ACEOF
+if test "x$ac_cv_header_ifaddrs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_IFADDRS_H 1" >>confdefs.h
 
 fi
 
-done
-
 
-for ac_header in sys/ucontext.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "sys/ucontext.h" "ac_cv_header_sys_ucontext_h" "#include <signal.h>
+ac_fn_c_check_header_compile "$LINENO" "sys/ucontext.h" "ac_cv_header_sys_ucontext_h" "#include <signal.h>
 "
-if test "x$ac_cv_header_sys_ucontext_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_SYS_UCONTEXT_H 1
-_ACEOF
+if test "x$ac_cv_header_sys_ucontext_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UCONTEXT_H 1" >>confdefs.h
 
 fi
 
-done
-
 
-for ac_header in sys/thr.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "sys/thr.h" "ac_cv_header_sys_thr_h" "#include <sys/types.h>
+ac_fn_c_check_header_compile "$LINENO" "sys/thr.h" "ac_cv_header_sys_thr_h" "#include <sys/types.h>
 #ifdef HAVE_SYS_UCONTEXT_H
 #include <sys/ucontext.h>
 #endif
 "
-if test "x$ac_cv_header_sys_thr_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_SYS_THR_H 1
-_ACEOF
+if test "x$ac_cv_header_sys_thr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_THR_H 1" >>confdefs.h
 
 fi
 
-done
-
 
-for ac_header in pthread_np.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "pthread_np.h" "ac_cv_header_pthread_np_h" "#ifdef HAVE_PTHREAD_H
+ac_fn_c_check_header_compile "$LINENO" "pthread_np.h" "ac_cv_header_pthread_np_h" "#ifdef HAVE_PTHREAD_H
 #include <pthread.h>
 #endif
 "
-if test "x$ac_cv_header_pthread_np_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_PTHREAD_NP_H 1
-_ACEOF
+if test "x$ac_cv_header_pthread_np_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PTHREAD_NP_H 1" >>confdefs.h
 
 fi
 
-done
-
 
-for ac_header in linux/videodev2.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "linux/videodev2.h" "ac_cv_header_linux_videodev2_h" "#ifdef HAVE_SYS_TIME_H
+ac_fn_c_check_header_compile "$LINENO" "linux/videodev2.h" "ac_cv_header_linux_videodev2_h" "#ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
 #include <sys/types.h>
@@ -7866,19 +9593,14 @@ do :
 #include <asm/types.h>
 #endif
 "
-if test "x$ac_cv_header_linux_videodev2_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LINUX_VIDEODEV2_H 1
-_ACEOF
+if test "x$ac_cv_header_linux_videodev2_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_VIDEODEV2_H 1" >>confdefs.h
 
 fi
 
-done
-
 
-for ac_header in libprocstat.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "libprocstat.h" "ac_cv_header_libprocstat_h" "#ifdef HAVE_SYS_PARAM_H
+ac_fn_c_check_header_compile "$LINENO" "libprocstat.h" "ac_cv_header_libprocstat_h" "#ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 #ifdef HAVE_SYS_QUEUE_H
@@ -7888,15 +9610,12 @@ do :
 #include <sys/socket.h>
 #endif
 "
-if test "x$ac_cv_header_libprocstat_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBPROCSTAT_H 1
-_ACEOF
+if test "x$ac_cv_header_libprocstat_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBPROCSTAT_H 1" >>confdefs.h
 
 fi
 
-done
-
 
 
 DLLFLAGS=""
@@ -7922,11 +9641,12 @@ WINEPRELOADER_LDFLAGS=""
 LIBEXT="so"
 # Extract the first word of "ldd", so it can be a program name with args.
 set dummy ldd; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_LDD+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_LDD+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   case $LDD in
   [\\/]* | ?:[\\/]*)
   ac_cv_path_LDD="$LDD" # Let the user override the test with a path.
@@ -7937,11 +9657,15 @@ as_dummy="/sbin:/usr/sbin:$PATH"
 for as_dir in $as_dummy
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_LDD="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_LDD="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -7954,22 +9678,23 @@ esac
 fi
 LDD=$ac_cv_path_LDD
 if test -n "$LDD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LDD" >&5
-$as_echo "$LDD" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $LDD" >&5
+printf "%s\n" "$LDD" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
 set dummy ${ac_tool_prefix}otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_OTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_OTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$OTOOL"; then
   ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
 else
@@ -7977,11 +9702,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -7992,11 +9721,11 @@ fi
 fi
 OTOOL=$ac_cv_prog_OTOOL
 if test -n "$OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
-$as_echo "$OTOOL" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
+printf "%s\n" "$OTOOL" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -8005,11 +9734,12 @@ if test -z "$ac_cv_prog_OTOOL"; then
   ac_ct_OTOOL=$OTOOL
   # Extract the first word of "otool", so it can be a program name with args.
 set dummy otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_OTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_OTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_OTOOL"; then
   ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
 else
@@ -8017,11 +9747,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_OTOOL="otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -8032,11 +9766,11 @@ fi
 fi
 ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
 if test -n "$ac_ct_OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
-$as_echo "$ac_ct_OTOOL" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
+printf "%s\n" "$ac_ct_OTOOL" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_OTOOL" = x; then
@@ -8044,8 +9778,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     OTOOL=$ac_ct_OTOOL
@@ -8057,11 +9791,12 @@ fi
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}readelf", so it can be a program name with args.
 set dummy ${ac_tool_prefix}readelf; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_READELF+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_READELF+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$READELF"; then
   ac_cv_prog_READELF="$READELF" # Let the user override the test.
 else
@@ -8069,11 +9804,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_READELF="${ac_tool_prefix}readelf"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -8084,11 +9823,11 @@ fi
 fi
 READELF=$ac_cv_prog_READELF
 if test -n "$READELF"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $READELF" >&5
-$as_echo "$READELF" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $READELF" >&5
+printf "%s\n" "$READELF" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -8097,11 +9836,12 @@ if test -z "$ac_cv_prog_READELF"; then
   ac_ct_READELF=$READELF
   # Extract the first word of "readelf", so it can be a program name with args.
 set dummy readelf; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_READELF+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_READELF+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_READELF"; then
   ac_cv_prog_ac_ct_READELF="$ac_ct_READELF" # Let the user override the test.
 else
@@ -8109,11 +9849,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_READELF="readelf"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -8124,11 +9868,11 @@ fi
 fi
 ac_ct_READELF=$ac_cv_prog_ac_ct_READELF
 if test -n "$ac_ct_READELF"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_READELF" >&5
-$as_echo "$ac_ct_READELF" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_READELF" >&5
+printf "%s\n" "$ac_ct_READELF" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_READELF" = x; then
@@ -8136,8 +9880,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     READELF=$ac_ct_READELF
@@ -8162,13 +9906,14 @@ wine_fn_append_file ()
 
 wine_fn_append_rule ()
 {
-    $as_echo "$1" >>$wine_rules_file
+    printf "%s\n" "$1" >>$wine_rules_file
 }
 
 wine_fn_config_makefile ()
 {
     wine_fn_append_file SUBDIRS $1
-    if eval test \"x\$"$2"\" = x"no"; then :
+    if eval test \"x\$"$2"\" = x"no"
+then :
   wine_fn_append_file DISABLED_SUBDIRS $1
 fi
 }
@@ -8193,11 +9938,12 @@ case $host_os in
     if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}dlltool", so it can be a program name with args.
 set dummy ${ac_tool_prefix}dlltool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_DLLTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_DLLTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$DLLTOOL"; then
   ac_cv_prog_DLLTOOL="$DLLTOOL" # Let the user override the test.
 else
@@ -8205,11 +9951,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_DLLTOOL="${ac_tool_prefix}dlltool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -8220,11 +9970,11 @@ fi
 fi
 DLLTOOL=$ac_cv_prog_DLLTOOL
 if test -n "$DLLTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DLLTOOL" >&5
-$as_echo "$DLLTOOL" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $DLLTOOL" >&5
+printf "%s\n" "$DLLTOOL" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -8233,11 +9983,12 @@ if test -z "$ac_cv_prog_DLLTOOL"; then
   ac_ct_DLLTOOL=$DLLTOOL
   # Extract the first word of "dlltool", so it can be a program name with args.
 set dummy dlltool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_DLLTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_DLLTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_DLLTOOL"; then
   ac_cv_prog_ac_ct_DLLTOOL="$ac_ct_DLLTOOL" # Let the user override the test.
 else
@@ -8245,11 +9996,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_DLLTOOL="dlltool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -8260,11 +10015,11 @@ fi
 fi
 ac_ct_DLLTOOL=$ac_cv_prog_ac_ct_DLLTOOL
 if test -n "$ac_ct_DLLTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DLLTOOL" >&5
-$as_echo "$ac_ct_DLLTOOL" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DLLTOOL" >&5
+printf "%s\n" "$ac_ct_DLLTOOL" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_DLLTOOL" = x; then
@@ -8272,8 +10027,8 @@ fi
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     DLLTOOL=$ac_ct_DLLTOOL
@@ -8285,29 +10040,32 @@ fi
     LIBEXT="dll"
     EXTRACFLAGS="-D__WINE_PE_BUILD"
         case $host_cpu in
-      *i[3456]86*) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--disable-stdcall-fixup" >&5
-$as_echo_n "checking whether the compiler supports -Wl,--disable-stdcall-fixup... " >&6; }
-if ${ac_cv_cflags__Wl___disable_stdcall_fixup+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      *i[3456]86*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--disable-stdcall-fixup" >&5
+printf %s "checking whether the compiler supports -Wl,--disable-stdcall-fixup... " >&6; }
+if test ${ac_cv_cflags__Wl___disable_stdcall_fixup+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,--disable-stdcall-fixup"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl___disable_stdcall_fixup=yes
-else
+else $as_nop
   ac_cv_cflags__Wl___disable_stdcall_fixup=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___disable_stdcall_fixup" >&5
-$as_echo "$ac_cv_cflags__Wl___disable_stdcall_fixup" >&6; }
-if test "x$ac_cv_cflags__Wl___disable_stdcall_fixup" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___disable_stdcall_fixup" >&5
+printf "%s\n" "$ac_cv_cflags__Wl___disable_stdcall_fixup" >&6; }
+if test "x$ac_cv_cflags__Wl___disable_stdcall_fixup" = xyes
+then :
   LDDLLFLAGS="-Wl,--disable-stdcall-fixup"
 fi ;;
     esac
@@ -8331,15 +10089,16 @@ ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$OBJC -o conftest$ac_exeext $OBJCFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_objc_compiler_gnu
 if test -n "$ac_tool_prefix"; then
-  for ac_prog in gcc objcc objc cc CC
+  for ac_prog in gcc objcc objc cc CC clang
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_OBJC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_OBJC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$OBJC"; then
   ac_cv_prog_OBJC="$OBJC" # Let the user override the test.
 else
@@ -8347,11 +10106,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_OBJC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -8362,11 +10125,11 @@ fi
 fi
 OBJC=$ac_cv_prog_OBJC
 if test -n "$OBJC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJC" >&5
-$as_echo "$OBJC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $OBJC" >&5
+printf "%s\n" "$OBJC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -8375,15 +10138,16 @@ fi
 fi
 if test -z "$OBJC"; then
   ac_ct_OBJC=$OBJC
-  for ac_prog in gcc objcc objc cc CC
+  for ac_prog in gcc objcc objc cc CC clang
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_OBJC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_OBJC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_OBJC"; then
   ac_cv_prog_ac_ct_OBJC="$ac_ct_OBJC" # Let the user override the test.
 else
@@ -8391,11 +10155,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_OBJC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -8406,11 +10174,11 @@ fi
 fi
 ac_ct_OBJC=$ac_cv_prog_ac_ct_OBJC
 if test -n "$ac_ct_OBJC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJC" >&5
-$as_echo "$ac_ct_OBJC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJC" >&5
+printf "%s\n" "$ac_ct_OBJC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -8422,8 +10190,8 @@ done
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     OBJC=$ac_ct_OBJC
@@ -8431,7 +10199,7 @@ esac
 fi
 
 # Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for Objective C compiler version" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for Objective C compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
 for ac_option in --version -v -V -qversion; do
@@ -8441,7 +10209,7 @@ case "(($ac_try" in
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
@@ -8451,20 +10219,21 @@ $as_echo "$ac_try_echo"; } >&5
     cat conftest.er1 >&5
   fi
   rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
 done
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU Objective C compiler" >&5
-$as_echo_n "checking whether we are using the GNU Objective C compiler... " >&6; }
-if ${ac_cv_objc_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU Objective C" >&5
+printf %s "checking whether the compiler supports GNU Objective C... " >&6; }
+if test ${ac_cv_objc_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 #ifndef __GNUC__
        choke me
@@ -8474,29 +10243,33 @@ main ()
   return 0;
 }
 _ACEOF
-if ac_fn_objc_try_compile "$LINENO"; then :
+if ac_fn_objc_try_compile "$LINENO"
+then :
   ac_compiler_gnu=yes
-else
+else $as_nop
   ac_compiler_gnu=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 ac_cv_objc_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objc_compiler_gnu" >&5
-$as_echo "$ac_cv_objc_compiler_gnu" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objc_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_objc_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_objc_compiler_gnu
+
 if test $ac_compiler_gnu = yes; then
   GOBJC=yes
 else
   GOBJC=
 fi
-ac_test_OBJCFLAGS=${OBJCFLAGS+set}
+ac_test_OBJCFLAGS=${OBJCFLAGS+y}
 ac_save_OBJCFLAGS=$OBJCFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $OBJC accepts -g" >&5
-$as_echo_n "checking whether $OBJC accepts -g... " >&6; }
-if ${ac_cv_prog_objc_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $OBJC accepts -g" >&5
+printf %s "checking whether $OBJC accepts -g... " >&6; }
+if test ${ac_cv_prog_objc_g+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_save_objc_werror_flag=$ac_objc_werror_flag
    ac_objc_werror_flag=yes
    ac_cv_prog_objc_g=no
@@ -8505,205 +10278,74 @@ else
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_objc_try_compile "$LINENO"; then :
+if ac_fn_objc_try_compile "$LINENO"
+then :
   ac_cv_prog_objc_g=yes
-else
+else $as_nop
   OBJCFLAGS=""
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_objc_try_compile "$LINENO"; then :
+if ac_fn_objc_try_compile "$LINENO"
+then :
 
-else
+else $as_nop
   ac_objc_werror_flag=$ac_save_objc_werror_flag
 	 OBJCFLAGS="-g"
 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_objc_try_compile "$LINENO"; then :
+if ac_fn_objc_try_compile "$LINENO"
+then :
   ac_cv_prog_objc_g=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
    ac_objc_werror_flag=$ac_save_objc_werror_flag
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_objc_g" >&5
-$as_echo "$ac_cv_prog_objc_g" >&6; }
-if test "$ac_test_OBJCFLAGS" = set; then
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_objc_g" >&5
+printf "%s\n" "$ac_cv_prog_objc_g" >&6; }
+if test $ac_test_OBJCFLAGS; then
   OBJCFLAGS=$ac_save_OBJCFLAGS
 elif test $ac_cv_prog_objc_g = yes; then
   if test "$GOBJC" = yes; then
     OBJCFLAGS="-g -O2"
-  else
-    OBJCFLAGS="-g"
-  fi
-else
-  if test "$GOBJC" = yes; then
-    OBJCFLAGS="-O2"
-  else
-    OBJCFLAGS=
-  fi
-fi
-ac_ext=m
-ac_cpp='$OBJCPP $CPPFLAGS'
-ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$OBJC -o conftest$ac_exeext $OBJCFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_objc_compiler_gnu
-
-
-ac_ext=m
-ac_cpp='$OBJCPP $CPPFLAGS'
-ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$OBJC -o conftest$ac_exeext $OBJCFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_objc_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the Objective C preprocessor" >&5
-$as_echo_n "checking how to run the Objective C preprocessor... " >&6; }
-if test -z "$OBJCPP"; then
-  if ${ac_cv_prog_OBJCPP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because OBJCPP needs to be expanded
-    for OBJCPP in "$OBJC -E" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_objc_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_objc_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_objc_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_OBJCPP=$OBJCPP
-
-fi
-  OBJCPP=$ac_cv_prog_OBJCPP
-else
-  ac_cv_prog_OBJCPP=$OBJCPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJCPP" >&5
-$as_echo "$OBJCPP" >&6; }
-ac_preproc_ok=false
-for ac_objc_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_objc_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_objc_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
+  else
+    OBJCFLAGS="-g"
+  fi
 else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "Objective C preprocessor \"$OBJCPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
+  if test "$GOBJC" = yes; then
+    OBJCFLAGS="-O2"
+  else
+    OBJCFLAGS=
+  fi
 fi
-
 ac_ext=m
 ac_cpp='$OBJCPP $CPPFLAGS'
 ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -8711,18 +10353,13 @@ ac_link='$OBJC -o conftest$ac_exeext $OBJCFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_
 ac_compiler_gnu=$ac_cv_objc_compiler_gnu
 
 
-for ac_header in Metal/Metal.h
-do :
-  ac_fn_objc_check_header_mongrel "$LINENO" "Metal/Metal.h" "ac_cv_header_Metal_Metal_h" "$ac_includes_default"
-if test "x$ac_cv_header_Metal_Metal_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_METAL_METAL_H 1
-_ACEOF
+ac_fn_objc_check_header_compile "$LINENO" "Metal/Metal.h" "ac_cv_header_Metal_Metal_h" "$ac_includes_default"
+if test "x$ac_cv_header_Metal_Metal_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_METAL_METAL_H 1" >>confdefs.h
 
 fi
 
-done
-
     ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -8749,111 +10386,123 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
     wine_can_build_preloader=yes
     WINEPRELOADER_LDFLAGS="-nostartfiles -nodefaultlibs -e _start -ldylib1.o -Wl,-image_base,0x7d400000,-segalign,0x1000,-pagezero_size,0x1000,-sectcreate,__TEXT,__info_plist,loader/wine_info.plist,-segaddr,WINE_4GB_RESERVE,0x100000000"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_new_main -e _main" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-no_new_main -e _main... " >&6; }
-if ${ac_cv_cflags__Wl__no_new_main__e__main+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_new_main -e _main" >&5
+printf %s "checking whether the compiler supports -Wl,-no_new_main -e _main... " >&6; }
+if test ${ac_cv_cflags__Wl__no_new_main__e__main+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-no_new_main -e _main"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__no_new_main__e__main=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__no_new_main__e__main=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_new_main__e__main" >&5
-$as_echo "$ac_cv_cflags__Wl__no_new_main__e__main" >&6; }
-if test "x$ac_cv_cflags__Wl__no_new_main__e__main" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_new_main__e__main" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__no_new_main__e__main" >&6; }
+if test "x$ac_cv_cflags__Wl__no_new_main__e__main" = xyes
+then :
   WINEPRELOADER_LDFLAGS="-Wl,-no_new_main $WINEPRELOADER_LDFLAGS"
-                     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_new_main -e _main -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-no_new_main -e _main -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs... " >&6; }
-if ${ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                     { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_new_main -e _main -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs" >&5
+printf %s "checking whether the compiler supports -Wl,-no_new_main -e _main -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs... " >&6; }
+if test ${ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-no_new_main -e _main -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&5
-$as_echo "$ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&6; }
-if test "x$ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&6; }
+if test "x$ac_cv_cflags__Wl__no_new_main__e__main__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" = xyes
+then :
   WINEPRELOADER_LDFLAGS="-mmacosx-version-min=10.7 $WINEPRELOADER_LDFLAGS"
-else
+else $as_nop
   wine_can_build_preloader=no
 fi
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs" >&5
-$as_echo_n "checking whether the compiler supports -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs... " >&6; }
-if ${ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs" >&5
+printf %s "checking whether the compiler supports -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs... " >&6; }
+if test ${ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -mmacosx-version-min=10.7 -nostartfiles -nodefaultlibs"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs=yes
-else
+else $as_nop
   ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&5
-$as_echo "$ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&6; }
-if test "x$ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&5
+printf "%s\n" "$ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" >&6; }
+if test "x$ac_cv_cflags__mmacosx_version_min_10_7__nostartfiles__nodefaultlibs" = xyes
+then :
   WINEPRELOADER_LDFLAGS="-mmacosx-version-min=10.7 $WINEPRELOADER_LDFLAGS"
-else
+else $as_nop
   wine_can_build_preloader=no
 fi
 fi
     if test "$wine_can_build_preloader" = "yes"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_pie" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-no_pie... " >&6; }
-if ${ac_cv_cflags__Wl__no_pie+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_pie" >&5
+printf %s "checking whether the compiler supports -Wl,-no_pie... " >&6; }
+if test ${ac_cv_cflags__Wl__no_pie+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-no_pie"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__no_pie=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__no_pie=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_pie" >&5
-$as_echo "$ac_cv_cflags__Wl__no_pie" >&6; }
-if test "x$ac_cv_cflags__Wl__no_pie" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_pie" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__no_pie" >&6; }
+if test "x$ac_cv_cflags__Wl__no_pie" = xyes
+then :
   WINEPRELOADER_LDFLAGS="-Wl,-no_pie $WINEPRELOADER_LDFLAGS"
 fi
         test "$wine_binary" = wine || wine_fn_append_file CONFIGURE_TARGETS "loader/wine-preloader"
@@ -8883,9 +10532,7 @@ fi
         OPENAL_LIBS="-framework OpenAL"
 
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_OPENAL 1
-_ACEOF
+printf "%s\n" "#define HAVE_OPENAL 1" >>confdefs.h
 
         ac_cv_lib_openal=yes
     fi
@@ -8899,16 +10546,12 @@ _ACEOF
     then
         ac_save_LIBS="$LIBS"
         LIBS="$LIBS $IOKIT_LIBS"
-        for ac_func in IOHIDManagerCreate
-do :
-  ac_fn_c_check_func "$LINENO" "IOHIDManagerCreate" "ac_cv_func_IOHIDManagerCreate"
-if test "x$ac_cv_func_IOHIDManagerCreate" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_IOHIDMANAGERCREATE 1
-_ACEOF
+        ac_fn_c_check_func "$LINENO" "IOHIDManagerCreate" "ac_cv_func_IOHIDManagerCreate"
+if test "x$ac_cv_func_IOHIDManagerCreate" = xyes
+then :
+  printf "%s\n" "#define HAVE_IOHIDMANAGERCREATE 1" >>confdefs.h
 
 fi
-done
 
         LIBS="$ac_save_LIBS"
     fi
@@ -8919,36 +10562,38 @@ done
         then
                         ac_save_LIBS="$LIBS"
             LIBS="-framework QuickTime -framework ApplicationServices -framework CoreVideo $LIBS"
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the QuickTime framework" >&5
-$as_echo_n "checking for the QuickTime framework... " >&6; }
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for the QuickTime framework" >&5
+printf %s "checking for the QuickTime framework... " >&6; }
             cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <QuickTime/ImageCompression.h>
 int
-main ()
+main (void)
 {
 CodecManagerVersion(NULL);
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+if ac_fn_c_try_link "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
                             QUICKTIME_LIBS="-framework QuickTime -framework ApplicationServices -framework CoreVideo"
 
                             enable_wineqtdecoder=${enable_wineqtdecoder:-yes}
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
                             ac_cv_header_QuickTime_ImageCompression_h=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
             LIBS="$ac_save_LIBS"
         fi
     fi
-    if test "$ac_cv_header_QuickTime_ImageCompression_h" != "yes"; then :
+    if test "$ac_cv_header_QuickTime_ImageCompression_h" != "yes"
+then :
   case "x$with_quicktime" in
   x)   as_fn_append wine_notices "|QuickTime ${notice_platform}development files not found, video decoding won't be supported." ;;
   xno) ;;
@@ -8971,8 +10616,8 @@ fi
 
         if test "$ac_cv_header_Metal_Metal_h" = "yes"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether MTLDevice protocol supports registryID property" >&5
-$as_echo_n "checking whether MTLDevice protocol supports registryID property... " >&6; }
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether MTLDevice protocol supports registryID property" >&5
+printf %s "checking whether MTLDevice protocol supports registryID property... " >&6; }
         ac_ext=m
 ac_cpp='$OBJCPP $CPPFLAGS'
 ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -8983,24 +10628,25 @@ ac_compiler_gnu=$ac_cv_objc_compiler_gnu
 /* end confdefs.h.  */
 #include <Metal/Metal.h>
 int
-main ()
+main (void)
 {
 id<MTLDevice> device; device.registryID;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_objc_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+if ac_fn_objc_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-$as_echo "#define HAVE_MTLDEVICE_REGISTRYID 1" >>confdefs.h
+printf "%s\n" "#define HAVE_MTLDEVICE_REGISTRYID 1" >>confdefs.h
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
         ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -9014,7 +10660,8 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
         ac_save_LIBS="$LIBS"
         LIBS="$LIBS $APPLICATIONSERVICES_LIBS"
         ac_fn_c_check_func "$LINENO" "CGDisplayModeGetWidth" "ac_cv_func_CGDisplayModeGetWidth"
-if test "x$ac_cv_func_CGDisplayModeGetWidth" = xyes; then :
+if test "x$ac_cv_func_CGDisplayModeGetWidth" = xyes
+then :
   enable_winemac_drv=${enable_winemac_drv:-yes}
 fi
 
@@ -9033,69 +10680,76 @@ fi
 
   linux-android*)
 
-$as_echo "#define _GNU_SOURCE 1" >>confdefs.h
+printf "%s\n" "#define _GNU_SOURCE 1" >>confdefs.h
 
     DLLFLAGS="$DLLFLAGS -fPIC"
     LDDLLFLAGS="-fPIC"
     LDEXECFLAGS="-Wl,-pie"
     enable_wineandroid_drv=${enable_wineandroid_drv:-yes}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-z,defs" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-z,defs... " >&6; }
-if ${ac_cv_cflags__Wl__z_defs+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-z,defs" >&5
+printf %s "checking whether the compiler supports -Wl,-z,defs... " >&6; }
+if test ${ac_cv_cflags__Wl__z_defs+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-z,defs"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__z_defs=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__z_defs=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_defs" >&5
-$as_echo "$ac_cv_cflags__Wl__z_defs" >&6; }
-if test "x$ac_cv_cflags__Wl__z_defs" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_defs" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__z_defs" >&6; }
+if test "x$ac_cv_cflags__Wl__z_defs" = xyes
+then :
   UNIXLDFLAGS="$UNIXLDFLAGS -Wl,-z,defs"
 fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fPIC -Wl,--export-dynamic" >&5
-$as_echo_n "checking whether the compiler supports -fPIC -Wl,--export-dynamic... " >&6; }
-if ${ac_cv_cflags__fPIC__Wl___export_dynamic+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fPIC -Wl,--export-dynamic" >&5
+printf %s "checking whether the compiler supports -fPIC -Wl,--export-dynamic... " >&6; }
+if test ${ac_cv_cflags__fPIC__Wl___export_dynamic+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fPIC -Wl,--export-dynamic"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fPIC__Wl___export_dynamic=yes
-else
+else $as_nop
   ac_cv_cflags__fPIC__Wl___export_dynamic=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fPIC__Wl___export_dynamic" >&5
-$as_echo "$ac_cv_cflags__fPIC__Wl___export_dynamic" >&6; }
-if test "x$ac_cv_cflags__fPIC__Wl___export_dynamic" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fPIC__Wl___export_dynamic" >&5
+printf "%s\n" "$ac_cv_cflags__fPIC__Wl___export_dynamic" >&6; }
+if test "x$ac_cv_cflags__fPIC__Wl___export_dynamic" = xyes
+then :
   WINELOADER_LDFLAGS="-Wl,--export-dynamic"
 fi
     WINEPRELOADER_LDFLAGS="-static -nostartfiles -nodefaultlibs -Wl,-Ttext=0x7d400000"
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lEGL" >&5
-$as_echo_n "checking for -lEGL... " >&6; }
-if ${ac_cv_lib_soname_EGL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lEGL" >&5
+printf %s "checking for -lEGL... " >&6; }
+if test ${ac_cv_lib_soname_EGL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lEGL  $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9104,53 +10758,52 @@ LIBS="-lEGL  $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char eglGetProcAddress ();
 int
-main ()
+main (void)
 {
 return eglGetProcAddress ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_EGL=`$ac_cv_path_LDD conftest.exe | grep "EGL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_EGL=`$OTOOL -L conftest$ac_exeext | grep "libEGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libEGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_EGL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libEGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libEGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_EGL:+false} :; then :
+       if ${ac_cv_lib_soname_EGL:+false} :
+then :
   ac_cv_lib_soname_EGL=`$LDD conftest$ac_exeext | grep "libEGL\\.$LIBEXT" | sed -e "s/^.*\(libEGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_EGL=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_EGL:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_EGL" >&5
-$as_echo "$ac_cv_lib_soname_EGL" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_EGL" >&5
+printf "%s\n" "$ac_cv_lib_soname_EGL" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBEGL "$ac_cv_lib_soname_EGL"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBEGL \"$ac_cv_lib_soname_EGL\"" >>confdefs.h
 
 
 fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lGLESv2" >&5
-$as_echo_n "checking for -lGLESv2... " >&6; }
-if ${ac_cv_lib_soname_GLESv2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGLESv2" >&5
+printf %s "checking for -lGLESv2... " >&6; }
+if test ${ac_cv_lib_soname_GLESv2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lGLESv2  $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -9159,45 +10812,43 @@ LIBS="-lGLESv2  $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char glFlush ();
 int
-main ()
+main (void)
 {
 return glFlush ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_GLESv2=`$ac_cv_path_LDD conftest.exe | grep "GLESv2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_GLESv2=`$OTOOL -L conftest$ac_exeext | grep "libGLESv2\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGLESv2\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_GLESv2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGLESv2\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGLESv2\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_GLESv2:+false} :; then :
+       if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
   ac_cv_lib_soname_GLESv2=`$LDD conftest$ac_exeext | grep "libGLESv2\\.$LIBEXT" | sed -e "s/^.*\(libGLESv2\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_GLESv2=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_GLESv2:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GLESv2" >&5
-$as_echo "$ac_cv_lib_soname_GLESv2" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GLESv2" >&5
+printf "%s\n" "$ac_cv_lib_soname_GLESv2" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBGLESV2 "$ac_cv_lib_soname_GLESv2"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBGLESV2 \"$ac_cv_lib_soname_GLESv2\"" >>confdefs.h
 
 
 fi
@@ -9215,35 +10866,38 @@ fi
 
   *)
 
-$as_echo "#define _GNU_SOURCE 1" >>confdefs.h
+printf "%s\n" "#define _GNU_SOURCE 1" >>confdefs.h
 
     case $host_cpu in
       *i[3456789]86*)
         DLLFLAGS="$DLLFLAGS -fno-PIC"
         LDDLLFLAGS="-fno-PIC"
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-PIC -Wl,-z,notext" >&5
-$as_echo_n "checking whether the compiler supports -fno-PIC -Wl,-z,notext... " >&6; }
-if ${ac_cv_cflags__fno_PIC__Wl__z_notext+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-PIC -Wl,-z,notext" >&5
+printf %s "checking whether the compiler supports -fno-PIC -Wl,-z,notext... " >&6; }
+if test ${ac_cv_cflags__fno_PIC__Wl__z_notext+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fno-PIC -Wl,-z,notext"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fno_PIC__Wl__z_notext=yes
-else
+else $as_nop
   ac_cv_cflags__fno_PIC__Wl__z_notext=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_PIC__Wl__z_notext" >&5
-$as_echo "$ac_cv_cflags__fno_PIC__Wl__z_notext" >&6; }
-if test "x$ac_cv_cflags__fno_PIC__Wl__z_notext" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_PIC__Wl__z_notext" >&5
+printf "%s\n" "$ac_cv_cflags__fno_PIC__Wl__z_notext" >&6; }
+if test "x$ac_cv_cflags__fno_PIC__Wl__z_notext" = xyes
+then :
   LDDLLFLAGS="$LDDLLFLAGS -Wl,-z,notext"
 fi
         ;;
@@ -9254,138 +10908,153 @@ fi
     LIBWINE_LDFLAGS="-shared -Wl,-soname,libwine.so.$libwine_soversion"
 
     echo '{ global: *; };' >conftest.map
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -shared -Wl,--version-script=conftest.map" >&5
-$as_echo_n "checking whether the compiler supports -shared -Wl,--version-script=conftest.map... " >&6; }
-if ${ac_cv_cflags__shared__Wl___version_script_conftest_map+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -shared -Wl,--version-script=conftest.map" >&5
+printf %s "checking whether the compiler supports -shared -Wl,--version-script=conftest.map... " >&6; }
+if test ${ac_cv_cflags__shared__Wl___version_script_conftest_map+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -shared -Wl,--version-script=conftest.map"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__shared__Wl___version_script_conftest_map=yes
-else
+else $as_nop
   ac_cv_cflags__shared__Wl___version_script_conftest_map=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__shared__Wl___version_script_conftest_map" >&5
-$as_echo "$ac_cv_cflags__shared__Wl___version_script_conftest_map" >&6; }
-if test "x$ac_cv_cflags__shared__Wl___version_script_conftest_map" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__shared__Wl___version_script_conftest_map" >&5
+printf "%s\n" "$ac_cv_cflags__shared__Wl___version_script_conftest_map" >&6; }
+if test "x$ac_cv_cflags__shared__Wl___version_script_conftest_map" = xyes
+then :
   LIBWINE_LDFLAGS="$LIBWINE_LDFLAGS -Wl,--version-script=\$(srcdir)/wine.map"
 fi
     rm -f conftest.map
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-z,defs" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-z,defs... " >&6; }
-if ${ac_cv_cflags__Wl__z_defs+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-z,defs" >&5
+printf %s "checking whether the compiler supports -Wl,-z,defs... " >&6; }
+if test ${ac_cv_cflags__Wl__z_defs+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-z,defs"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__z_defs=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__z_defs=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_defs" >&5
-$as_echo "$ac_cv_cflags__Wl__z_defs" >&6; }
-if test "x$ac_cv_cflags__Wl__z_defs" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_defs" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__z_defs" >&6; }
+if test "x$ac_cv_cflags__Wl__z_defs" = xyes
+then :
   UNIXLDFLAGS="$UNIXLDFLAGS -Wl,-z,defs"
 fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--export-dynamic" >&5
-$as_echo_n "checking whether the compiler supports -Wl,--export-dynamic... " >&6; }
-if ${ac_cv_cflags__Wl___export_dynamic+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--export-dynamic" >&5
+printf %s "checking whether the compiler supports -Wl,--export-dynamic... " >&6; }
+if test ${ac_cv_cflags__Wl___export_dynamic+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,--export-dynamic"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl___export_dynamic=yes
-else
+else $as_nop
   ac_cv_cflags__Wl___export_dynamic=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___export_dynamic" >&5
-$as_echo "$ac_cv_cflags__Wl___export_dynamic" >&6; }
-if test "x$ac_cv_cflags__Wl___export_dynamic" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___export_dynamic" >&5
+printf "%s\n" "$ac_cv_cflags__Wl___export_dynamic" >&6; }
+if test "x$ac_cv_cflags__Wl___export_dynamic" = xyes
+then :
   WINELOADER_LDFLAGS="-Wl,--export-dynamic"
 fi
     WINEPRELOADER_LDFLAGS="-static -nostartfiles -nodefaultlibs -Wl,-Ttext=0x7d400000"
 
     case $host_cpu in
       *i[3456789]86* | x86_64 | *aarch64* | arm*)
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-Ttext-segment=0x7bc00000" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-Ttext-segment=0x7bc00000... " >&6; }
-if ${ac_cv_cflags__Wl__Ttext_segment_0x7bc00000+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-Ttext-segment=0x7bc00000" >&5
+printf %s "checking whether the compiler supports -Wl,-Ttext-segment=0x7bc00000... " >&6; }
+if test ${ac_cv_cflags__Wl__Ttext_segment_0x7bc00000+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-Ttext-segment=0x7bc00000"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__Ttext_segment_0x7bc00000=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__Ttext_segment_0x7bc00000=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" >&5
-$as_echo "$ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" >&6; }
-if test "x$ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" >&6; }
+if test "x$ac_cv_cflags__Wl__Ttext_segment_0x7bc00000" = xyes
+then :
   case $host_os in
                          freebsd* | kfreebsd*-gnu) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,-Ttext-segment=0x60000000" ;;
                          *) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,-Ttext-segment=0x7d000000" ;;
                          esac
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--section-start,.interp=0x7d000400" >&5
-$as_echo_n "checking whether the compiler supports -Wl,--section-start,.interp=0x7d000400... " >&6; }
-if ${ac_cv_cflags__Wl___section_start__interp_0x7d000400+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--section-start,.interp=0x7d000400" >&5
+printf %s "checking whether the compiler supports -Wl,--section-start,.interp=0x7d000400... " >&6; }
+if test ${ac_cv_cflags__Wl___section_start__interp_0x7d000400+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,--section-start,.interp=0x7d000400"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl___section_start__interp_0x7d000400=yes
-else
+else $as_nop
   ac_cv_cflags__Wl___section_start__interp_0x7d000400=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___section_start__interp_0x7d000400" >&5
-$as_echo "$ac_cv_cflags__Wl___section_start__interp_0x7d000400" >&6; }
-if test "x$ac_cv_cflags__Wl___section_start__interp_0x7d000400" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___section_start__interp_0x7d000400" >&5
+printf "%s\n" "$ac_cv_cflags__Wl___section_start__interp_0x7d000400" >&6; }
+if test "x$ac_cv_cflags__Wl___section_start__interp_0x7d000400" = xyes
+then :
   case $host_os in
                                             freebsd* | kfreebsd*-gnu) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,--section-start,.interp=0x60000400" ;;
                                             *) WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,--section-start,.interp=0x7d000400" ;;
@@ -9393,11 +11062,12 @@ if test "x$ac_cv_cflags__Wl___section_start__interp_0x7d000400" = xyes; then :
 fi
                          # Extract the first word of "prelink", so it can be a program name with args.
 set dummy prelink; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PRELINK+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_PRELINK+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   case $PRELINK in
   [\\/]* | ?:[\\/]*)
   ac_cv_path_PRELINK="$PRELINK" # Let the user override the test with a path.
@@ -9407,11 +11077,15 @@ else
 for as_dir in /sbin /usr/sbin $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_PRELINK="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_PRELINK="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -9424,11 +11098,11 @@ esac
 fi
 PRELINK=$ac_cv_path_PRELINK
 if test -n "$PRELINK"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PRELINK" >&5
-$as_echo "$PRELINK" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $PRELINK" >&5
+printf "%s\n" "$PRELINK" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -9437,29 +11111,32 @@ fi
                              as_fn_append wine_warnings "|prelink not found and linker does not support relocation, base address of core dlls won't be set correctly."
                          fi
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-z,max-page-size=0x1000" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-z,max-page-size=0x1000... " >&6; }
-if ${ac_cv_cflags__Wl__z_max_page_size_0x1000+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-z,max-page-size=0x1000" >&5
+printf %s "checking whether the compiler supports -Wl,-z,max-page-size=0x1000... " >&6; }
+if test ${ac_cv_cflags__Wl__z_max_page_size_0x1000+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-z,max-page-size=0x1000"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__z_max_page_size_0x1000=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__z_max_page_size_0x1000=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_max_page_size_0x1000" >&5
-$as_echo "$ac_cv_cflags__Wl__z_max_page_size_0x1000" >&6; }
-if test "x$ac_cv_cflags__Wl__z_max_page_size_0x1000" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_max_page_size_0x1000" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__z_max_page_size_0x1000" >&6; }
+if test "x$ac_cv_cflags__Wl__z_max_page_size_0x1000" = xyes
+then :
   WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,-z,max-page-size=0x1000"
 fi
         ;;
@@ -9501,11 +11178,12 @@ for ac_prog in $ac_prefix_list
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CROSSCC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CROSSCC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CROSSCC"; then
   ac_cv_prog_CROSSCC="$CROSSCC" # Let the user override the test.
 else
@@ -9513,11 +11191,15 @@ as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CROSSCC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
@@ -9528,11 +11210,11 @@ fi
 fi
 CROSSCC=$ac_cv_prog_CROSSCC
 if test -n "$CROSSCC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CROSSCC" >&5
-$as_echo "$CROSSCC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CROSSCC" >&5
+printf "%s\n" "$CROSSCC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
@@ -9556,31 +11238,33 @@ test -n "$CROSSCC" || CROSSCC="false"
         CC="$CROSSCC"
         CFLAGS=$CROSSCFLAGS
         LDFLAGS=$CROSSLDFLAGS
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CROSSCC works" >&5
-$as_echo_n "checking whether $CROSSCC works... " >&6; }
-if ${wine_cv_crosscc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CROSSCC works" >&5
+printf %s "checking whether $CROSSCC works... " >&6; }
+if test ${wine_cv_crosscc+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   wine_cv_crosscc=yes
-else
+else $as_nop
   wine_cv_crosscc=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_crosscc" >&5
-$as_echo "$wine_cv_crosscc" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_crosscc" >&5
+printf "%s\n" "$wine_cv_crosscc" >&6; }
         if test $wine_cv_crosscc = yes
         then
             set x $CROSSCC
@@ -9606,12 +11290,13 @@ $as_echo "$wine_cv_crosscc" >&6; }
             case $llvm_target in
             *windows) llvm_cflags="$llvm_cflags -Wl,-subsystem:console" ;;
             esac
-            as_ac_var=`$as_echo "ac_cv_crosscflags_-target $llvm_target $llvm_cflags" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -target $llvm_target $llvm_cflags" >&5
-$as_echo_n "checking whether the cross-compiler supports -target $llvm_target $llvm_cflags... " >&6; }
-if eval \${$as_ac_var+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            as_ac_var=`printf "%s\n" "ac_cv_crosscflags_-target $llvm_target $llvm_cflags" | $as_tr_sh`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -target $llvm_target $llvm_cflags" >&5
+printf %s "checking whether the cross-compiler supports -target $llvm_target $llvm_cflags... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9622,21 +11307,23 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   eval "$as_ac_var=yes"
-else
+else $as_nop
   eval "$as_ac_var=no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
 eval ac_res=\$$as_ac_var
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
   CROSSTARGET=$llvm_target
                                   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -target $CROSSTARGET"
                                   DELAYLOADFLAG="-Wl,-delayload,"
@@ -9644,11 +11331,12 @@ if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
                                   CFLAGS="$CFLAGS $llvm_cflags"
 fi
         fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -fno-strict-aliasing" >&5
-$as_echo_n "checking whether the cross-compiler supports -fno-strict-aliasing... " >&6; }
-if ${ac_cv_crosscflags__fno_strict_aliasing+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -fno-strict-aliasing" >&5
+printf %s "checking whether the cross-compiler supports -fno-strict-aliasing... " >&6; }
+if test ${ac_cv_crosscflags__fno_strict_aliasing+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9659,27 +11347,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__fno_strict_aliasing=yes
-else
+else $as_nop
   ac_cv_crosscflags__fno_strict_aliasing=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__fno_strict_aliasing" >&5
-$as_echo "$ac_cv_crosscflags__fno_strict_aliasing" >&6; }
-if test "x$ac_cv_crosscflags__fno_strict_aliasing" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__fno_strict_aliasing" >&5
+printf "%s\n" "$ac_cv_crosscflags__fno_strict_aliasing" >&6; }
+if test "x$ac_cv_crosscflags__fno_strict_aliasing" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -fno-strict-aliasing"
 fi
-                { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Werror=unknown-warning-option" >&5
-$as_echo_n "checking whether the cross-compiler supports -Werror=unknown-warning-option... " >&6; }
-if ${ac_cv_crosscflags__Werror_unknown_warning_option+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Werror=unknown-warning-option" >&5
+printf %s "checking whether the cross-compiler supports -Werror=unknown-warning-option... " >&6; }
+if test ${ac_cv_crosscflags__Werror_unknown_warning_option+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9690,27 +11381,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Werror_unknown_warning_option=yes
-else
+else $as_nop
   ac_cv_crosscflags__Werror_unknown_warning_option=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Werror_unknown_warning_option" >&5
-$as_echo "$ac_cv_crosscflags__Werror_unknown_warning_option" >&6; }
-if test "x$ac_cv_crosscflags__Werror_unknown_warning_option" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Werror_unknown_warning_option" >&5
+printf "%s\n" "$ac_cv_crosscflags__Werror_unknown_warning_option" >&6; }
+if test "x$ac_cv_crosscflags__Werror_unknown_warning_option" = xyes
+then :
   CFLAGS="$CFLAGS -Werror=unknown-warning-option"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Werror=ignored-optimization-argument" >&5
-$as_echo_n "checking whether the cross-compiler supports -Werror=ignored-optimization-argument... " >&6; }
-if ${ac_cv_crosscflags__Werror_ignored_optimization_argument+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Werror=ignored-optimization-argument" >&5
+printf %s "checking whether the cross-compiler supports -Werror=ignored-optimization-argument... " >&6; }
+if test ${ac_cv_crosscflags__Werror_ignored_optimization_argument+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9721,27 +11415,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Werror_ignored_optimization_argument=yes
-else
+else $as_nop
   ac_cv_crosscflags__Werror_ignored_optimization_argument=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Werror_ignored_optimization_argument" >&5
-$as_echo "$ac_cv_crosscflags__Werror_ignored_optimization_argument" >&6; }
-if test "x$ac_cv_crosscflags__Werror_ignored_optimization_argument" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Werror_ignored_optimization_argument" >&5
+printf "%s\n" "$ac_cv_crosscflags__Werror_ignored_optimization_argument" >&6; }
+if test "x$ac_cv_crosscflags__Werror_ignored_optimization_argument" = xyes
+then :
   CFLAGS="$CFLAGS -Werror=ignored-optimization-argument"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wdeclaration-after-statement" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wdeclaration-after-statement... " >&6; }
-if ${ac_cv_crosscflags__Wdeclaration_after_statement+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wdeclaration-after-statement" >&5
+printf %s "checking whether the cross-compiler supports -Wdeclaration-after-statement... " >&6; }
+if test ${ac_cv_crosscflags__Wdeclaration_after_statement+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9752,27 +11449,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wdeclaration_after_statement=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wdeclaration_after_statement=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wdeclaration_after_statement" >&5
-$as_echo "$ac_cv_crosscflags__Wdeclaration_after_statement" >&6; }
-if test "x$ac_cv_crosscflags__Wdeclaration_after_statement" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wdeclaration_after_statement" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wdeclaration_after_statement" >&6; }
+if test "x$ac_cv_crosscflags__Wdeclaration_after_statement" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wdeclaration-after-statement"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wempty-body" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wempty-body... " >&6; }
-if ${ac_cv_crosscflags__Wempty_body+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wempty-body" >&5
+printf %s "checking whether the cross-compiler supports -Wempty-body... " >&6; }
+if test ${ac_cv_crosscflags__Wempty_body+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9783,27 +11483,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wempty_body=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wempty_body=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wempty_body" >&5
-$as_echo "$ac_cv_crosscflags__Wempty_body" >&6; }
-if test "x$ac_cv_crosscflags__Wempty_body" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wempty_body" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wempty_body" >&6; }
+if test "x$ac_cv_crosscflags__Wempty_body" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wempty-body"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wignored-qualifiers" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wignored-qualifiers... " >&6; }
-if ${ac_cv_crosscflags__Wignored_qualifiers+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wignored-qualifiers" >&5
+printf %s "checking whether the cross-compiler supports -Wignored-qualifiers... " >&6; }
+if test ${ac_cv_crosscflags__Wignored_qualifiers+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9814,27 +11517,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wignored_qualifiers=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wignored_qualifiers=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wignored_qualifiers" >&5
-$as_echo "$ac_cv_crosscflags__Wignored_qualifiers" >&6; }
-if test "x$ac_cv_crosscflags__Wignored_qualifiers" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wignored_qualifiers" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wignored_qualifiers" >&6; }
+if test "x$ac_cv_crosscflags__Wignored_qualifiers" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wignored-qualifiers"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Winit-self" >&5
-$as_echo_n "checking whether the cross-compiler supports -Winit-self... " >&6; }
-if ${ac_cv_crosscflags__Winit_self+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Winit-self" >&5
+printf %s "checking whether the cross-compiler supports -Winit-self... " >&6; }
+if test ${ac_cv_crosscflags__Winit_self+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9845,27 +11551,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Winit_self=yes
-else
+else $as_nop
   ac_cv_crosscflags__Winit_self=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Winit_self" >&5
-$as_echo "$ac_cv_crosscflags__Winit_self" >&6; }
-if test "x$ac_cv_crosscflags__Winit_self" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Winit_self" >&5
+printf "%s\n" "$ac_cv_crosscflags__Winit_self" >&6; }
+if test "x$ac_cv_crosscflags__Winit_self" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Winit-self"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wpacked-not-aligned" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wpacked-not-aligned... " >&6; }
-if ${ac_cv_crosscflags__Wpacked_not_aligned+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wpacked-not-aligned" >&5
+printf %s "checking whether the cross-compiler supports -Wpacked-not-aligned... " >&6; }
+if test ${ac_cv_crosscflags__Wpacked_not_aligned+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9876,27 +11585,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wpacked_not_aligned=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wpacked_not_aligned=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wpacked_not_aligned" >&5
-$as_echo "$ac_cv_crosscflags__Wpacked_not_aligned" >&6; }
-if test "x$ac_cv_crosscflags__Wpacked_not_aligned" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wpacked_not_aligned" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wpacked_not_aligned" >&6; }
+if test "x$ac_cv_crosscflags__Wpacked_not_aligned" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wno-packed-not-aligned"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wpragma-pack" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wpragma-pack... " >&6; }
-if ${ac_cv_crosscflags__Wpragma_pack+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wpragma-pack" >&5
+printf %s "checking whether the cross-compiler supports -Wpragma-pack... " >&6; }
+if test ${ac_cv_crosscflags__Wpragma_pack+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9907,27 +11619,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wpragma_pack=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wpragma_pack=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wpragma_pack" >&5
-$as_echo "$ac_cv_crosscflags__Wpragma_pack" >&6; }
-if test "x$ac_cv_crosscflags__Wpragma_pack" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wpragma_pack" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wpragma_pack" >&6; }
+if test "x$ac_cv_crosscflags__Wpragma_pack" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wno-pragma-pack"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wshift-overflow=2" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wshift-overflow=2... " >&6; }
-if ${ac_cv_crosscflags__Wshift_overflow_2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wshift-overflow=2" >&5
+printf %s "checking whether the cross-compiler supports -Wshift-overflow=2... " >&6; }
+if test ${ac_cv_crosscflags__Wshift_overflow_2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9938,27 +11653,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wshift_overflow_2=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wshift_overflow_2=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wshift_overflow_2" >&5
-$as_echo "$ac_cv_crosscflags__Wshift_overflow_2" >&6; }
-if test "x$ac_cv_crosscflags__Wshift_overflow_2" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wshift_overflow_2" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wshift_overflow_2" >&6; }
+if test "x$ac_cv_crosscflags__Wshift_overflow_2" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wshift-overflow=2"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wstrict-prototypes" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wstrict-prototypes... " >&6; }
-if ${ac_cv_crosscflags__Wstrict_prototypes+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wstrict-prototypes" >&5
+printf %s "checking whether the cross-compiler supports -Wstrict-prototypes... " >&6; }
+if test ${ac_cv_crosscflags__Wstrict_prototypes+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -9969,27 +11687,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wstrict_prototypes=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wstrict_prototypes=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wstrict_prototypes" >&5
-$as_echo "$ac_cv_crosscflags__Wstrict_prototypes" >&6; }
-if test "x$ac_cv_crosscflags__Wstrict_prototypes" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wstrict_prototypes" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wstrict_prototypes" >&6; }
+if test "x$ac_cv_crosscflags__Wstrict_prototypes" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wstrict-prototypes"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wtype-limits" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wtype-limits... " >&6; }
-if ${ac_cv_crosscflags__Wtype_limits+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wtype-limits" >&5
+printf %s "checking whether the cross-compiler supports -Wtype-limits... " >&6; }
+if test ${ac_cv_crosscflags__Wtype_limits+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10000,27 +11721,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wtype_limits=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wtype_limits=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wtype_limits" >&5
-$as_echo "$ac_cv_crosscflags__Wtype_limits" >&6; }
-if test "x$ac_cv_crosscflags__Wtype_limits" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wtype_limits" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wtype_limits" >&6; }
+if test "x$ac_cv_crosscflags__Wtype_limits" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wtype-limits"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wunused-but-set-parameter" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wunused-but-set-parameter... " >&6; }
-if ${ac_cv_crosscflags__Wunused_but_set_parameter+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wunused-but-set-parameter" >&5
+printf %s "checking whether the cross-compiler supports -Wunused-but-set-parameter... " >&6; }
+if test ${ac_cv_crosscflags__Wunused_but_set_parameter+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10031,27 +11755,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wunused_but_set_parameter=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wunused_but_set_parameter=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wunused_but_set_parameter" >&5
-$as_echo "$ac_cv_crosscflags__Wunused_but_set_parameter" >&6; }
-if test "x$ac_cv_crosscflags__Wunused_but_set_parameter" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wunused_but_set_parameter" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wunused_but_set_parameter" >&6; }
+if test "x$ac_cv_crosscflags__Wunused_but_set_parameter" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wunused-but-set-parameter"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wvla" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wvla... " >&6; }
-if ${ac_cv_crosscflags__Wvla+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wvla" >&5
+printf %s "checking whether the cross-compiler supports -Wvla... " >&6; }
+if test ${ac_cv_crosscflags__Wvla+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10062,27 +11789,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wvla=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wvla=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wvla" >&5
-$as_echo "$ac_cv_crosscflags__Wvla" >&6; }
-if test "x$ac_cv_crosscflags__Wvla" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wvla" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wvla" >&6; }
+if test "x$ac_cv_crosscflags__Wvla" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wvla"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wwrite-strings" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wwrite-strings... " >&6; }
-if ${ac_cv_crosscflags__Wwrite_strings+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wwrite-strings" >&5
+printf %s "checking whether the cross-compiler supports -Wwrite-strings... " >&6; }
+if test ${ac_cv_crosscflags__Wwrite_strings+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10093,27 +11823,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wwrite_strings=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wwrite_strings=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wwrite_strings" >&5
-$as_echo "$ac_cv_crosscflags__Wwrite_strings" >&6; }
-if test "x$ac_cv_crosscflags__Wwrite_strings" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wwrite_strings" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wwrite_strings" >&6; }
+if test "x$ac_cv_crosscflags__Wwrite_strings" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wwrite-strings"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wpointer-arith" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wpointer-arith... " >&6; }
-if ${ac_cv_crosscflags__Wpointer_arith+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wpointer-arith" >&5
+printf %s "checking whether the cross-compiler supports -Wpointer-arith... " >&6; }
+if test ${ac_cv_crosscflags__Wpointer_arith+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10124,27 +11857,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wpointer_arith=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wpointer_arith=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wpointer_arith" >&5
-$as_echo "$ac_cv_crosscflags__Wpointer_arith" >&6; }
-if test "x$ac_cv_crosscflags__Wpointer_arith" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wpointer_arith" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wpointer_arith" >&6; }
+if test "x$ac_cv_crosscflags__Wpointer_arith" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wpointer-arith"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wlogical-op" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wlogical-op... " >&6; }
-if ${ac_cv_crosscflags__Wlogical_op+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wlogical-op" >&5
+printf %s "checking whether the cross-compiler supports -Wlogical-op... " >&6; }
+if test ${ac_cv_crosscflags__Wlogical_op+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10155,27 +11891,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wlogical_op=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wlogical_op=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wlogical_op" >&5
-$as_echo "$ac_cv_crosscflags__Wlogical_op" >&6; }
-if test "x$ac_cv_crosscflags__Wlogical_op" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wlogical_op" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wlogical_op" >&6; }
+if test "x$ac_cv_crosscflags__Wlogical_op" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wlogical-op"
 fi
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wabsolute-value" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wabsolute-value... " >&6; }
-if ${ac_cv_crosscflags__Wabsolute_value+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wabsolute-value" >&5
+printf %s "checking whether the cross-compiler supports -Wabsolute-value... " >&6; }
+if test ${ac_cv_crosscflags__Wabsolute_value+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10186,29 +11925,32 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wabsolute_value=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wabsolute_value=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wabsolute_value" >&5
-$as_echo "$ac_cv_crosscflags__Wabsolute_value" >&6; }
-if test "x$ac_cv_crosscflags__Wabsolute_value" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wabsolute_value" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wabsolute_value" >&6; }
+if test "x$ac_cv_crosscflags__Wabsolute_value" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wabsolute-value"
 fi
 
         case $host_cpu in
-          *i[3456789]86*) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -fno-omit-frame-pointer" >&5
-$as_echo_n "checking whether the cross-compiler supports -fno-omit-frame-pointer... " >&6; }
-if ${ac_cv_crosscflags__fno_omit_frame_pointer+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+          *i[3456789]86*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -fno-omit-frame-pointer" >&5
+printf %s "checking whether the cross-compiler supports -fno-omit-frame-pointer... " >&6; }
+if test ${ac_cv_crosscflags__fno_omit_frame_pointer+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10219,27 +11961,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__fno_omit_frame_pointer=yes
-else
+else $as_nop
   ac_cv_crosscflags__fno_omit_frame_pointer=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__fno_omit_frame_pointer" >&5
-$as_echo "$ac_cv_crosscflags__fno_omit_frame_pointer" >&6; }
-if test "x$ac_cv_crosscflags__fno_omit_frame_pointer" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__fno_omit_frame_pointer" >&5
+printf "%s\n" "$ac_cv_crosscflags__fno_omit_frame_pointer" >&6; }
+if test "x$ac_cv_crosscflags__fno_omit_frame_pointer" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -fno-omit-frame-pointer"
 fi ;;
-          x86_64) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wno-format" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wno-format... " >&6; }
-if ${ac_cv_crosscflags__Wno_format+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+          x86_64) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wno-format" >&5
+printf %s "checking whether the cross-compiler supports -Wno-format... " >&6; }
+if test ${ac_cv_crosscflags__Wno_format+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10250,27 +11995,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wno_format=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wno_format=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wno_format" >&5
-$as_echo "$ac_cv_crosscflags__Wno_format" >&6; }
-if test "x$ac_cv_crosscflags__Wno_format" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wno_format" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wno_format" >&6; }
+if test "x$ac_cv_crosscflags__Wno_format" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wno-format"
 fi
-                  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wformat-overflow" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wformat-overflow... " >&6; }
-if ${ac_cv_crosscflags__Wformat_overflow+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wformat-overflow" >&5
+printf %s "checking whether the cross-compiler supports -Wformat-overflow... " >&6; }
+if test ${ac_cv_crosscflags__Wformat_overflow+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10281,27 +12029,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wformat_overflow=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wformat_overflow=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wformat_overflow" >&5
-$as_echo "$ac_cv_crosscflags__Wformat_overflow" >&6; }
-if test "x$ac_cv_crosscflags__Wformat_overflow" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wformat_overflow" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wformat_overflow" >&6; }
+if test "x$ac_cv_crosscflags__Wformat_overflow" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wformat-overflow"
 fi
-                  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wnonnull" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wnonnull... " >&6; }
-if ${ac_cv_crosscflags__Wnonnull+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wnonnull" >&5
+printf %s "checking whether the cross-compiler supports -Wnonnull... " >&6; }
+if test ${ac_cv_crosscflags__Wnonnull+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10312,27 +12063,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wnonnull=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wnonnull=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wnonnull" >&5
-$as_echo "$ac_cv_crosscflags__Wnonnull" >&6; }
-if test "x$ac_cv_crosscflags__Wnonnull" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wnonnull" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wnonnull" >&6; }
+if test "x$ac_cv_crosscflags__Wnonnull" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wnonnull"
 fi
-                  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -mcx16" >&5
-$as_echo_n "checking whether the cross-compiler supports -mcx16... " >&6; }
-if ${ac_cv_crosscflags__mcx16+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -mcx16" >&5
+printf %s "checking whether the cross-compiler supports -mcx16... " >&6; }
+if test ${ac_cv_crosscflags__mcx16+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10343,27 +12097,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__mcx16=yes
-else
+else $as_nop
   ac_cv_crosscflags__mcx16=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__mcx16" >&5
-$as_echo "$ac_cv_crosscflags__mcx16" >&6; }
-if test "x$ac_cv_crosscflags__mcx16" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__mcx16" >&5
+printf "%s\n" "$ac_cv_crosscflags__mcx16" >&6; }
+if test "x$ac_cv_crosscflags__mcx16" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -mcx16"
 fi ;;
-          aarch64) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wno-format" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wno-format... " >&6; }
-if ${ac_cv_crosscflags__Wno_format+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+          aarch64) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wno-format" >&5
+printf %s "checking whether the cross-compiler supports -Wno-format... " >&6; }
+if test ${ac_cv_crosscflags__Wno_format+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10374,20 +12131,22 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wno_format=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wno_format=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wno_format" >&5
-$as_echo "$ac_cv_crosscflags__Wno_format" >&6; }
-if test "x$ac_cv_crosscflags__Wno_format" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wno_format" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wno_format" >&6; }
+if test "x$ac_cv_crosscflags__Wno_format" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Wno-format"
 fi ;;
         esac
@@ -10413,11 +12172,12 @@ fi ;;
         if test "x$ac_debug_format_seen" = x
         then
           case $CROSSDEBUG in
-            *dwarf)  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -gdwarf-2" >&5
-$as_echo_n "checking whether the cross-compiler supports -gdwarf-2... " >&6; }
-if ${ac_cv_crosscflags__gdwarf_2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            *dwarf)  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -gdwarf-2" >&5
+printf %s "checking whether the cross-compiler supports -gdwarf-2... " >&6; }
+if test ${ac_cv_crosscflags__gdwarf_2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10428,27 +12188,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__gdwarf_2=yes
-else
+else $as_nop
   ac_cv_crosscflags__gdwarf_2=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__gdwarf_2" >&5
-$as_echo "$ac_cv_crosscflags__gdwarf_2" >&6; }
-if test "x$ac_cv_crosscflags__gdwarf_2" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__gdwarf_2" >&5
+printf "%s\n" "$ac_cv_crosscflags__gdwarf_2" >&6; }
+if test "x$ac_cv_crosscflags__gdwarf_2" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -gdwarf-2"
 fi
-                     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -gstrict-dwarf" >&5
-$as_echo_n "checking whether the cross-compiler supports -gstrict-dwarf... " >&6; }
-if ${ac_cv_crosscflags__gstrict_dwarf+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                     { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -gstrict-dwarf" >&5
+printf %s "checking whether the cross-compiler supports -gstrict-dwarf... " >&6; }
+if test ${ac_cv_crosscflags__gstrict_dwarf+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10459,27 +12222,30 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__gstrict_dwarf=yes
-else
+else $as_nop
   ac_cv_crosscflags__gstrict_dwarf=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__gstrict_dwarf" >&5
-$as_echo "$ac_cv_crosscflags__gstrict_dwarf" >&6; }
-if test "x$ac_cv_crosscflags__gstrict_dwarf" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__gstrict_dwarf" >&5
+printf "%s\n" "$ac_cv_crosscflags__gstrict_dwarf" >&6; }
+if test "x$ac_cv_crosscflags__gstrict_dwarf" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -gstrict-dwarf"
 fi ;;
-            pdb)     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -gcodeview" >&5
-$as_echo_n "checking whether the cross-compiler supports -gcodeview... " >&6; }
-if ${ac_cv_crosscflags__gcodeview+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            pdb)     { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -gcodeview" >&5
+printf %s "checking whether the cross-compiler supports -gcodeview... " >&6; }
+if test ${ac_cv_crosscflags__gcodeview+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10490,30 +12256,33 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__gcodeview=yes
-else
+else $as_nop
   ac_cv_crosscflags__gcodeview=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__gcodeview" >&5
-$as_echo "$ac_cv_crosscflags__gcodeview" >&6; }
-if test "x$ac_cv_crosscflags__gcodeview" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__gcodeview" >&5
+printf "%s\n" "$ac_cv_crosscflags__gcodeview" >&6; }
+if test "x$ac_cv_crosscflags__gcodeview" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -gcodeview"
 fi ;;
           esac
         fi
 
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -fexcess-precision=standard" >&5
-$as_echo_n "checking whether the cross-compiler supports -fexcess-precision=standard... " >&6; }
-if ${ac_cv_crosscflags__fexcess_precision_standard+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -fexcess-precision=standard" >&5
+printf %s "checking whether the cross-compiler supports -fexcess-precision=standard... " >&6; }
+if test ${ac_cv_crosscflags__fexcess_precision_standard+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10524,31 +12293,34 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__fexcess_precision_standard=yes
-else
+else $as_nop
   ac_cv_crosscflags__fexcess_precision_standard=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__fexcess_precision_standard" >&5
-$as_echo "$ac_cv_crosscflags__fexcess_precision_standard" >&6; }
-if test "x$ac_cv_crosscflags__fexcess_precision_standard" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__fexcess_precision_standard" >&5
+printf "%s\n" "$ac_cv_crosscflags__fexcess_precision_standard" >&6; }
+if test "x$ac_cv_crosscflags__fexcess_precision_standard" = xyes
+then :
   EXCESS_PRECISION_CFLAGS="-fexcess-precision=standard"
 
 fi
 
         if test "x$enable_werror" = "xyes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Werror" >&5
-$as_echo_n "checking whether the cross-compiler supports -Werror... " >&6; }
-if ${ac_cv_crosscflags__Werror+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Werror" >&5
+printf %s "checking whether the cross-compiler supports -Werror... " >&6; }
+if test ${ac_cv_crosscflags__Werror+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10559,30 +12331,33 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Werror=yes
-else
+else $as_nop
   ac_cv_crosscflags__Werror=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Werror" >&5
-$as_echo "$ac_cv_crosscflags__Werror" >&6; }
-if test "x$ac_cv_crosscflags__Werror" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Werror" >&5
+printf "%s\n" "$ac_cv_crosscflags__Werror" >&6; }
+if test "x$ac_cv_crosscflags__Werror" = xyes
+then :
   EXTRACROSSCFLAGS="$EXTRACROSSCFLAGS -Werror"
 fi
         fi
         if test "x$enable_build_id" = "xyes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wl,--build-id" >&5
-$as_echo_n "checking whether the cross-compiler supports -Wl,--build-id... " >&6; }
-if ${ac_cv_crosscflags__Wl___build_id+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the cross-compiler supports -Wl,--build-id" >&5
+printf %s "checking whether the cross-compiler supports -Wl,--build-id... " >&6; }
+if test ${ac_cv_crosscflags__Wl___build_id+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 ac_wine_try_cflags_saved_cc=$CC
 ac_wine_try_cflags_saved_exeext=$ac_exeext
@@ -10593,20 +12368,22 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int __cdecl mainCRTStartup(void) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_crosscflags__Wl___build_id=yes
-else
+else $as_nop
   ac_cv_crosscflags__Wl___build_id=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 CC=$ac_wine_try_cflags_saved_cc
 ac_exeext=$ac_wine_try_cflags_saved_exeext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wl___build_id" >&5
-$as_echo "$ac_cv_crosscflags__Wl___build_id" >&6; }
-if test "x$ac_cv_crosscflags__Wl___build_id" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_crosscflags__Wl___build_id" >&5
+printf "%s\n" "$ac_cv_crosscflags__Wl___build_id" >&6; }
+if test "x$ac_cv_crosscflags__Wl___build_id" = xyes
+then :
   CROSSCFLAGS="$CROSSCFLAGS -Wl,--build-id"
                             CROSSLDFLAGS="$CROSSLDFLAGS -Wl,--build-id"
 fi
@@ -10617,7 +12394,8 @@ fi
         CC="$ac_save_CC"
     fi
 fi
-if test "x$CROSSTARGET" = "x"; then :
+if test "x$CROSSTARGET" = "x"
+then :
   case "x$with_mingw" in
   x)   as_fn_append wine_notices "|MinGW compiler not found, cross-compiling PE files won't be supported." ;;
   xno) ;;
@@ -10628,162 +12406,186 @@ esac
 fi
 
 
-if ${FAUDIO_PE_CFLAGS:+false} :; then :
+if ${FAUDIO_PE_CFLAGS:+false} :
+then :
   FAUDIO_PE_CFLAGS="-I\$(top_srcdir)/libs/faudio/include"
-else
+else $as_nop
   enable_faudio=no
 fi
-if ${FAUDIO_PE_LIBS:+false} :; then :
+if ${FAUDIO_PE_LIBS:+false} :
+then :
   FAUDIO_PE_LIBS="faudio mfplat mfreadwrite mfuuid propsys"
-else
+else $as_nop
   enable_faudio=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: faudio cflags: $FAUDIO_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: faudio libs: $FAUDIO_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: faudio cflags: $FAUDIO_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: faudio libs: $FAUDIO_PE_LIBS" >&5
 
-if ${GSM_PE_CFLAGS:+false} :; then :
+if ${GSM_PE_CFLAGS:+false} :
+then :
   GSM_PE_CFLAGS="-I\$(top_srcdir)/libs/gsm/inc"
-else
+else $as_nop
   enable_gsm=no
 fi
-if ${GSM_PE_LIBS:+false} :; then :
+if ${GSM_PE_LIBS:+false} :
+then :
   GSM_PE_LIBS=gsm
-else
+else $as_nop
   enable_gsm=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: gsm cflags: $GSM_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: gsm libs: $GSM_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gsm cflags: $GSM_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gsm libs: $GSM_PE_LIBS" >&5
 
-if ${JPEG_PE_CFLAGS:+false} :; then :
+if ${JPEG_PE_CFLAGS:+false} :
+then :
   JPEG_PE_CFLAGS="-I\$(top_srcdir)/libs/jpeg"
-else
+else $as_nop
   enable_jpeg=no
 fi
-if ${JPEG_PE_LIBS:+false} :; then :
+if ${JPEG_PE_LIBS:+false} :
+then :
   JPEG_PE_LIBS=jpeg
-else
+else $as_nop
   enable_jpeg=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: jpeg cflags: $JPEG_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: jpeg libs: $JPEG_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jpeg cflags: $JPEG_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jpeg libs: $JPEG_PE_LIBS" >&5
 
-if ${JXR_PE_CFLAGS:+false} :; then :
+if ${JXR_PE_CFLAGS:+false} :
+then :
   JXR_PE_CFLAGS="-I\$(top_srcdir)/libs/jxr/jxrgluelib -I\$(top_srcdir)/libs/jxr/image/sys"
-else
+else $as_nop
   enable_jxr=no
 fi
-if ${JXR_PE_LIBS:+false} :; then :
+if ${JXR_PE_LIBS:+false} :
+then :
   JXR_PE_LIBS=jxr
-else
+else $as_nop
   enable_jxr=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: jxr cflags: $JXR_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: jxr libs: $JXR_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jxr cflags: $JXR_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jxr libs: $JXR_PE_LIBS" >&5
 
-if ${LCMS2_PE_CFLAGS:+false} :; then :
+if ${LCMS2_PE_CFLAGS:+false} :
+then :
   LCMS2_PE_CFLAGS="-I\$(top_srcdir)/libs/lcms2/include"
-else
+else $as_nop
   enable_lcms2=no
 fi
-if ${LCMS2_PE_LIBS:+false} :; then :
+if ${LCMS2_PE_LIBS:+false} :
+then :
   LCMS2_PE_LIBS=lcms2
-else
+else $as_nop
   enable_lcms2=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: lcms2 cflags: $LCMS2_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: lcms2 libs: $LCMS2_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: lcms2 cflags: $LCMS2_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: lcms2 libs: $LCMS2_PE_LIBS" >&5
 
-if ${MPG123_PE_CFLAGS:+false} :; then :
+if ${MPG123_PE_CFLAGS:+false} :
+then :
   MPG123_PE_CFLAGS="-I\$(top_srcdir)/libs/mpg123/src/libmpg123"
-else
+else $as_nop
   enable_mpg123=no
 fi
-if ${MPG123_PE_LIBS:+false} :; then :
+if ${MPG123_PE_LIBS:+false} :
+then :
   MPG123_PE_LIBS=mpg123
-else
+else $as_nop
   enable_mpg123=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: mpg123 cflags: $MPG123_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: mpg123 libs: $MPG123_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: mpg123 cflags: $MPG123_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: mpg123 libs: $MPG123_PE_LIBS" >&5
 
-if ${PNG_PE_CFLAGS:+false} :; then :
+if ${PNG_PE_CFLAGS:+false} :
+then :
   PNG_PE_CFLAGS="-I\$(top_srcdir)/libs/png"
-else
+else $as_nop
   enable_png=no
 fi
-if ${PNG_PE_LIBS:+false} :; then :
+if ${PNG_PE_LIBS:+false} :
+then :
   PNG_PE_LIBS="png \$(ZLIB_PE_LIBS)"
-else
+else $as_nop
   enable_png=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: png cflags: $PNG_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: png libs: $PNG_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: png cflags: $PNG_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: png libs: $PNG_PE_LIBS" >&5
 
-if ${TIFF_PE_CFLAGS:+false} :; then :
+if ${TIFF_PE_CFLAGS:+false} :
+then :
   TIFF_PE_CFLAGS="-I\$(top_srcdir)/libs/tiff/libtiff"
-else
+else $as_nop
   enable_tiff=no
 fi
-if ${TIFF_PE_LIBS:+false} :; then :
+if ${TIFF_PE_LIBS:+false} :
+then :
   TIFF_PE_LIBS=tiff
-else
+else $as_nop
   enable_tiff=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: tiff cflags: $TIFF_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: tiff libs: $TIFF_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: tiff cflags: $TIFF_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: tiff libs: $TIFF_PE_LIBS" >&5
 
-if ${XML2_PE_CFLAGS:+false} :; then :
+if ${XML2_PE_CFLAGS:+false} :
+then :
   XML2_PE_CFLAGS="-I\$(top_srcdir)/libs/xml2/include -DLIBXML_STATIC"
-else
+else $as_nop
   enable_libxml2=no
 fi
-if ${XML2_PE_LIBS:+false} :; then :
+if ${XML2_PE_LIBS:+false} :
+then :
   XML2_PE_LIBS=xml2
-else
+else $as_nop
   enable_libxml2=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: libxml2 cflags: $XML2_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libxml2 libs: $XML2_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libxml2 cflags: $XML2_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libxml2 libs: $XML2_PE_LIBS" >&5
 
-if ${XSLT_PE_CFLAGS:+false} :; then :
+if ${XSLT_PE_CFLAGS:+false} :
+then :
   XSLT_PE_CFLAGS="-I\$(top_srcdir)/libs/xslt -DLIBXSLT_STATIC"
-else
+else $as_nop
   enable_libxslt=no
 fi
-if ${XSLT_PE_LIBS:+false} :; then :
+if ${XSLT_PE_LIBS:+false} :
+then :
   XSLT_PE_LIBS=xslt
-else
+else $as_nop
   enable_libxslt=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: libxslt cflags: $XSLT_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libxslt libs: $XSLT_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libxslt cflags: $XSLT_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libxslt libs: $XSLT_PE_LIBS" >&5
 
-if ${ZLIB_PE_CFLAGS:+false} :; then :
+if ${ZLIB_PE_CFLAGS:+false} :
+then :
   ZLIB_PE_CFLAGS="-I\$(top_srcdir)/libs/zlib -DFAR= -DZ_SOLO"
-else
+else $as_nop
   enable_zlib=no
 fi
-if ${ZLIB_PE_LIBS:+false} :; then :
+if ${ZLIB_PE_LIBS:+false} :
+then :
   ZLIB_PE_LIBS=z
-else
+else $as_nop
   enable_zlib=no
 fi
-$as_echo "$as_me:${as_lineno-$LINENO}: zlib cflags: $ZLIB_PE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: zlib libs: $ZLIB_PE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: zlib cflags: $ZLIB_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: zlib libs: $ZLIB_PE_LIBS" >&5
 
 
 
 if test "$ac_cv_header_pthread_h" = "yes"
 then
     ac_fn_c_check_func "$LINENO" "pthread_create" "ac_cv_func_pthread_create"
-if test "x$ac_cv_func_pthread_create" = xyes; then :
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_create in -lpthread" >&5
-$as_echo_n "checking for pthread_create in -lpthread... " >&6; }
-if ${ac_cv_lib_pthread_pthread_create+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if test "x$ac_cv_func_pthread_create" = xyes
+then :
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pthread_create in -lpthread" >&5
+printf %s "checking for pthread_create in -lpthread... " >&6; }
+if test ${ac_cv_lib_pthread_pthread_create+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lpthread  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -10792,54 +12594,188 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char pthread_create ();
 int
-main ()
+main (void)
 {
 return pthread_create ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_pthread_pthread_create=yes
-else
+else $as_nop
   ac_cv_lib_pthread_pthread_create=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_pthread_create" >&5
-$as_echo "$ac_cv_lib_pthread_pthread_create" >&6; }
-if test "x$ac_cv_lib_pthread_pthread_create" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_pthread_create" >&5
+printf "%s\n" "$ac_cv_lib_pthread_pthread_create" >&6; }
+if test "x$ac_cv_lib_pthread_pthread_create" = xyes
+then :
   PTHREAD_LIBS="-lpthread"
 
 fi
 
-fi
+fi
+
+fi
+if test "x$ac_cv_func_pthread_create" != xyes -a "x$PTHREAD_LIBS" = x
+then :
+  case "x$with_pthread" in
+  xno) ;;
+  *)   as_fn_error $? "pthread ${notice_platform}development files not found.
+Wine cannot support threads without libpthread.
+Use the --without-pthread option if you really want this." "$LINENO" 5 ;;
+esac
+
+fi
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+printf %s "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test ${ac_cv_prog_CPP+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+      # Double quotes because $CC needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" cpp /lib/cpp
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <limits.h>
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+
+else $as_nop
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+  # Broken: success on invalid input.
+continue
+else $as_nop
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok
+then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+printf "%s\n" "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <limits.h>
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+
+else $as_nop
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+  # Broken: success on invalid input.
+continue
+else $as_nop
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok
+then :
 
+else $as_nop
+  { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5; }
 fi
-if test "x$ac_cv_func_pthread_create" != xyes -a "x$PTHREAD_LIBS" = x; then :
-  case "x$with_pthread" in
-  xno) ;;
-  *)   as_fn_error $? "pthread ${notice_platform}development files not found.
-Wine cannot support threads without libpthread.
-Use the --without-pthread option if you really want this." "$LINENO" 5 ;;
-esac
 
-fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
-$as_echo_n "checking for X... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for X" >&5
+printf %s "checking for X... " >&6; }
 
 
 # Check whether --with-x was given.
-if test "${with_x+set}" = set; then :
+if test ${with_x+y}
+then :
   withval=$with_x;
 fi
 
@@ -10850,12 +12786,41 @@ if test "x$with_x" = xno; then
 else
   case $x_includes,$x_libraries in #(
     *\'*) as_fn_error $? "cannot use X directory names containing '" "$LINENO" 5;; #(
-    *,NONE | NONE,*) if ${ac_cv_have_x+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    *,NONE | NONE,*) if test ${ac_cv_have_x+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   # One or both of the vars are not set, and there is no cached value.
-ac_x_includes=no ac_x_libraries=no
-rm -f -r conftest.dir
+ac_x_includes=no
+ac_x_libraries=no
+# Do we need to do anything special at all?
+ac_save_LIBS=$LIBS
+LIBS="-lX11 $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main (void)
+{
+XrmInitialize ()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  # We can compile and link X programs with no special options.
+  ac_x_includes=
+  ac_x_libraries=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS="$ac_save_LIBS"
+# If that didn't work, only try xmkmf and file system searches
+# for native compilation.
+if test x"$ac_x_includes" = xno && test "$cross_compiling" = no
+then :
+  rm -f -r conftest.dir
 if mkdir conftest.dir; then
   cd conftest.dir
   cat >Imakefile <<'_ACEOF'
@@ -10894,7 +12859,7 @@ _ACEOF
   rm -f -r conftest.dir
 fi
 
-# Standard set of common directories for X headers.
+  # Standard set of common directories for X headers.
 # Check X11 before X11Rn because it is often a symlink to the current release.
 ac_x_header_dirs='
 /usr/X11/include
@@ -10921,6 +12886,8 @@ ac_x_header_dirs='
 /usr/local/include/X11R5
 /usr/local/include/X11R4
 
+/opt/X11/include
+
 /usr/X386/include
 /usr/x386/include
 /usr/XFree86/include/X11
@@ -10942,10 +12909,11 @@ if test "$ac_x_includes" = no; then
 /* end confdefs.h.  */
 #include <X11/Xlib.h>
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+if ac_fn_c_try_cpp "$LINENO"
+then :
   # We can compile using X headers with no special include directory.
 ac_x_includes=
-else
+else $as_nop
   for ac_dir in $ac_x_header_dirs; do
   if test -r "$ac_dir/X11/Xlib.h"; then
     ac_x_includes=$ac_dir
@@ -10966,20 +12934,21 @@ if test "$ac_x_libraries" = no; then
 /* end confdefs.h.  */
 #include <X11/Xlib.h>
 int
-main ()
+main (void)
 {
 XrmInitialize ()
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   LIBS=$ac_save_LIBS
 # We can link X programs with no special library path.
 ac_x_libraries=
-else
+else $as_nop
   LIBS=$ac_save_LIBS
-for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+for ac_dir in `printf "%s\n" "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
 do
   # Don't even attempt the hair of trying to link an X program!
   for ac_extension in a so sl dylib la dll; do
@@ -10990,19 +12959,21 @@ do
   done
 done
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi # $ac_x_libraries = no
 
+fi
+# Record the results.
 case $ac_x_includes,$ac_x_libraries in #(
-  no,* | *,no | *\'*)
+  no,* | *,no | *\'*) :
     # Didn't find X, or a directory has "'" in its name.
-    ac_cv_have_x="have_x=no";; #(
-  *)
+    ac_cv_have_x="have_x=no" ;; #(
+  *) :
     # Record where we found X for the cache.
     ac_cv_have_x="have_x=yes\
 	ac_x_includes='$ac_x_includes'\
-	ac_x_libraries='$ac_x_libraries'"
+	ac_x_libraries='$ac_x_libraries'" ;;
 esac
 fi
 ;; #(
@@ -11012,8 +12983,8 @@ fi
 fi # $with_x != no
 
 if test "$have_x" != yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
-$as_echo "$have_x" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
+printf "%s\n" "$have_x" >&6; }
   no_x=yes
 else
   # If each of the values was on the command line, it overrides each guess.
@@ -11023,14 +12994,14 @@ else
   ac_cv_have_x="have_x=yes\
 	ac_x_includes='$x_includes'\
 	ac_x_libraries='$x_libraries'"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
-$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
+printf "%s\n" "libraries $x_libraries, headers $x_includes" >&6; }
 fi
 
 if test "$no_x" = yes; then
   # Not all programs may use this symbol, but it does not hurt to define it.
 
-$as_echo "#define X_DISPLAY_MISSING 1" >>confdefs.h
+printf "%s\n" "#define X_DISPLAY_MISSING 1" >>confdefs.h
 
   X_CFLAGS= X_PRE_LIBS= X_LIBS= X_EXTRA_LIBS=
 else
@@ -11043,8 +13014,8 @@ else
     X_LIBS="$X_LIBS -L$x_libraries"
     # For Solaris; some versions of Sun CC require a space after -R and
     # others require no space.  Words are not sufficient . . . .
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -R must be followed by a space" >&5
-$as_echo_n "checking whether -R must be followed by a space... " >&6; }
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether -R must be followed by a space" >&5
+printf %s "checking whether -R must be followed by a space... " >&6; }
     ac_xsave_LIBS=$LIBS; LIBS="$LIBS -R$x_libraries"
     ac_xsave_c_werror_flag=$ac_c_werror_flag
     ac_c_werror_flag=yes
@@ -11052,42 +13023,44 @@ $as_echo_n "checking whether -R must be followed by a space... " >&6; }
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+if ac_fn_c_try_link "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
        X_LIBS="$X_LIBS -R$x_libraries"
-else
+else $as_nop
   LIBS="$ac_xsave_LIBS -R $x_libraries"
        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+if ac_fn_c_try_link "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 	  X_LIBS="$X_LIBS -R $x_libraries"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: neither works" >&5
-$as_echo "neither works" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: neither works" >&5
+printf "%s\n" "neither works" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
     ac_c_werror_flag=$ac_xsave_c_werror_flag
     LIBS=$ac_xsave_LIBS
@@ -11110,26 +13083,25 @@ rm -f core conftest.err conftest.$ac_objext \
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XOpenDisplay ();
 int
-main ()
+main (void)
 {
 return XOpenDisplay ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet" >&5
-$as_echo_n "checking for dnet_ntoa in -ldnet... " >&6; }
-if ${ac_cv_lib_dnet_dnet_ntoa+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet" >&5
+printf %s "checking for dnet_ntoa in -ldnet... " >&6; }
+if test ${ac_cv_lib_dnet_dnet_ntoa+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldnet  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11138,39 +13110,39 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char dnet_ntoa ();
 int
-main ()
+main (void)
 {
 return dnet_ntoa ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_dnet_dnet_ntoa=yes
-else
+else $as_nop
   ac_cv_lib_dnet_dnet_ntoa=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
-$as_echo "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
-if test "x$ac_cv_lib_dnet_dnet_ntoa" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_dnet_ntoa" >&5
+printf "%s\n" "$ac_cv_lib_dnet_dnet_ntoa" >&6; }
+if test "x$ac_cv_lib_dnet_dnet_ntoa" = xyes
+then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
 fi
 
     if test $ac_cv_lib_dnet_dnet_ntoa = no; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet_stub" >&5
-$as_echo_n "checking for dnet_ntoa in -ldnet_stub... " >&6; }
-if ${ac_cv_lib_dnet_stub_dnet_ntoa+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for dnet_ntoa in -ldnet_stub" >&5
+printf %s "checking for dnet_ntoa in -ldnet_stub... " >&6; }
+if test ${ac_cv_lib_dnet_stub_dnet_ntoa+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldnet_stub  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11179,36 +13151,35 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char dnet_ntoa ();
 int
-main ()
+main (void)
 {
 return dnet_ntoa ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_dnet_stub_dnet_ntoa=yes
-else
+else $as_nop
   ac_cv_lib_dnet_stub_dnet_ntoa=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
-$as_echo "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
-if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dnet_stub_dnet_ntoa" >&5
+printf "%s\n" "$ac_cv_lib_dnet_stub_dnet_ntoa" >&6; }
+if test "x$ac_cv_lib_dnet_stub_dnet_ntoa" = xyes
+then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
 fi
 
     fi
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
     LIBS="$ac_xsave_LIBS"
 
@@ -11221,16 +13192,18 @@ rm -f core conftest.err conftest.$ac_objext \
     # The functions gethostbyname, getservbyname, and inet_addr are
     # in -lbsd on LynxOS 3.0.1/i386, according to Lars Hecking.
     ac_fn_c_check_func "$LINENO" "gethostbyname" "ac_cv_func_gethostbyname"
-if test "x$ac_cv_func_gethostbyname" = xyes; then :
+if test "x$ac_cv_func_gethostbyname" = xyes
+then :
 
 fi
 
     if test $ac_cv_func_gethostbyname = no; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lnsl" >&5
-$as_echo_n "checking for gethostbyname in -lnsl... " >&6; }
-if ${ac_cv_lib_nsl_gethostbyname+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lnsl" >&5
+printf %s "checking for gethostbyname in -lnsl... " >&6; }
+if test ${ac_cv_lib_nsl_gethostbyname+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lnsl  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11239,39 +13212,39 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gethostbyname ();
 int
-main ()
+main (void)
 {
 return gethostbyname ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_nsl_gethostbyname=yes
-else
+else $as_nop
   ac_cv_lib_nsl_gethostbyname=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_gethostbyname" >&5
-$as_echo "$ac_cv_lib_nsl_gethostbyname" >&6; }
-if test "x$ac_cv_lib_nsl_gethostbyname" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_nsl_gethostbyname" >&5
+printf "%s\n" "$ac_cv_lib_nsl_gethostbyname" >&6; }
+if test "x$ac_cv_lib_nsl_gethostbyname" = xyes
+then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
 fi
 
       if test $ac_cv_lib_nsl_gethostbyname = no; then
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lbsd" >&5
-$as_echo_n "checking for gethostbyname in -lbsd... " >&6; }
-if ${ac_cv_lib_bsd_gethostbyname+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gethostbyname in -lbsd" >&5
+printf %s "checking for gethostbyname in -lbsd... " >&6; }
+if test ${ac_cv_lib_bsd_gethostbyname+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lbsd  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11280,30 +13253,29 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gethostbyname ();
 int
-main ()
+main (void)
 {
 return gethostbyname ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_bsd_gethostbyname=yes
-else
+else $as_nop
   ac_cv_lib_bsd_gethostbyname=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bsd_gethostbyname" >&5
-$as_echo "$ac_cv_lib_bsd_gethostbyname" >&6; }
-if test "x$ac_cv_lib_bsd_gethostbyname" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bsd_gethostbyname" >&5
+printf "%s\n" "$ac_cv_lib_bsd_gethostbyname" >&6; }
+if test "x$ac_cv_lib_bsd_gethostbyname" = xyes
+then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lbsd"
 fi
 
@@ -11318,16 +13290,18 @@ fi
     # must be given before -lnsl if both are needed.  We assume that
     # if connect needs -lnsl, so does gethostbyname.
     ac_fn_c_check_func "$LINENO" "connect" "ac_cv_func_connect"
-if test "x$ac_cv_func_connect" = xyes; then :
+if test "x$ac_cv_func_connect" = xyes
+then :
 
 fi
 
     if test $ac_cv_func_connect = no; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for connect in -lsocket" >&5
-$as_echo_n "checking for connect in -lsocket... " >&6; }
-if ${ac_cv_lib_socket_connect+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for connect in -lsocket" >&5
+printf %s "checking for connect in -lsocket... " >&6; }
+if test ${ac_cv_lib_socket_connect+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsocket $X_EXTRA_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11336,30 +13310,29 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char connect ();
 int
-main ()
+main (void)
 {
 return connect ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_socket_connect=yes
-else
+else $as_nop
   ac_cv_lib_socket_connect=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_connect" >&5
-$as_echo "$ac_cv_lib_socket_connect" >&6; }
-if test "x$ac_cv_lib_socket_connect" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_socket_connect" >&5
+printf "%s\n" "$ac_cv_lib_socket_connect" >&6; }
+if test "x$ac_cv_lib_socket_connect" = xyes
+then :
   X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
 fi
 
@@ -11367,16 +13340,18 @@ fi
 
     # Guillermo Gomez says -lposix is necessary on A/UX.
     ac_fn_c_check_func "$LINENO" "remove" "ac_cv_func_remove"
-if test "x$ac_cv_func_remove" = xyes; then :
+if test "x$ac_cv_func_remove" = xyes
+then :
 
 fi
 
     if test $ac_cv_func_remove = no; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for remove in -lposix" >&5
-$as_echo_n "checking for remove in -lposix... " >&6; }
-if ${ac_cv_lib_posix_remove+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for remove in -lposix" >&5
+printf %s "checking for remove in -lposix... " >&6; }
+if test ${ac_cv_lib_posix_remove+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lposix  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11385,30 +13360,29 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char remove ();
 int
-main ()
+main (void)
 {
 return remove ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_posix_remove=yes
-else
+else $as_nop
   ac_cv_lib_posix_remove=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_posix_remove" >&5
-$as_echo "$ac_cv_lib_posix_remove" >&6; }
-if test "x$ac_cv_lib_posix_remove" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_posix_remove" >&5
+printf "%s\n" "$ac_cv_lib_posix_remove" >&6; }
+if test "x$ac_cv_lib_posix_remove" = xyes
+then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
 fi
 
@@ -11416,16 +13390,18 @@ fi
 
     # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
     ac_fn_c_check_func "$LINENO" "shmat" "ac_cv_func_shmat"
-if test "x$ac_cv_func_shmat" = xyes; then :
+if test "x$ac_cv_func_shmat" = xyes
+then :
 
 fi
 
     if test $ac_cv_func_shmat = no; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shmat in -lipc" >&5
-$as_echo_n "checking for shmat in -lipc... " >&6; }
-if ${ac_cv_lib_ipc_shmat+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for shmat in -lipc" >&5
+printf %s "checking for shmat in -lipc... " >&6; }
+if test ${ac_cv_lib_ipc_shmat+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lipc  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11434,30 +13410,29 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char shmat ();
 int
-main ()
+main (void)
 {
 return shmat ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_ipc_shmat=yes
-else
+else $as_nop
   ac_cv_lib_ipc_shmat=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ipc_shmat" >&5
-$as_echo "$ac_cv_lib_ipc_shmat" >&6; }
-if test "x$ac_cv_lib_ipc_shmat" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ipc_shmat" >&5
+printf "%s\n" "$ac_cv_lib_ipc_shmat" >&6; }
+if test "x$ac_cv_lib_ipc_shmat" = xyes
+then :
   X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
 fi
 
@@ -11473,11 +13448,12 @@ fi
   # These have to be linked with before -lX11, unlike the other
   # libraries we check for below, so use a different variable.
   # John Interrante, Karl Berry
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for IceConnectionNumber in -lICE" >&5
-$as_echo_n "checking for IceConnectionNumber in -lICE... " >&6; }
-if ${ac_cv_lib_ICE_IceConnectionNumber+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for IceConnectionNumber in -lICE" >&5
+printf %s "checking for IceConnectionNumber in -lICE... " >&6; }
+if test ${ac_cv_lib_ICE_IceConnectionNumber+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lICE $X_EXTRA_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11486,30 +13462,29 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char IceConnectionNumber ();
 int
-main ()
+main (void)
 {
 return IceConnectionNumber ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_ICE_IceConnectionNumber=yes
-else
+else $as_nop
   ac_cv_lib_ICE_IceConnectionNumber=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
-$as_echo "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
-if test "x$ac_cv_lib_ICE_IceConnectionNumber" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ICE_IceConnectionNumber" >&5
+printf "%s\n" "$ac_cv_lib_ICE_IceConnectionNumber" >&6; }
+if test "x$ac_cv_lib_ICE_IceConnectionNumber" = xyes
+then :
   X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
 fi
 
@@ -11523,11 +13498,12 @@ then
     ac_save_CPPFLAGS="$CPPFLAGS"
     CPPFLAGS="$CPPFLAGS $X_CFLAGS"
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lX11" >&5
-$as_echo_n "checking for -lX11... " >&6; }
-if ${ac_cv_lib_soname_X11+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lX11" >&5
+printf %s "checking for -lX11... " >&6; }
+if test ${ac_cv_lib_soname_X11+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lX11 $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11536,53 +13512,52 @@ LIBS="-lX11 $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XCreateWindow ();
 int
-main ()
+main (void)
 {
 return XCreateWindow ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_X11=`$ac_cv_path_LDD conftest.exe | grep "X11" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_X11=`$OTOOL -L conftest$ac_exeext | grep "libX11\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libX11\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_X11=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libX11\\.$LIBEXT" | sed -e "s/^.*\\[\\(libX11\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_X11:+false} :; then :
+       if ${ac_cv_lib_soname_X11:+false} :
+then :
   ac_cv_lib_soname_X11=`$LDD conftest$ac_exeext | grep "libX11\\.$LIBEXT" | sed -e "s/^.*\(libX11\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_X11=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_X11:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_X11:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_X11" >&5
-$as_echo "$ac_cv_lib_soname_X11" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_X11" >&5
+printf "%s\n" "$ac_cv_lib_soname_X11" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBX11 "$ac_cv_lib_soname_X11"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBX11 \"$ac_cv_lib_soname_X11\"" >>confdefs.h
 
 
 fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXext" >&5
-$as_echo_n "checking for -lXext... " >&6; }
-if ${ac_cv_lib_soname_Xext+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXext" >&5
+printf %s "checking for -lXext... " >&6; }
+if test ${ac_cv_lib_soname_Xext+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXext $X_LIBS -lX11 $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11591,91 +13566,250 @@ LIBS="-lXext $X_LIBS -lX11 $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XextCreateExtension ();
 int
-main ()
+main (void)
 {
 return XextCreateExtension ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xext=`$ac_cv_path_LDD conftest.exe | grep "Xext" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xext=`$OTOOL -L conftest$ac_exeext | grep "libXext\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXext\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xext=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXext\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXext\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xext:+false} :; then :
+       if ${ac_cv_lib_soname_Xext:+false} :
+then :
   ac_cv_lib_soname_Xext=`$LDD conftest$ac_exeext | grep "libXext\\.$LIBEXT" | sed -e "s/^.*\(libXext\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xext=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xext:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xext:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xext" >&5
-$as_echo "$ac_cv_lib_soname_Xext" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xext" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xext" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXEXT "$ac_cv_lib_soname_Xext"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXEXT \"$ac_cv_lib_soname_Xext\"" >>confdefs.h
 
        X_LIBS="$X_LIBS -lXext"
 fi
     X_LIBS="$X_LIBS -lX11"
 
-        for ac_header in X11/Xlib.h \
-                      X11/XKBlib.h \
-                      X11/Xutil.h \
-                      X11/Xcursor/Xcursor.h \
-                      X11/extensions/shape.h \
-                      X11/extensions/XInput.h \
-                      X11/extensions/XInput2.h \
-                      X11/extensions/XShm.h \
-                      X11/extensions/Xcomposite.h \
-                      X11/extensions/Xfixes.h \
-                      X11/extensions/Xinerama.h \
-                      X11/extensions/Xrandr.h \
-                      X11/extensions/Xrender.h \
-                      X11/extensions/xf86vmode.h \
-                      X11/extensions/xf86vmproto.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#ifdef HAVE_X11_XLIB_H
+        ac_fn_c_check_header_compile "$LINENO" "X11/Xlib.h" "ac_cv_header_X11_Xlib_h" "#ifdef HAVE_X11_XLIB_H
 # include <X11/Xlib.h>
 #endif
 #ifdef HAVE_X11_XUTIL_H
 # include <X11/Xutil.h>
 #endif
 "
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+if test "x$ac_cv_header_X11_Xlib_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_XLIB_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/XKBlib.h" "ac_cv_header_X11_XKBlib_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_XKBlib_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_XKBLIB_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "X11/Xutil.h" "ac_cv_header_X11_Xutil_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_Xutil_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_XUTIL_H 1" >>confdefs.h
 
-done
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/Xcursor/Xcursor.h" "ac_cv_header_X11_Xcursor_Xcursor_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_Xcursor_Xcursor_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_XCURSOR_XCURSOR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/shape.h" "ac_cv_header_X11_extensions_shape_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_shape_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_SHAPE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/XInput.h" "ac_cv_header_X11_extensions_XInput_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_XInput_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XINPUT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/XInput2.h" "ac_cv_header_X11_extensions_XInput2_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_XInput2_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XINPUT2_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/XShm.h" "ac_cv_header_X11_extensions_XShm_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_XShm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XSHM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xcomposite.h" "ac_cv_header_X11_extensions_Xcomposite_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_Xcomposite_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XCOMPOSITE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xfixes.h" "ac_cv_header_X11_extensions_Xfixes_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_Xfixes_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XFIXES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xinerama.h" "ac_cv_header_X11_extensions_Xinerama_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_Xinerama_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XINERAMA_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xpresent.h" "ac_cv_header_X11_extensions_Xpresent_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_Xpresent_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XPRESENT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xrandr.h" "ac_cv_header_X11_extensions_Xrandr_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_Xrandr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XRANDR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xrender.h" "ac_cv_header_X11_extensions_Xrender_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_Xrender_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XRENDER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/xf86vmode.h" "ac_cv_header_X11_extensions_xf86vmode_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_xf86vmode_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XF86VMODE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/xf86vmproto.h" "ac_cv_header_X11_extensions_xf86vmproto_h" "#ifdef HAVE_X11_XLIB_H
+# include <X11/Xlib.h>
+#endif
+#ifdef HAVE_X11_XUTIL_H
+# include <X11/Xutil.h>
+#endif
+"
+if test "x$ac_cv_header_X11_extensions_xf86vmproto_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XF86VMPROTO_H 1" >>confdefs.h
+
+fi
 
 
                 if test "$ac_cv_header_X11_XKBlib_h" = "yes"
         then
-              { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XkbQueryExtension in -lX11" >&5
-$as_echo_n "checking for XkbQueryExtension in -lX11... " >&6; }
-if ${ac_cv_lib_X11_XkbQueryExtension+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+              { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XkbQueryExtension in -lX11" >&5
+printf %s "checking for XkbQueryExtension in -lX11... " >&6; }
+if test ${ac_cv_lib_X11_XkbQueryExtension+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lX11 $X_LIBS $X_EXTRA_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11684,32 +13818,31 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XkbQueryExtension ();
 int
-main ()
+main (void)
 {
 return XkbQueryExtension ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_X11_XkbQueryExtension=yes
-else
+else $as_nop
   ac_cv_lib_X11_XkbQueryExtension=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_X11_XkbQueryExtension" >&5
-$as_echo "$ac_cv_lib_X11_XkbQueryExtension" >&6; }
-if test "x$ac_cv_lib_X11_XkbQueryExtension" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_X11_XkbQueryExtension" >&5
+printf "%s\n" "$ac_cv_lib_X11_XkbQueryExtension" >&6; }
+if test "x$ac_cv_lib_X11_XkbQueryExtension" = xyes
+then :
 
-$as_echo "#define HAVE_XKB 1" >>confdefs.h
+printf "%s\n" "#define HAVE_XKB 1" >>confdefs.h
 
 fi
 
@@ -11717,11 +13850,12 @@ fi
 
                 if test "$ac_cv_header_X11_Xcursor_Xcursor_h" = "yes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXcursor" >&5
-$as_echo_n "checking for -lXcursor... " >&6; }
-if ${ac_cv_lib_soname_Xcursor+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXcursor" >&5
+printf %s "checking for -lXcursor... " >&6; }
+if test ${ac_cv_lib_soname_Xcursor+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXcursor $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11730,50 +13864,49 @@ LIBS="-lXcursor $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XcursorImageLoadCursor ();
 int
-main ()
+main (void)
 {
 return XcursorImageLoadCursor ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xcursor=`$ac_cv_path_LDD conftest.exe | grep "Xcursor" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xcursor=`$OTOOL -L conftest$ac_exeext | grep "libXcursor\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXcursor\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xcursor=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXcursor\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXcursor\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xcursor:+false} :; then :
+       if ${ac_cv_lib_soname_Xcursor:+false} :
+then :
   ac_cv_lib_soname_Xcursor=`$LDD conftest$ac_exeext | grep "libXcursor\\.$LIBEXT" | sed -e "s/^.*\(libXcursor\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xcursor=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xcursor:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xcursor:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xcursor" >&5
-$as_echo "$ac_cv_lib_soname_Xcursor" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xcursor" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xcursor" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXCURSOR "$ac_cv_lib_soname_Xcursor"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXCURSOR \"$ac_cv_lib_soname_Xcursor\"" >>confdefs.h
 
 
 fi
         fi
-        if test "x$ac_cv_lib_soname_Xcursor" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xcursor" = "x"
+then :
   case "x$with_xcursor" in
   x)   as_fn_append wine_notices "|libxcursor ${notice_platform}development files not found, the Xcursor extension won't be supported." ;;
   xno) ;;
@@ -11785,11 +13918,12 @@ fi
 
                 if test "$ac_cv_header_X11_extensions_XInput_h" = "yes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXi" >&5
-$as_echo_n "checking for -lXi... " >&6; }
-if ${ac_cv_lib_soname_Xi+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXi" >&5
+printf %s "checking for -lXi... " >&6; }
+if test ${ac_cv_lib_soname_Xi+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXi $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11798,50 +13932,49 @@ LIBS="-lXi $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XOpenDevice ();
 int
-main ()
+main (void)
 {
 return XOpenDevice ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xi=`$ac_cv_path_LDD conftest.exe | grep "Xi" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xi=`$OTOOL -L conftest$ac_exeext | grep "libXi\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXi\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xi=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXi\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXi\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xi:+false} :; then :
+       if ${ac_cv_lib_soname_Xi:+false} :
+then :
   ac_cv_lib_soname_Xi=`$LDD conftest$ac_exeext | grep "libXi\\.$LIBEXT" | sed -e "s/^.*\(libXi\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xi=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xi:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xi:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xi" >&5
-$as_echo "$ac_cv_lib_soname_Xi" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xi" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xi" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXI "$ac_cv_lib_soname_Xi"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXI \"$ac_cv_lib_soname_Xi\"" >>confdefs.h
 
 
 fi
         fi
-        if test "x$ac_cv_lib_soname_Xi" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xi" = "x"
+then :
   case "x$with_xinput" in
   x)   as_fn_append wine_notices "|libxi ${notice_platform}development files not found, the Xinput extension won't be supported." ;;
   xno) ;;
@@ -11853,7 +13986,8 @@ fi
 
                 if test "x$ac_cv_lib_soname_Xi" != x
         then
-            if test "$ac_cv_header_X11_extensions_XInput2_h" != "yes"; then :
+            if test "$ac_cv_header_X11_extensions_XInput2_h" != "yes"
+then :
   case "x$with_xinput2" in
   x)   as_fn_append wine_notices "|XInput2 headers not found, the XInput 2 extension won't be supported." ;;
   xno) ;;
@@ -11866,11 +14000,12 @@ fi
 
                 if test "$ac_cv_header_X11_extensions_XShm_h" = "yes"
         then
-              { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XShmQueryExtension in -lXext" >&5
-$as_echo_n "checking for XShmQueryExtension in -lXext... " >&6; }
-if ${ac_cv_lib_Xext_XShmQueryExtension+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+              { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XShmQueryExtension in -lXext" >&5
+printf %s "checking for XShmQueryExtension in -lXext... " >&6; }
+if test ${ac_cv_lib_Xext_XShmQueryExtension+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lXext $X_LIBS $X_EXTRA_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11879,37 +14014,37 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XShmQueryExtension ();
 int
-main ()
+main (void)
 {
 return XShmQueryExtension ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_Xext_XShmQueryExtension=yes
-else
+else $as_nop
   ac_cv_lib_Xext_XShmQueryExtension=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShmQueryExtension" >&5
-$as_echo "$ac_cv_lib_Xext_XShmQueryExtension" >&6; }
-if test "x$ac_cv_lib_Xext_XShmQueryExtension" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShmQueryExtension" >&5
+printf "%s\n" "$ac_cv_lib_Xext_XShmQueryExtension" >&6; }
+if test "x$ac_cv_lib_Xext_XShmQueryExtension" = xyes
+then :
 
-$as_echo "#define HAVE_LIBXXSHM 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LIBXXSHM 1" >>confdefs.h
 
 fi
 
         fi
-        if test "$ac_cv_lib_Xext_XShmQueryExtension" != "yes"; then :
+        if test "$ac_cv_lib_Xext_XShmQueryExtension" != "yes"
+then :
   case "x$with_xshm" in
   x)   as_fn_append wine_notices "|XShm ${notice_platform}development files not found, X Shared Memory won't be supported." ;;
   xno) ;;
@@ -11921,11 +14056,12 @@ fi
 
                 if test "$ac_cv_header_X11_extensions_shape_h" = "yes"
         then
-              { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XShapeQueryExtension in -lXext" >&5
-$as_echo_n "checking for XShapeQueryExtension in -lXext... " >&6; }
-if ${ac_cv_lib_Xext_XShapeQueryExtension+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+              { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XShapeQueryExtension in -lXext" >&5
+printf %s "checking for XShapeQueryExtension in -lXext... " >&6; }
+if test ${ac_cv_lib_Xext_XShapeQueryExtension+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lXext $X_LIBS $X_EXTRA_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11934,37 +14070,37 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XShapeQueryExtension ();
 int
-main ()
+main (void)
 {
 return XShapeQueryExtension ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_Xext_XShapeQueryExtension=yes
-else
+else $as_nop
   ac_cv_lib_Xext_XShapeQueryExtension=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
-$as_echo "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
-if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
+printf "%s\n" "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
+if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = xyes
+then :
 
-$as_echo "#define HAVE_LIBXSHAPE 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LIBXSHAPE 1" >>confdefs.h
 
 fi
 
         fi
-        if test "$ac_cv_lib_Xext_XShapeQueryExtension" != "yes"; then :
+        if test "$ac_cv_lib_Xext_XShapeQueryExtension" != "yes"
+then :
   case "x$with_xshape" in
   x)   as_fn_append wine_notices "|XShape ${notice_platform}development files not found, XShape won't be supported." ;;
   xno) ;;
@@ -11976,11 +14112,12 @@ fi
 
                 if test "$ac_cv_header_X11_extensions_xf86vmode_h" = "yes" -o "$ac_cv_header_X11_extensions_xf86vmproto_h" = "yes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXxf86vm" >&5
-$as_echo_n "checking for -lXxf86vm... " >&6; }
-if ${ac_cv_lib_soname_Xxf86vm+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXxf86vm" >&5
+printf %s "checking for -lXxf86vm... " >&6; }
+if test ${ac_cv_lib_soname_Xxf86vm+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXxf86vm $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11989,50 +14126,49 @@ LIBS="-lXxf86vm $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XF86VidModeQueryExtension ();
 int
-main ()
+main (void)
 {
 return XF86VidModeQueryExtension ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xxf86vm=`$ac_cv_path_LDD conftest.exe | grep "Xxf86vm" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xxf86vm=`$OTOOL -L conftest$ac_exeext | grep "libXxf86vm\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXxf86vm\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xxf86vm=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXxf86vm\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXxf86vm\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xxf86vm:+false} :; then :
+       if ${ac_cv_lib_soname_Xxf86vm:+false} :
+then :
   ac_cv_lib_soname_Xxf86vm=`$LDD conftest$ac_exeext | grep "libXxf86vm\\.$LIBEXT" | sed -e "s/^.*\(libXxf86vm\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xxf86vm=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xxf86vm:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xxf86vm:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xxf86vm" >&5
-$as_echo "$ac_cv_lib_soname_Xxf86vm" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xxf86vm" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xxf86vm" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXXF86VM "$ac_cv_lib_soname_Xxf86vm"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXXF86VM \"$ac_cv_lib_soname_Xxf86vm\"" >>confdefs.h
 
 
 fi
         fi
-        if test "x$ac_cv_lib_soname_Xxf86vm" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xxf86vm" = "x"
+then :
   case "x$with_xxf86vm" in
   x)   as_fn_append wine_notices "|libXxf86vm ${notice_platform}development files not found, XFree86 Vidmode won't be supported." ;;
   xno) ;;
@@ -12044,11 +14180,12 @@ fi
 
                 if test "$ac_cv_header_X11_extensions_Xrender_h" = "yes" -a "x$ac_cv_lib_soname_X11" != "x"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXrender" >&5
-$as_echo_n "checking for -lXrender... " >&6; }
-if ${ac_cv_lib_soname_Xrender+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXrender" >&5
+printf %s "checking for -lXrender... " >&6; }
+if test ${ac_cv_lib_soname_Xrender+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXrender $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12057,51 +14194,50 @@ LIBS="-lXrender $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XRenderQueryExtension ();
 int
-main ()
+main (void)
 {
 return XRenderQueryExtension ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xrender=`$ac_cv_path_LDD conftest.exe | grep "Xrender" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xrender=`$OTOOL -L conftest$ac_exeext | grep "libXrender\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXrender\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xrender=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXrender\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXrender\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xrender:+false} :; then :
+       if ${ac_cv_lib_soname_Xrender:+false} :
+then :
   ac_cv_lib_soname_Xrender=`$LDD conftest$ac_exeext | grep "libXrender\\.$LIBEXT" | sed -e "s/^.*\(libXrender\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xrender=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xrender:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xrender:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xrender" >&5
-$as_echo "$ac_cv_lib_soname_Xrender" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xrender" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xrender" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXRENDER "$ac_cv_lib_soname_Xrender"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXRENDER \"$ac_cv_lib_soname_Xrender\"" >>confdefs.h
 
-       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XRenderSetPictureTransform in -lXrender" >&5
-$as_echo_n "checking for XRenderSetPictureTransform in -lXrender... " >&6; }
-if ${ac_cv_lib_Xrender_XRenderSetPictureTransform+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XRenderSetPictureTransform in -lXrender" >&5
+printf %s "checking for XRenderSetPictureTransform in -lXrender... " >&6; }
+if test ${ac_cv_lib_Xrender_XRenderSetPictureTransform+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lXrender $X_LIBS $X_EXTRA_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12110,40 +14246,40 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XRenderSetPictureTransform ();
 int
-main ()
+main (void)
 {
 return XRenderSetPictureTransform ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_Xrender_XRenderSetPictureTransform=yes
-else
+else $as_nop
   ac_cv_lib_Xrender_XRenderSetPictureTransform=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xrender_XRenderSetPictureTransform" >&5
-$as_echo "$ac_cv_lib_Xrender_XRenderSetPictureTransform" >&6; }
-if test "x$ac_cv_lib_Xrender_XRenderSetPictureTransform" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xrender_XRenderSetPictureTransform" >&5
+printf "%s\n" "$ac_cv_lib_Xrender_XRenderSetPictureTransform" >&6; }
+if test "x$ac_cv_lib_Xrender_XRenderSetPictureTransform" = xyes
+then :
 
-$as_echo "#define HAVE_XRENDERSETPICTURETRANSFORM 1" >>confdefs.h
+printf "%s\n" "#define HAVE_XRENDERSETPICTURETRANSFORM 1" >>confdefs.h
 
 fi
 
-               { $as_echo "$as_me:${as_lineno-$LINENO}: checking for XRenderCreateLinearGradient in -lXrender" >&5
-$as_echo_n "checking for XRenderCreateLinearGradient in -lXrender... " >&6; }
-if ${ac_cv_lib_Xrender_XRenderCreateLinearGradient+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+               { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XRenderCreateLinearGradient in -lXrender" >&5
+printf %s "checking for XRenderCreateLinearGradient in -lXrender... " >&6; }
+if test ${ac_cv_lib_Xrender_XRenderCreateLinearGradient+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lXrender $X_LIBS $X_EXTRA_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12152,39 +14288,39 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XRenderCreateLinearGradient ();
 int
-main ()
+main (void)
 {
 return XRenderCreateLinearGradient ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_Xrender_XRenderCreateLinearGradient=yes
-else
+else $as_nop
   ac_cv_lib_Xrender_XRenderCreateLinearGradient=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xrender_XRenderCreateLinearGradient" >&5
-$as_echo "$ac_cv_lib_Xrender_XRenderCreateLinearGradient" >&6; }
-if test "x$ac_cv_lib_Xrender_XRenderCreateLinearGradient" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xrender_XRenderCreateLinearGradient" >&5
+printf "%s\n" "$ac_cv_lib_Xrender_XRenderCreateLinearGradient" >&6; }
+if test "x$ac_cv_lib_Xrender_XRenderCreateLinearGradient" = xyes
+then :
 
-$as_echo "#define HAVE_XRENDERCREATELINEARGRADIENT 1" >>confdefs.h
+printf "%s\n" "#define HAVE_XRENDERCREATELINEARGRADIENT 1" >>confdefs.h
 
 fi
 
 fi
 
         fi
-        if test "x$ac_cv_lib_soname_Xrender" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xrender" = "x"
+then :
   case "x$with_xrender" in
   x)   as_fn_append wine_warnings "|libxrender ${notice_platform}development files not found, XRender won't be supported." ;;
   xno) ;;
@@ -12201,19 +14337,21 @@ fi
 #include <X11/Xlib.h>
 #include <X11/extensions/Xrandr.h>
 int
-main ()
+main (void)
 {
 static typeof(XRRSetScreenConfigAndRate) * func; if (func) return 0;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXrandr" >&5
-$as_echo_n "checking for -lXrandr... " >&6; }
-if ${ac_cv_lib_soname_Xrandr+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXrandr" >&5
+printf %s "checking for -lXrandr... " >&6; }
+if test ${ac_cv_lib_soname_Xrandr+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXrandr $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12222,71 +14360,71 @@ LIBS="-lXrandr $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XRRQueryExtension ();
 int
-main ()
+main (void)
 {
 return XRRQueryExtension ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xrandr=`$ac_cv_path_LDD conftest.exe | grep "Xrandr" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xrandr=`$OTOOL -L conftest$ac_exeext | grep "libXrandr\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXrandr\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xrandr=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXrandr\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXrandr\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xrandr:+false} :; then :
+       if ${ac_cv_lib_soname_Xrandr:+false} :
+then :
   ac_cv_lib_soname_Xrandr=`$LDD conftest$ac_exeext | grep "libXrandr\\.$LIBEXT" | sed -e "s/^.*\(libXrandr\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xrandr=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xrandr:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xrandr:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xrandr" >&5
-$as_echo "$ac_cv_lib_soname_Xrandr" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xrandr" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xrandr" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXRANDR "$ac_cv_lib_soname_Xrandr"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXRANDR \"$ac_cv_lib_soname_Xrandr\"" >>confdefs.h
 
        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <X11/Xlib.h>
 #include <X11/extensions/Xrandr.h>
 int
-main ()
+main (void)
 {
 static typeof(XRRGetProviderResources) *f; if (f) return 0;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-$as_echo "#define HAVE_XRRGETPROVIDERRESOURCES 1" >>confdefs.h
+printf "%s\n" "#define HAVE_XRRGETPROVIDERRESOURCES 1" >>confdefs.h
 
-else
+else $as_nop
   as_fn_append wine_notices "|libxrandr ${notice_platform}development files too old, XRandR display device handler won't be supported."
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
         fi
-        if test "x$ac_cv_lib_soname_Xrandr" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xrandr" = "x"
+then :
   case "x$with_xrandr" in
   x)   as_fn_append wine_notices "|libxrandr ${notice_platform}development files not found, XRandr won't be supported." ;;
   xno) ;;
@@ -12303,19 +14441,21 @@ fi
 #include <X11/Xlib.h>
 #include <X11/extensions/Xfixes.h>
 int
-main ()
+main (void)
 {
 static typeof(XFixesQueryVersion) * func; if (func) return 0;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXfixes" >&5
-$as_echo_n "checking for -lXfixes... " >&6; }
-if ${ac_cv_lib_soname_Xfixes+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXfixes" >&5
+printf %s "checking for -lXfixes... " >&6; }
+if test ${ac_cv_lib_soname_Xfixes+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXfixes $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12324,52 +14464,51 @@ LIBS="-lXfixes $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XFixesQueryVersion ();
 int
-main ()
+main (void)
 {
 return XFixesQueryVersion ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xfixes=`$ac_cv_path_LDD conftest.exe | grep "Xfixes" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xfixes=`$OTOOL -L conftest$ac_exeext | grep "libXfixes\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXfixes\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xfixes=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXfixes\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXfixes\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xfixes:+false} :; then :
+       if ${ac_cv_lib_soname_Xfixes:+false} :
+then :
   ac_cv_lib_soname_Xfixes=`$LDD conftest$ac_exeext | grep "libXfixes\\.$LIBEXT" | sed -e "s/^.*\(libXfixes\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xfixes=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xfixes:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xfixes:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xfixes" >&5
-$as_echo "$ac_cv_lib_soname_Xfixes" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xfixes" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xfixes" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXFIXES "$ac_cv_lib_soname_Xfixes"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXFIXES \"$ac_cv_lib_soname_Xfixes\"" >>confdefs.h
 
 
 fi
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
         fi
-        if test "x$ac_cv_lib_soname_Xfixes" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xfixes" = "x"
+then :
   case "x$with_xfixes" in
   x)   as_fn_append wine_notices "|libxfixes ${notice_platform}development files not found, Xfixes won't be supported." ;;
   xno) ;;
@@ -12386,19 +14525,21 @@ fi
 #include <X11/Xlib.h>
 #include <X11/extensions/Xinerama.h>
 int
-main ()
+main (void)
 {
 static typeof(XineramaQueryScreens) * func; if (func) return 0;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXinerama" >&5
-$as_echo_n "checking for -lXinerama... " >&6; }
-if ${ac_cv_lib_soname_Xinerama+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXinerama" >&5
+printf %s "checking for -lXinerama... " >&6; }
+if test ${ac_cv_lib_soname_Xinerama+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXinerama $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12407,52 +14548,51 @@ LIBS="-lXinerama $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XineramaQueryScreens ();
 int
-main ()
+main (void)
 {
 return XineramaQueryScreens ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xinerama=`$ac_cv_path_LDD conftest.exe | grep "Xinerama" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xinerama=`$OTOOL -L conftest$ac_exeext | grep "libXinerama\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXinerama\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xinerama=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXinerama\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXinerama\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xinerama:+false} :; then :
+       if ${ac_cv_lib_soname_Xinerama:+false} :
+then :
   ac_cv_lib_soname_Xinerama=`$LDD conftest$ac_exeext | grep "libXinerama\\.$LIBEXT" | sed -e "s/^.*\(libXinerama\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xinerama=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xinerama:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xinerama:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xinerama" >&5
-$as_echo "$ac_cv_lib_soname_Xinerama" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xinerama" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xinerama" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXINERAMA "$ac_cv_lib_soname_Xinerama"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXINERAMA \"$ac_cv_lib_soname_Xinerama\"" >>confdefs.h
 
 
 fi
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
         fi
-        if test "x$ac_cv_lib_soname_Xinerama" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xinerama" = "x"
+then :
   case "x$with_xinerama" in
   x)   as_fn_append wine_notices "|libxinerama ${notice_platform}development files not found, multi-monitor setups won't be supported." ;;
   xno) ;;
@@ -12460,15 +14600,100 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 This is an error since --with-xinerama was requested." "$LINENO" 5 ;;
 esac
 
+fi
+
+                if test "$ac_cv_header_X11_extensions_Xpresent_h" = "yes"
+        then
+                cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+#include <X11/extensions/Xpresent.h>
+int
+main (void)
+{
+static typeof(XPresentQueryVersion) * func; if (func) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXpresent" >&5
+printf %s "checking for -lXpresent... " >&6; }
+if test ${ac_cv_lib_soname_Xpresent+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXpresent $X_LIBS $X_EXTRA_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char XPresentQueryVersion ();
+int
+main (void)
+{
+return XPresentQueryVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xpresent=`$ac_cv_path_LDD conftest.exe | grep "Xpresent" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xpresent=`$OTOOL -L conftest$ac_exeext | grep "libXpresent\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXpresent\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xpresent=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXpresent\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXpresent\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xpresent:+false} :
+then :
+  ac_cv_lib_soname_Xpresent=`$LDD conftest$ac_exeext | grep "libXpresent\\.$LIBEXT" | sed -e "s/^.*\(libXpresent\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_Xpresent=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_Xpresent:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xpresent" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xpresent" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXPRESENT \"$ac_cv_lib_soname_Xpresent\"" >>confdefs.h
+
+
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+        fi
+        if test "x$ac_cv_lib_soname_Xpresent" = "x"
+then :
+  case "x$with_Xpresent" in
+  x)   as_fn_append wine_notices "|libXpresent ${notice_platform}development files not found, Xpresent won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libXpresent ${notice_platform}development files not found, Xpresent won't be supported.
+This is an error since --with-Xpresent was requested." "$LINENO" 5 ;;
+esac
+
 fi
 
                 if test "$ac_cv_header_X11_extensions_Xcomposite_h" = "yes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lXcomposite" >&5
-$as_echo_n "checking for -lXcomposite... " >&6; }
-if ${ac_cv_lib_soname_Xcomposite+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXcomposite" >&5
+printf %s "checking for -lXcomposite... " >&6; }
+if test ${ac_cv_lib_soname_Xcomposite+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lXcomposite $X_LIBS $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12477,50 +14702,49 @@ LIBS="-lXcomposite $X_LIBS $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char XCompositeRedirectWindow ();
 int
-main ()
+main (void)
 {
 return XCompositeRedirectWindow ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_Xcomposite=`$ac_cv_path_LDD conftest.exe | grep "Xcomposite" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_Xcomposite=`$OTOOL -L conftest$ac_exeext | grep "libXcomposite\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXcomposite\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_Xcomposite=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXcomposite\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXcomposite\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_Xcomposite:+false} :; then :
+       if ${ac_cv_lib_soname_Xcomposite:+false} :
+then :
   ac_cv_lib_soname_Xcomposite=`$LDD conftest$ac_exeext | grep "libXcomposite\\.$LIBEXT" | sed -e "s/^.*\(libXcomposite\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_Xcomposite=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_Xcomposite:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_Xcomposite:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xcomposite" >&5
-$as_echo "$ac_cv_lib_soname_Xcomposite" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xcomposite" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xcomposite" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBXCOMPOSITE "$ac_cv_lib_soname_Xcomposite"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBXCOMPOSITE \"$ac_cv_lib_soname_Xcomposite\"" >>confdefs.h
 
 
 fi
         fi
-        if test "x$ac_cv_lib_soname_Xcomposite" = "x"; then :
+        if test "x$ac_cv_lib_soname_Xcomposite" = "x"
+then :
   case "x$with_xcomposite" in
   x)   as_fn_append wine_notices "|libxcomposite ${notice_platform}development files not found, Xcomposite won't be supported." ;;
   xno) ;;
@@ -12534,11 +14758,10 @@ fi
 #include <X11/Xlib.h>
 #endif
 "
-if test "x$ac_cv_member_XICCallback_callback" = xyes; then :
+if test "x$ac_cv_member_XICCallback_callback" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_XICCALLBACK_CALLBACK 1
-_ACEOF
+printf "%s\n" "#define HAVE_XICCALLBACK_CALLBACK 1" >>confdefs.h
 
 
 fi
@@ -12546,11 +14769,10 @@ ac_fn_c_check_member "$LINENO" "XEvent" "xcookie" "ac_cv_member_XEvent_xcookie"
 #include <X11/Xlib.h>
 #endif
 "
-if test "x$ac_cv_member_XEvent_xcookie" = xyes; then :
+if test "x$ac_cv_member_XEvent_xcookie" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_XEVENT_XCOOKIE 1
-_ACEOF
+printf "%s\n" "#define HAVE_XEVENT_XCOOKIE 1" >>confdefs.h
 
 
 fi
@@ -12560,11 +14782,12 @@ fi
         opengl_msg=""
     if test "x$with_opengl" != "xno"
     then
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
-$as_echo_n "checking for -lGL... " >&6; }
-if ${ac_cv_lib_soname_GL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
+printf %s "checking for -lGL... " >&6; }
+if test ${ac_cv_lib_soname_GL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lGL $X_LIBS -lm $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12573,42 +14796,43 @@ LIBS="-lGL $X_LIBS -lm $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char glXCreateContext ();
 int
-main ()
+main (void)
 {
 return glXCreateContext ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_GL=`$ac_cv_path_LDD conftest.exe | grep "GL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_GL=`$OTOOL -L conftest$ac_exeext | grep "libGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_GL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_GL:+false} :; then :
+       if ${ac_cv_lib_soname_GL:+false} :
+then :
   ac_cv_lib_soname_GL=`$LDD conftest$ac_exeext | grep "libGL\\.$LIBEXT" | sed -e "s/^.*\(libGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_GL=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_GL:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-       { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
-$as_echo_n "checking for -lGL... " >&6; }
-if ${ac_cv_lib_soname_GL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if ${ac_cv_lib_soname_GL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
+printf %s "checking for -lGL... " >&6; }
+if test ${ac_cv_lib_soname_GL+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lGL $X_LIBS -lm $X_EXTRA_LIBS -dylib_file /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12617,37 +14841,37 @@ LIBS="-lGL $X_LIBS -lm $X_EXTRA_LIBS -dylib_file /System/Library/Frameworks/Open
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char glXCreateContext ();
 int
-main ()
+main (void)
 {
 return glXCreateContext ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_GL=`$ac_cv_path_LDD conftest.exe | grep "GL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_GL=`$OTOOL -L conftest$ac_exeext | grep "libGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_GL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_GL:+false} :; then :
+       if ${ac_cv_lib_soname_GL:+false} :
+then :
   ac_cv_lib_soname_GL=`$LDD conftest$ac_exeext | grep "libGL\\.$LIBEXT" | sed -e "s/^.*\(libGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_GL=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_GL:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_GL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        if test -f /usr/X11R6/lib/libGL.a
                             then
 	                        opengl_msg="/usr/X11R6/lib/libGL.a is present on your system.
@@ -12655,33 +14879,30 @@ This probably prevents linking to OpenGL. Try deleting the file and restarting c
                             else
                                 opengl_msg="No OpenGL library found on this system."
                             fi
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
-$as_echo "$ac_cv_lib_soname_GL" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
+printf "%s\n" "$ac_cv_lib_soname_GL" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBGL "$ac_cv_lib_soname_GL"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBGL \"$ac_cv_lib_soname_GL\"" >>confdefs.h
 
        OPENGL_LIBS="-Xlinker -dylib_file -Xlinker /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib -lGL"
 fi
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
-$as_echo "$ac_cv_lib_soname_GL" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
+printf "%s\n" "$ac_cv_lib_soname_GL" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBGL "$ac_cv_lib_soname_GL"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBGL \"$ac_cv_lib_soname_GL\"" >>confdefs.h
 
        OPENGL_LIBS="-lGL"
 fi
         if test "x$with_osmesa" != "xno"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lOSMesa" >&5
-$as_echo_n "checking for -lOSMesa... " >&6; }
-if ${ac_cv_lib_soname_OSMesa+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lOSMesa" >&5
+printf %s "checking for -lOSMesa... " >&6; }
+if test ${ac_cv_lib_soname_OSMesa+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lOSMesa $X_LIBS -lm $X_EXTRA_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12690,49 +14911,48 @@ LIBS="-lOSMesa $X_LIBS -lm $X_EXTRA_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char OSMesaGetProcAddress ();
 int
-main ()
+main (void)
 {
 return OSMesaGetProcAddress ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_OSMesa=`$ac_cv_path_LDD conftest.exe | grep "OSMesa" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_OSMesa=`$OTOOL -L conftest$ac_exeext | grep "libOSMesa\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libOSMesa\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_OSMesa=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libOSMesa\\.$LIBEXT" | sed -e "s/^.*\\[\\(libOSMesa\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_OSMesa:+false} :; then :
+       if ${ac_cv_lib_soname_OSMesa:+false} :
+then :
   ac_cv_lib_soname_OSMesa=`$LDD conftest$ac_exeext | grep "libOSMesa\\.$LIBEXT" | sed -e "s/^.*\(libOSMesa\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_OSMesa=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_OSMesa:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_OSMesa:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_OSMesa" >&5
-$as_echo "$ac_cv_lib_soname_OSMesa" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_OSMesa" >&5
+printf "%s\n" "$ac_cv_lib_soname_OSMesa" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBOSMESA "$ac_cv_lib_soname_OSMesa"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBOSMESA \"$ac_cv_lib_soname_OSMesa\"" >>confdefs.h
 
 
 fi
-            if test "x$ac_cv_lib_soname_OSMesa" = "x"; then :
+            if test "x$ac_cv_lib_soname_OSMesa" = "x"
+then :
   case "x$with_osmesa" in
   x)   as_fn_append wine_notices "|libOSMesa ${notice_platform}development files not found (or too old), OpenGL rendering in bitmaps won't be supported." ;;
   xno) ;;
@@ -12743,7 +14963,8 @@ esac
 fi
         fi
     fi
-    if test -n "$opengl_msg"; then :
+    if test -n "$opengl_msg"
+then :
   case "x$with_opengl" in
   x)   as_fn_append wine_warnings "|$opengl_msg
 OpenGL and Direct3D won't be supported." ;;
@@ -12763,7 +14984,8 @@ fi
 
 if test "$enable_wineandroid_drv$enable_winemac_drv" = "nono"
 then
-    if test "x$X_LIBS" = "x"; then :
+    if test "x$X_LIBS" = "x"
+then :
   case "x$with_x" in
   xno) ;;
   *)   as_fn_error $? "X ${notice_platform}development files not found. Wine will be built
@@ -12774,7 +14996,8 @@ esac
 enable_winex11_drv=${enable_winex11_drv:-no}
 fi
 else
-    if test "x$X_LIBS" = "x"; then :
+    if test "x$X_LIBS" = "x"
+then :
   case "x$with_x" in
   x)   as_fn_append wine_notices "|X ${notice_platform}development files not found, the X11 driver won't be supported." ;;
   xno) ;;
@@ -12787,11 +15010,12 @@ fi
 
 if test "$ac_cv_header_CL_cl_h" = "yes"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for clGetPlatformInfo in -lOpenCL" >&5
-$as_echo_n "checking for clGetPlatformInfo in -lOpenCL... " >&6; }
-if ${ac_cv_lib_OpenCL_clGetPlatformInfo+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for clGetPlatformInfo in -lOpenCL" >&5
+printf %s "checking for clGetPlatformInfo in -lOpenCL... " >&6; }
+if test ${ac_cv_lib_OpenCL_clGetPlatformInfo+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lOpenCL  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12800,36 +15024,36 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char clGetPlatformInfo ();
 int
-main ()
+main (void)
 {
 return clGetPlatformInfo ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_OpenCL_clGetPlatformInfo=yes
-else
+else $as_nop
   ac_cv_lib_OpenCL_clGetPlatformInfo=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_OpenCL_clGetPlatformInfo" >&5
-$as_echo "$ac_cv_lib_OpenCL_clGetPlatformInfo" >&6; }
-if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_OpenCL_clGetPlatformInfo" >&5
+printf "%s\n" "$ac_cv_lib_OpenCL_clGetPlatformInfo" >&6; }
+if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" = xyes
+then :
   OPENCL_LIBS="-lOpenCL"
 
 fi
 
 fi
-if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes; then :
+if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes
+then :
   case "x$with_opencl" in
   x)   as_fn_append wine_notices "|OpenCL ${notice_platform}development files not found, OpenCL won't be supported." ;;
   xno) ;;
@@ -12841,11 +15065,12 @@ fi
 
 if test "$ac_cv_header_pcap_pcap_h" = "yes"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pcap_create in -lpcap" >&5
-$as_echo_n "checking for pcap_create in -lpcap... " >&6; }
-if ${ac_cv_lib_pcap_pcap_create+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pcap_create in -lpcap" >&5
+printf %s "checking for pcap_create in -lpcap... " >&6; }
+if test ${ac_cv_lib_pcap_pcap_create+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lpcap  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12854,36 +15079,36 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char pcap_create ();
 int
-main ()
+main (void)
 {
 return pcap_create ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_pcap_pcap_create=yes
-else
+else $as_nop
   ac_cv_lib_pcap_pcap_create=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcap_pcap_create" >&5
-$as_echo "$ac_cv_lib_pcap_pcap_create" >&6; }
-if test "x$ac_cv_lib_pcap_pcap_create" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcap_pcap_create" >&5
+printf "%s\n" "$ac_cv_lib_pcap_pcap_create" >&6; }
+if test "x$ac_cv_lib_pcap_pcap_create" = xyes
+then :
   PCAP_LIBS="-lpcap"
 
 fi
 
 fi
-if test "x$ac_cv_lib_pcap_pcap_create" != xyes; then :
+if test "x$ac_cv_lib_pcap_pcap_create" != xyes
+then :
   case "x$with_pcap" in
   x)   as_fn_append wine_notices "|pcap ${notice_platform}development files not found, wpcap won't be supported." ;;
   xno) ;;
@@ -12895,40 +15120,40 @@ fi
 
 if test "x$with_inotify" != "xno"
 then
-    if ${INOTIFY_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${INOTIFY_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   INOTIFY_CFLAGS=`$PKG_CONFIG --cflags libinotify 2>/dev/null`
 fi
 fi
 
-if ${INOTIFY_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${INOTIFY_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   INOTIFY_LIBS=`$PKG_CONFIG --libs libinotify 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: libinotify cflags: $INOTIFY_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libinotify libs: $INOTIFY_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify cflags: $INOTIFY_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify libs: $INOTIFY_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $INOTIFY_CFLAGS"
-for ac_header in sys/inotify.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "sys/inotify.h" "ac_cv_header_sys_inotify_h" "$ac_includes_default"
-if test "x$ac_cv_header_sys_inotify_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_SYS_INOTIFY_H 1
-_ACEOF
+ac_fn_c_check_header_compile "$LINENO" "sys/inotify.h" "ac_cv_header_sys_inotify_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_inotify_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_INOTIFY_H 1" >>confdefs.h
 
 fi
 
-done
-
-         { $as_echo "$as_me:${as_lineno-$LINENO}: checking for inotify_add_watch in -linotify" >&5
-$as_echo_n "checking for inotify_add_watch in -linotify... " >&6; }
-if ${ac_cv_lib_inotify_inotify_add_watch+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for inotify_add_watch in -linotify" >&5
+printf %s "checking for inotify_add_watch in -linotify... " >&6; }
+if test ${ac_cv_lib_inotify_inotify_add_watch+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-linotify $INOTIFY_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -12937,39 +15162,39 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char inotify_add_watch ();
 int
-main ()
+main (void)
 {
 return inotify_add_watch ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_inotify_inotify_add_watch=yes
-else
+else $as_nop
   ac_cv_lib_inotify_inotify_add_watch=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_inotify_inotify_add_watch" >&5
-$as_echo "$ac_cv_lib_inotify_inotify_add_watch" >&6; }
-if test "x$ac_cv_lib_inotify_inotify_add_watch" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_inotify_inotify_add_watch" >&5
+printf "%s\n" "$ac_cv_lib_inotify_inotify_add_watch" >&6; }
+if test "x$ac_cv_lib_inotify_inotify_add_watch" = xyes
+then :
   :
-else
+else $as_nop
   INOTIFY_LIBS=""
 fi
 
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "$ac_cv_header_sys_inotify_h" != "yes"; then :
+if test "$ac_cv_header_sys_inotify_h" != "yes"
+then :
   case "x$with_inotify" in
   x)   as_fn_append wine_notices "|libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported." ;;
   xno) ;;
@@ -12981,30 +15206,36 @@ fi
 
 if test "x$with_dbus" != "xno"
 then
-    if ${DBUS_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${DBUS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   DBUS_CFLAGS=`$PKG_CONFIG --cflags dbus-1 2>/dev/null`
 fi
 fi
 
-if ${DBUS_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${DBUS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   DBUS_LIBS=`$PKG_CONFIG --libs dbus-1 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: dbus-1 cflags: $DBUS_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: dbus-1 libs: $DBUS_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 cflags: $DBUS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 libs: $DBUS_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $DBUS_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
-if test "x$ac_cv_header_dbus_dbus_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
-$as_echo_n "checking for -ldbus-1... " >&6; }
-if ${ac_cv_lib_soname_dbus_1+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+ac_fn_c_check_header_compile "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
+if test "x$ac_cv_header_dbus_dbus_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
+printf %s "checking for -ldbus-1... " >&6; }
+if test ${ac_cv_lib_soname_dbus_1+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-ldbus-1 $DBUS_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13013,58 +15244,56 @@ LIBS="-ldbus-1 $DBUS_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char dbus_connection_close ();
 int
-main ()
+main (void)
 {
 return dbus_connection_close ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_dbus_1=`$ac_cv_path_LDD conftest.exe | grep "dbus-1" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_dbus_1=`$OTOOL -L conftest$ac_exeext | grep "libdbus-1\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libdbus-1\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_dbus_1=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libdbus-1\\.$LIBEXT" | sed -e "s/^.*\\[\\(libdbus-1\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_dbus_1:+false} :; then :
+       if ${ac_cv_lib_soname_dbus_1:+false} :
+then :
   ac_cv_lib_soname_dbus_1=`$LDD conftest$ac_exeext | grep "libdbus-1\\.$LIBEXT" | sed -e "s/^.*\(libdbus-1\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_dbus_1=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_dbus_1:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_dbus_1:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        DBUS_CFLAGS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_dbus_1" >&5
-$as_echo "$ac_cv_lib_soname_dbus_1" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_dbus_1" >&5
+printf "%s\n" "$ac_cv_lib_soname_dbus_1" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBDBUS_1 "$ac_cv_lib_soname_dbus_1"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBDBUS_1 \"$ac_cv_lib_soname_dbus_1\"" >>confdefs.h
 
 
 fi
-else
+else $as_nop
   DBUS_CFLAGS=""
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
 if test "x$ac_cv_lib_soname_dbus_1" = "x" -a \
-                            "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"; then :
+                            "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"
+then :
   case "x$with_dbus" in
   x)   as_fn_append wine_notices "|libdbus ${notice_platform}development files not found, no dynamic device support." ;;
   xno) ;;
@@ -13076,30 +15305,36 @@ fi
 
 if test "x$with_hal" != "xno" -a "x$ac_cv_lib_soname_dbus_1" != x
 then
-    if ${HAL_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${HAL_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   HAL_CFLAGS=`$PKG_CONFIG --cflags hal 2>/dev/null`
 fi
 fi
 
-if ${HAL_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${HAL_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   HAL_LIBS=`$PKG_CONFIG --libs hal 2>/dev/null`
 fi
 fi
 
 HAL_LIBS=${HAL_LIBS:-"-ldbus-1"}
-$as_echo "$as_me:${as_lineno-$LINENO}: hal cflags: $HAL_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: hal libs: $HAL_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: hal cflags: $HAL_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: hal libs: $HAL_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $HAL_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "hal/libhal.h" "ac_cv_header_hal_libhal_h" "$ac_includes_default"
-if test "x$ac_cv_header_hal_libhal_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lhal" >&5
-$as_echo_n "checking for -lhal... " >&6; }
-if ${ac_cv_lib_soname_hal+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+ac_fn_c_check_header_compile "$LINENO" "hal/libhal.h" "ac_cv_header_hal_libhal_h" "$ac_includes_default"
+if test "x$ac_cv_header_hal_libhal_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lhal" >&5
+printf %s "checking for -lhal... " >&6; }
+if test ${ac_cv_lib_soname_hal+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lhal $HAL_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13108,57 +15343,55 @@ LIBS="-lhal $HAL_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char libhal_ctx_new ();
 int
-main ()
+main (void)
 {
 return libhal_ctx_new ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_hal=`$ac_cv_path_LDD conftest.exe | grep "hal" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_hal=`$OTOOL -L conftest$ac_exeext | grep "libhal\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libhal\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_hal=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libhal\\.$LIBEXT" | sed -e "s/^.*\\[\\(libhal\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_hal:+false} :; then :
+       if ${ac_cv_lib_soname_hal:+false} :
+then :
   ac_cv_lib_soname_hal=`$LDD conftest$ac_exeext | grep "libhal\\.$LIBEXT" | sed -e "s/^.*\(libhal\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_hal=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_hal:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_hal:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        HAL_CFLAGS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_hal" >&5
-$as_echo "$ac_cv_lib_soname_hal" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_hal" >&5
+printf "%s\n" "$ac_cv_lib_soname_hal" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBHAL "$ac_cv_lib_soname_hal"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBHAL \"$ac_cv_lib_soname_hal\"" >>confdefs.h
 
 
 fi
-else
+else $as_nop
   HAL_CFLAGS=""
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
     if test "x$ac_cv_lib_soname_hal" = "x" -a \
-                               "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"; then :
+                               "x$ac_cv_header_DiskArbitration_DiskArbitration_h" != "xyes"
+then :
   case "x$with_hal" in
   x)   as_fn_append wine_notices "|libhal ${notice_platform}development files not found, no legacy dynamic device support." ;;
   xno) ;;
@@ -13171,43 +15404,50 @@ fi
 
 if test "x$with_gnutls" != "xno"
 then
-    if ${GNUTLS_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${GNUTLS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GNUTLS_CFLAGS=`$PKG_CONFIG --cflags gnutls 2>/dev/null`
 fi
 fi
 
-if ${GNUTLS_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${GNUTLS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GNUTLS_LIBS=`$PKG_CONFIG --libs gnutls 2>/dev/null`
 fi
 fi
 
 GNUTLS_LIBS=${GNUTLS_LIBS:-"-lgnutls"}
-$as_echo "$as_me:${as_lineno-$LINENO}: gnutls cflags: $GNUTLS_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: gnutls libs: $GNUTLS_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gnutls cflags: $GNUTLS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gnutls libs: $GNUTLS_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $GNUTLS_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "gnutls/gnutls.h" "ac_cv_header_gnutls_gnutls_h" "$ac_includes_default"
-if test "x$ac_cv_header_gnutls_gnutls_h" = xyes; then :
+ac_fn_c_check_header_compile "$LINENO" "gnutls/gnutls.h" "ac_cv_header_gnutls_gnutls_h" "$ac_includes_default"
+if test "x$ac_cv_header_gnutls_gnutls_h" = xyes
+then :
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <gnutls/gnutls.h>
 #include <gnutls/crypto.h>
 int
-main ()
+main (void)
 {
 static typeof(gnutls_mac_get_key_size) *func; if (func) return 0;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lgnutls" >&5
-$as_echo_n "checking for -lgnutls... " >&6; }
-if ${ac_cv_lib_soname_gnutls+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lgnutls" >&5
+printf %s "checking for -lgnutls... " >&6; }
+if test ${ac_cv_lib_soname_gnutls+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lgnutls $GNUTLS_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13216,75 +15456,73 @@ LIBS="-lgnutls $GNUTLS_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gnutls_global_init ();
 int
-main ()
+main (void)
 {
 return gnutls_global_init ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_gnutls=`$ac_cv_path_LDD conftest.exe | grep "gnutls" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_gnutls=`$OTOOL -L conftest$ac_exeext | grep "libgnutls\\(-deb0\\)\\{0,1\\}\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libgnutls\\(-deb0\\)\\{0,1\\}\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_gnutls=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libgnutls\\(-deb0\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\\[\\(libgnutls\\(-deb0\\)\\{0,1\\}\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_gnutls:+false} :; then :
+       if ${ac_cv_lib_soname_gnutls:+false} :
+then :
   ac_cv_lib_soname_gnutls=`$LDD conftest$ac_exeext | grep "libgnutls\\(-deb0\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\(libgnutls\\(-deb0\\)\\{0,1\\}\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_gnutls=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_gnutls:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_gnutls:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        GNUTLS_CFLAGS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gnutls" >&5
-$as_echo "$ac_cv_lib_soname_gnutls" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gnutls" >&5
+printf "%s\n" "$ac_cv_lib_soname_gnutls" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBGNUTLS "$ac_cv_lib_soname_gnutls"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBGNUTLS \"$ac_cv_lib_soname_gnutls\"" >>confdefs.h
 
 
 fi
                  ac_wine_check_funcs_save_LIBS="$LIBS"
 LIBS="$LIBS $GNUTLS_LIBS"
-for ac_func in gnutls_cipher_init
+
+  for ac_func in gnutls_cipher_init
 do :
   ac_fn_c_check_func "$LINENO" "gnutls_cipher_init" "ac_cv_func_gnutls_cipher_init"
-if test "x$ac_cv_func_gnutls_cipher_init" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_GNUTLS_CIPHER_INIT 1
-_ACEOF
+if test "x$ac_cv_func_gnutls_cipher_init" = xyes
+then :
+  printf "%s\n" "#define HAVE_GNUTLS_CIPHER_INIT 1" >>confdefs.h
 
-else
+else $as_nop
   as_fn_append wine_notices "|libgnutls ${notice_platform}development files too old, bcrypt encryption won't be supported."
 fi
-done
 
+done
 LIBS="$ac_wine_check_funcs_save_LIBS"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+else $as_nop
   GNUTLS_CFLAGS=""
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_gnutls" = "x"; then :
+if test "x$ac_cv_lib_soname_gnutls" = "x"
+then :
   case "x$with_gnutls" in
   x)   as_fn_append wine_warnings "|libgnutls ${notice_platform}development files not found, no schannel support." ;;
   xno) ;;
@@ -13296,35 +15534,39 @@ fi
 
 if test "x$with_gnutls" != "xno"
 then
-    if ${GMP_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${GMP_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GMP_CFLAGS=`$PKG_CONFIG --cflags gmp 2>/dev/null`
 fi
 fi
 
-if ${GMP_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${GMP_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GMP_LIBS=`$PKG_CONFIG --libs gmp 2>/dev/null`
 fi
 fi
 
 GMP_LIBS=${GMP_LIBS:-"-lgmp"}
-$as_echo "$as_me:${as_lineno-$LINENO}: gmp cflags: $GMP_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: gmp libs: $GMP_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gmp cflags: $GMP_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gmp libs: $GMP_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $GMP_CFLAGS"
-for ac_header in gmp.h
+       for ac_header in gmp.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "gmp.h" "ac_cv_header_gmp_h" "$ac_includes_default"
-if test "x$ac_cv_header_gmp_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_GMP_H 1
-_ACEOF
- { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lgmp" >&5
-$as_echo_n "checking for -lgmp... " >&6; }
-if ${ac_cv_lib_soname_gmp+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  ac_fn_c_check_header_compile "$LINENO" "gmp.h" "ac_cv_header_gmp_h" "$ac_includes_default"
+if test "x$ac_cv_header_gmp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GMP_H 1" >>confdefs.h
+ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lgmp" >&5
+printf %s "checking for -lgmp... " >&6; }
+if test ${ac_cv_lib_soname_gmp+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lgmp $GMP_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13333,82 +15575,85 @@ LIBS="-lgmp $GMP_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char __gmpz_init ();
 int
-main ()
+main (void)
 {
 return __gmpz_init ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_gmp=`$ac_cv_path_LDD conftest.exe | grep "gmp" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_gmp=`$OTOOL -L conftest$ac_exeext | grep "libgmp-*\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libgmp-*\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_gmp=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libgmp-*\\.$LIBEXT" | sed -e "s/^.*\\[\\(libgmp-*\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_gmp:+false} :; then :
+       if ${ac_cv_lib_soname_gmp:+false} :
+then :
   ac_cv_lib_soname_gmp=`$LDD conftest$ac_exeext | grep "libgmp-*\\.$LIBEXT" | sed -e "s/^.*\(libgmp-*\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_gmp=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_gmp:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_gmp:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        GMP_CFLAGS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gmp" >&5
-$as_echo "$ac_cv_lib_soname_gmp" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gmp" >&5
+printf "%s\n" "$ac_cv_lib_soname_gmp" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBGMP "$ac_cv_lib_soname_gmp"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBGMP \"$ac_cv_lib_soname_gmp\"" >>confdefs.h
 
 
 fi
 fi
 
 done
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
 
 if test "x$with_sane" != "xno"
 then
-    if ${SANE_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${SANE_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   SANE_CFLAGS=`$PKG_CONFIG --cflags sane-backends 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || SANE_CFLAGS=${SANE_CFLAGS:-`${SANE_CONFIG:-sane-config} --cflags 2>/dev/null`}
-if ${SANE_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${SANE_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   SANE_LIBS=`$PKG_CONFIG --libs sane-backends 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || SANE_LIBS=${SANE_LIBS:-`${SANE_CONFIG:-sane-config} --ldflags 2>/dev/null`}
 
-$as_echo "$as_me:${as_lineno-$LINENO}: sane-backends cflags: $SANE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: sane-backends libs: $SANE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sane-backends cflags: $SANE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sane-backends libs: $SANE_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $SANE_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "sane/sane.h" "ac_cv_header_sane_sane_h" "$ac_includes_default"
-if test "x$ac_cv_header_sane_sane_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sane_init in -lsane" >&5
-$as_echo_n "checking for sane_init in -lsane... " >&6; }
-if ${ac_cv_lib_sane_sane_init+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+ac_fn_c_check_header_compile "$LINENO" "sane/sane.h" "ac_cv_header_sane_sane_h" "$ac_includes_default"
+if test "x$ac_cv_header_sane_sane_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sane_init in -lsane" >&5
+printf %s "checking for sane_init in -lsane... " >&6; }
+if test ${ac_cv_lib_sane_sane_init+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsane $SANE_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13417,40 +15662,39 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char sane_init ();
 int
-main ()
+main (void)
 {
 return sane_init ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_sane_sane_init=yes
-else
+else $as_nop
   ac_cv_lib_sane_sane_init=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sane_sane_init" >&5
-$as_echo "$ac_cv_lib_sane_sane_init" >&6; }
-if test "x$ac_cv_lib_sane_sane_init" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sane_sane_init" >&5
+printf "%s\n" "$ac_cv_lib_sane_sane_init" >&6; }
+if test "x$ac_cv_lib_sane_sane_init" = xyes
+then :
   :
 fi
 
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "$ac_cv_lib_sane_sane_init" != "yes"; then :
+if test "$ac_cv_lib_sane_sane_init" != "yes"
+then :
   case "x$with_sane" in
   x)   as_fn_append wine_notices "|libsane ${notice_platform}development files not found, scanners won't be supported." ;;
   xno) ;;
@@ -13462,30 +15706,36 @@ fi
 
 if test "x$with_usb" != "xno"
 then
-    if ${USB_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${USB_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   USB_CFLAGS=`$PKG_CONFIG --cflags libusb-1.0 2>/dev/null`
 fi
 fi
 
-if ${USB_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${USB_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   USB_LIBS=`$PKG_CONFIG --libs libusb-1.0 2>/dev/null`
 fi
 fi
 
 USB_LIBS=${USB_LIBS:-"-lusb-1.0"}
-$as_echo "$as_me:${as_lineno-$LINENO}: libusb-1.0 cflags: $USB_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libusb-1.0 libs: $USB_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libusb-1.0 cflags: $USB_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libusb-1.0 libs: $USB_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $USB_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "libusb.h" "ac_cv_header_libusb_h" "$ac_includes_default"
-if test "x$ac_cv_header_libusb_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for libusb_interrupt_event_handler in -lusb-1.0" >&5
-$as_echo_n "checking for libusb_interrupt_event_handler in -lusb-1.0... " >&6; }
-if ${ac_cv_lib_usb_1_0_libusb_interrupt_event_handler+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+ac_fn_c_check_header_compile "$LINENO" "libusb.h" "ac_cv_header_libusb_h" "$ac_includes_default"
+if test "x$ac_cv_header_libusb_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for libusb_interrupt_event_handler in -lusb-1.0" >&5
+printf %s "checking for libusb_interrupt_event_handler in -lusb-1.0... " >&6; }
+if test ${ac_cv_lib_usb_1_0_libusb_interrupt_event_handler+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lusb-1.0 $USB_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13494,44 +15744,43 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char libusb_interrupt_event_handler ();
 int
-main ()
+main (void)
 {
 return libusb_interrupt_event_handler ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_usb_1_0_libusb_interrupt_event_handler=yes
-else
+else $as_nop
   ac_cv_lib_usb_1_0_libusb_interrupt_event_handler=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" >&5
-$as_echo "$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" >&6; }
-if test "x$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" >&5
+printf "%s\n" "$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" >&6; }
+if test "x$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" = xyes
+then :
   :
-else
+else $as_nop
   USB_LIBS=""
 fi
 
-else
+else $as_nop
   USB_LIBS=""
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" != "yes"; then :
+if test "$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" != "yes"
+then :
   case "x$with_usb" in
   x)   as_fn_append wine_notices "|libusb-1.0 ${notice_platform}development files not found (or too old), USB devices won't be supported." ;;
   xno) ;;
@@ -13543,11 +15792,12 @@ fi
 
 if test "x$with_v4l2" != "xno"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lv4l2" >&5
-$as_echo_n "checking for -lv4l2... " >&6; }
-if ${ac_cv_lib_soname_v4l2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lv4l2" >&5
+printf %s "checking for -lv4l2... " >&6; }
+if test ${ac_cv_lib_soname_v4l2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lv4l2  $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13556,50 +15806,49 @@ LIBS="-lv4l2  $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char v4l2_open ();
 int
-main ()
+main (void)
 {
 return v4l2_open ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_v4l2=`$ac_cv_path_LDD conftest.exe | grep "v4l2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_v4l2=`$OTOOL -L conftest$ac_exeext | grep "libv4l2\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libv4l2\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_v4l2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libv4l2\\.$LIBEXT" | sed -e "s/^.*\\[\\(libv4l2\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_v4l2:+false} :; then :
+       if ${ac_cv_lib_soname_v4l2:+false} :
+then :
   ac_cv_lib_soname_v4l2=`$LDD conftest$ac_exeext | grep "libv4l2\\.$LIBEXT" | sed -e "s/^.*\(libv4l2\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_v4l2=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_v4l2:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_v4l2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_v4l2" >&5
-$as_echo "$ac_cv_lib_soname_v4l2" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_v4l2" >&5
+printf "%s\n" "$ac_cv_lib_soname_v4l2" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBV4L2 "$ac_cv_lib_soname_v4l2"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBV4L2 \"$ac_cv_lib_soname_v4l2\"" >>confdefs.h
 
 
 fi
 fi
-if test "x$ac_cv_lib_soname_v4l2" = "x"; then :
+if test "x$ac_cv_lib_soname_v4l2" = "x"
+then :
   case "x$with_v4l2" in
   x)   as_fn_append wine_notices "|libv4l2 ${notice_platform}development files not found." ;;
   xno) ;;
@@ -13611,30 +15860,36 @@ fi
 
 if test "x$with_gphoto" != "xno"
 then
-    if ${GPHOTO2_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${GPHOTO2_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GPHOTO2_CFLAGS=`$PKG_CONFIG --cflags libgphoto2 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || GPHOTO2_CFLAGS=${GPHOTO2_CFLAGS:-`${GPHOTO2_CONFIG:-gphoto2-config} --cflags 2>/dev/null`}
-if ${GPHOTO2_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${GPHOTO2_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GPHOTO2_LIBS=`$PKG_CONFIG --libs libgphoto2 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || GPHOTO2_LIBS=${GPHOTO2_LIBS:-`${GPHOTO2_CONFIG:-gphoto2-config} --libs 2>/dev/null`}
 GPHOTO2_LIBS=${GPHOTO2_LIBS:-"-lgphoto2"}
-$as_echo "$as_me:${as_lineno-$LINENO}: libgphoto2 cflags: $GPHOTO2_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libgphoto2 libs: $GPHOTO2_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2 cflags: $GPHOTO2_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2 libs: $GPHOTO2_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $GPHOTO2_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "gphoto2-camera.h" "ac_cv_header_gphoto2_camera_h" "$ac_includes_default"
-if test "x$ac_cv_header_gphoto2_camera_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gp_camera_new in -lgphoto2" >&5
-$as_echo_n "checking for gp_camera_new in -lgphoto2... " >&6; }
-if ${ac_cv_lib_gphoto2_gp_camera_new+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+ac_fn_c_check_header_compile "$LINENO" "gphoto2-camera.h" "ac_cv_header_gphoto2_camera_h" "$ac_includes_default"
+if test "x$ac_cv_header_gphoto2_camera_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gp_camera_new in -lgphoto2" >&5
+printf %s "checking for gp_camera_new in -lgphoto2... " >&6; }
+if test ${ac_cv_lib_gphoto2_gp_camera_new+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lgphoto2 $GPHOTO2_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13643,62 +15898,66 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gp_camera_new ();
 int
-main ()
+main (void)
 {
 return gp_camera_new ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_gphoto2_gp_camera_new=yes
-else
+else $as_nop
   ac_cv_lib_gphoto2_gp_camera_new=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gphoto2_gp_camera_new" >&5
-$as_echo "$ac_cv_lib_gphoto2_gp_camera_new" >&6; }
-if test "x$ac_cv_lib_gphoto2_gp_camera_new" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gphoto2_gp_camera_new" >&5
+printf "%s\n" "$ac_cv_lib_gphoto2_gp_camera_new" >&6; }
+if test "x$ac_cv_lib_gphoto2_gp_camera_new" = xyes
+then :
   :
 fi
 
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
-    if ${GPHOTO2_PORT_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${GPHOTO2_PORT_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GPHOTO2_PORT_CFLAGS=`$PKG_CONFIG --cflags libgphoto2_port 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || GPHOTO2_PORT_CFLAGS=${GPHOTO2_PORT_CFLAGS:-`${GPHOTO2_PORT_CONFIG:-gphoto2-port-config} --cflags 2>/dev/null`}
-if ${GPHOTO2_PORT_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${GPHOTO2_PORT_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GPHOTO2_PORT_LIBS=`$PKG_CONFIG --libs libgphoto2_port 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || GPHOTO2_PORT_LIBS=${GPHOTO2_PORT_LIBS:-`${GPHOTO2_PORT_CONFIG:-gphoto2-port-config} --libs 2>/dev/null`}
 GPHOTO2_PORT_LIBS=${GPHOTO2_PORT_LIBS:-"-lgphoto2_port"}
-$as_echo "$as_me:${as_lineno-$LINENO}: libgphoto2_port cflags: $GPHOTO2_PORT_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libgphoto2_port libs: $GPHOTO2_PORT_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2_port cflags: $GPHOTO2_PORT_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2_port libs: $GPHOTO2_PORT_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $GPHOTO2_PORT_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "gphoto2-port.h" "ac_cv_header_gphoto2_port_h" "$ac_includes_default"
-if test "x$ac_cv_header_gphoto2_port_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gp_port_info_list_new in -lgphoto2_port" >&5
-$as_echo_n "checking for gp_port_info_list_new in -lgphoto2_port... " >&6; }
-if ${ac_cv_lib_gphoto2_port_gp_port_info_list_new+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+ac_fn_c_check_header_compile "$LINENO" "gphoto2-port.h" "ac_cv_header_gphoto2_port_h" "$ac_includes_default"
+if test "x$ac_cv_header_gphoto2_port_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gp_port_info_list_new in -lgphoto2_port" >&5
+printf %s "checking for gp_port_info_list_new in -lgphoto2_port... " >&6; }
+if test ${ac_cv_lib_gphoto2_port_gp_port_info_list_new+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lgphoto2_port $GPHOTO2_PORT_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13707,46 +15966,45 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gp_port_info_list_new ();
 int
-main ()
+main (void)
 {
 return gp_port_info_list_new ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_gphoto2_port_gp_port_info_list_new=yes
-else
+else $as_nop
   ac_cv_lib_gphoto2_port_gp_port_info_list_new=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gphoto2_port_gp_port_info_list_new" >&5
-$as_echo "$ac_cv_lib_gphoto2_port_gp_port_info_list_new" >&6; }
-if test "x$ac_cv_lib_gphoto2_port_gp_port_info_list_new" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gphoto2_port_gp_port_info_list_new" >&5
+printf "%s\n" "$ac_cv_lib_gphoto2_port_gp_port_info_list_new" >&6; }
+if test "x$ac_cv_lib_gphoto2_port_gp_port_info_list_new" = xyes
+then :
 
-$as_echo "#define HAVE_GPHOTO2_PORT 1" >>confdefs.h
+printf "%s\n" "#define HAVE_GPHOTO2_PORT 1" >>confdefs.h
 
-else
+else $as_nop
   GPHOTO2_PORT_LIBS=""; GPHOTO2_PORT_CFLAGS=""
 fi
 
-else
+else $as_nop
   GPHOTO2_PORT_LIBS=""; GPHOTO2_PORT_CFLAGS=""
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "$ac_cv_lib_gphoto2_gp_camera_new" != "yes"; then :
+if test "$ac_cv_lib_gphoto2_gp_camera_new" != "yes"
+then :
   case "x$with_gphoto" in
   x)   as_fn_append wine_notices "|libgphoto2 ${notice_platform}development files not found, digital cameras won't be supported." ;;
   xno) ;;
@@ -13755,7 +16013,8 @@ This is an error since --with-gphoto was requested." "$LINENO" 5 ;;
 esac
 enable_gphoto2_ds=${enable_gphoto2_ds:-no}
 fi
-if test "$ac_cv_lib_gphoto2_port_gp_port_info_list_new" != "yes"; then :
+if test "$ac_cv_lib_gphoto2_port_gp_port_info_list_new" != "yes"
+then :
   case "x$with_gphoto" in
   x)   as_fn_append wine_notices "|libgphoto2_port ${notice_platform}development files not found, digital cameras won't be auto-detected." ;;
   xno) ;;
@@ -13768,11 +16027,12 @@ fi
 
 if test "$ac_cv_header_resolv_h" = "yes"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for resolver library" >&5
-$as_echo_n "checking for resolver library... " >&6; }
-if ${ac_cv_have_resolv+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for resolver library" >&5
+printf %s "checking for resolver library... " >&6; }
+if test ${ac_cv_have_resolv+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_save_LIBS="$LIBS"
        for lib in '' -lresolv
        do
@@ -13784,35 +16044,36 @@ else
 #endif
 #include <resolv.h>
 int
-main ()
+main (void)
 {
 if (!(_res.options & RES_INIT)) res_init(); res_query("foo",ns_c_in,0,0,0); ns_initparse(0,0,0)
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_have_resolv=${lib:-"none required"}
-else
+else $as_nop
   ac_cv_have_resolv="not found"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
          test "x$ac_cv_have_resolv" = "xnot found" || break
        done
        LIBS="$ac_save_LIBS"
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_resolv" >&5
-$as_echo "$ac_cv_have_resolv" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_resolv" >&5
+printf "%s\n" "$ac_cv_have_resolv" >&6; }
 
     case "$ac_cv_have_resolv" in
       "not found") ;;
       "none required")
 
-$as_echo "#define HAVE_RESOLV 1" >>confdefs.h
+printf "%s\n" "#define HAVE_RESOLV 1" >>confdefs.h
  ;;
       *)
-        $as_echo "#define HAVE_RESOLV 1" >>confdefs.h
+        printf "%s\n" "#define HAVE_RESOLV 1" >>confdefs.h
 
         RESOLV_LIBS=$ac_cv_have_resolv
  ;;
@@ -13820,39 +16081,41 @@ $as_echo "#define HAVE_RESOLV 1" >>confdefs.h
 
     if test "x$ac_cv_have_resolv" != "xnot found"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for res_getservers" >&5
-$as_echo_n "checking for res_getservers... " >&6; }
-if ${ac_cv_have_res_getservers+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for res_getservers" >&5
+printf %s "checking for res_getservers... " >&6; }
+if test ${ac_cv_have_res_getservers+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_save_LIBS="$LIBS"
                         LIBS="$RESOLV_LIBS $LIBS"
                         cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <resolv.h>
 int
-main ()
+main (void)
 {
 res_getservers(NULL, NULL, 0);
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_have_res_getservers=yes
-else
+else $as_nop
   ac_cv_have_res_getservers=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 	                 LIBS="$ac_save_LIBS"
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_res_getservers" >&5
-$as_echo "$ac_cv_have_res_getservers" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_res_getservers" >&5
+printf "%s\n" "$ac_cv_have_res_getservers" >&6; }
         if test "$ac_cv_have_res_getservers" = "yes"
         then
 
-$as_echo "#define HAVE_RES_GETSERVERS 1" >>confdefs.h
+printf "%s\n" "#define HAVE_RES_GETSERVERS 1" >>confdefs.h
 
         fi
     fi
@@ -13860,42 +16123,42 @@ fi
 
 if test "x$with_freetype" != "xno"
 then
-    if ${FREETYPE_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${FREETYPE_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   FREETYPE_CFLAGS=`$PKG_CONFIG --cflags freetype2 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || FREETYPE_CFLAGS=${FREETYPE_CFLAGS:-`(${FREETYPE_CONFIG:-freetype-config} --cflags || ${FREETYPE2_CONFIG:-freetype2-config} --cflags) 2>/dev/null`}
-if ${FREETYPE_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${FREETYPE_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   FREETYPE_LIBS=`$PKG_CONFIG --libs freetype2 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || FREETYPE_LIBS=${FREETYPE_LIBS:-`(${FREETYPE_CONFIG:-freetype-config} --libs || ${FREETYPE2_CONFIG:-freetype2-config} --libs) 2>/dev/null`}
 FREETYPE_LIBS=${FREETYPE_LIBS:-"-lfreetype"}
-$as_echo "$as_me:${as_lineno-$LINENO}: freetype2 cflags: $FREETYPE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: freetype2 libs: $FREETYPE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: freetype2 cflags: $FREETYPE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: freetype2 libs: $FREETYPE_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $FREETYPE_CFLAGS"
-for ac_header in ft2build.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "ft2build.h" "ac_cv_header_ft2build_h" "$ac_includes_default"
-if test "x$ac_cv_header_ft2build_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_FT2BUILD_H 1
-_ACEOF
+ac_fn_c_check_header_compile "$LINENO" "ft2build.h" "ac_cv_header_ft2build_h" "$ac_includes_default"
+if test "x$ac_cv_header_ft2build_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_FT2BUILD_H 1" >>confdefs.h
 
 fi
 
-done
-
         if test "$ac_cv_header_ft2build_h" = "yes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lfreetype" >&5
-$as_echo_n "checking for -lfreetype... " >&6; }
-if ${ac_cv_lib_soname_freetype+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lfreetype" >&5
+printf %s "checking for -lfreetype... " >&6; }
+if test ${ac_cv_lib_soname_freetype+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lfreetype $FREETYPE_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -13904,57 +16167,54 @@ LIBS="-lfreetype $FREETYPE_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char FT_Init_FreeType ();
 int
-main ()
+main (void)
 {
 return FT_Init_FreeType ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_freetype=`$ac_cv_path_LDD conftest.exe | grep "freetype" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_freetype=`$OTOOL -L conftest$ac_exeext | grep "libfreetype\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libfreetype\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_freetype=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libfreetype\\.$LIBEXT" | sed -e "s/^.*\\[\\(libfreetype\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_freetype:+false} :; then :
+       if ${ac_cv_lib_soname_freetype:+false} :
+then :
   ac_cv_lib_soname_freetype=`$LDD conftest$ac_exeext | grep "libfreetype\\.$LIBEXT" | sed -e "s/^.*\(libfreetype\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_freetype=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_freetype:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_freetype:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        FREETYPE_LIBS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_freetype" >&5
-$as_echo "$ac_cv_lib_soname_freetype" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_freetype" >&5
+printf "%s\n" "$ac_cv_lib_soname_freetype" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBFREETYPE "$ac_cv_lib_soname_freetype"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBFREETYPE \"$ac_cv_lib_soname_freetype\"" >>confdefs.h
 
 
-$as_echo "#define HAVE_FREETYPE 1" >>confdefs.h
+printf "%s\n" "#define HAVE_FREETYPE 1" >>confdefs.h
 
                  ac_fn_c_check_type "$LINENO" "FT_TrueTypeEngineType" "ac_cv_type_FT_TrueTypeEngineType" "#include <ft2build.h>
 #include FT_MODULE_H
 "
-if test "x$ac_cv_type_FT_TrueTypeEngineType" = xyes; then :
+if test "x$ac_cv_type_FT_TrueTypeEngineType" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_FT_TRUETYPEENGINETYPE 1
-_ACEOF
+printf "%s\n" "#define HAVE_FT_TRUETYPEENGINETYPE 1" >>confdefs.h
 
 
 fi
@@ -13967,7 +16227,8 @@ fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_freetype" = x; then :
+if test "x$ac_cv_lib_soname_freetype" = x
+then :
   case "x$with_freetype" in
   xno) ;;
   *)   as_fn_error $? "FreeType ${notice_platform}development files not found. Fonts will not be built.
@@ -13978,18 +16239,12 @@ fi
 
 ac_wine_check_funcs_save_LIBS="$LIBS"
 LIBS="$LIBS $PTHREAD_LIBS"
-for ac_func in \
-        pthread_getthreadid_np
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+ac_fn_c_check_func "$LINENO" "pthread_getthreadid_np" "ac_cv_func_pthread_getthreadid_np"
+if test "x$ac_cv_func_pthread_getthreadid_np" = xyes
+then :
+  printf "%s\n" "#define HAVE_PTHREAD_GETTHREADID_NP 1" >>confdefs.h
 
 fi
-done
 
 LIBS="$ac_wine_check_funcs_save_LIBS"
 
@@ -13997,11 +16252,12 @@ if test "x$enable_tools" != xno -a "x$with_gettextpo" = xyes
 then
     if test "$ac_cv_header_gettext_po_h" = "yes"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for po_message_msgctxt in -lgettextpo" >&5
-$as_echo_n "checking for po_message_msgctxt in -lgettextpo... " >&6; }
-if ${ac_cv_lib_gettextpo_po_message_msgctxt+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for po_message_msgctxt in -lgettextpo" >&5
+printf %s "checking for po_message_msgctxt in -lgettextpo... " >&6; }
+if test ${ac_cv_lib_gettextpo_po_message_msgctxt+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lgettextpo  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14010,39 +16266,39 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char po_message_msgctxt ();
 int
-main ()
+main (void)
 {
 return po_message_msgctxt ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_gettextpo_po_message_msgctxt=yes
-else
+else $as_nop
   ac_cv_lib_gettextpo_po_message_msgctxt=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gettextpo_po_message_msgctxt" >&5
-$as_echo "$ac_cv_lib_gettextpo_po_message_msgctxt" >&6; }
-if test "x$ac_cv_lib_gettextpo_po_message_msgctxt" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gettextpo_po_message_msgctxt" >&5
+printf "%s\n" "$ac_cv_lib_gettextpo_po_message_msgctxt" >&6; }
+if test "x$ac_cv_lib_gettextpo_po_message_msgctxt" = xyes
+then :
 
-$as_echo "#define HAVE_LIBGETTEXTPO 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LIBGETTEXTPO 1" >>confdefs.h
 
                       GETTEXTPO_LIBS="-lgettextpo"
 
 fi
 
     fi
-    if test "x$GETTEXTPO_LIBS" = "x"; then :
+    if test "x$GETTEXTPO_LIBS" = "x"
+then :
   case "x$with_gettextpo" in
   x)   as_fn_append wine_notices "|GetText ${notice_platform}development files not found (or too old), po files can't be rebuilt." ;;
   xno) ;;
@@ -14051,7 +16307,8 @@ This is an error since --with-gettextpo was requested." "$LINENO" 5 ;;
 esac
 
 fi
-    if test "$srcdir" != .; then :
+    if test "$srcdir" != .
+then :
   case "x$with_gettextpo" in
   x)   as_fn_append wine_notices "|Rebuilding po files is not supported for out of tree builds." ;;
   xno) ;;
@@ -14064,35 +16321,39 @@ fi
 
 if test "x$with_pulse" != "xno";
 then
-    if ${PULSE_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${PULSE_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   PULSE_CFLAGS=`$PKG_CONFIG --cflags libpulse 2>/dev/null`
 fi
 fi
 
-if ${PULSE_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${PULSE_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   PULSE_LIBS=`$PKG_CONFIG --libs libpulse 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: libpulse cflags: $PULSE_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libpulse libs: $PULSE_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libpulse cflags: $PULSE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libpulse libs: $PULSE_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $PULSE_CFLAGS"
-for ac_header in pulse/pulseaudio.h
+       for ac_header in pulse/pulseaudio.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "pulse/pulseaudio.h" "ac_cv_header_pulse_pulseaudio_h" "$ac_includes_default"
-if test "x$ac_cv_header_pulse_pulseaudio_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_PULSE_PULSEAUDIO_H 1
-_ACEOF
- { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pa_stream_is_corked in -lpulse" >&5
-$as_echo_n "checking for pa_stream_is_corked in -lpulse... " >&6; }
-if ${ac_cv_lib_pulse_pa_stream_is_corked+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  ac_fn_c_check_header_compile "$LINENO" "pulse/pulseaudio.h" "ac_cv_header_pulse_pulseaudio_h" "$ac_includes_default"
+if test "x$ac_cv_header_pulse_pulseaudio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PULSE_PULSEAUDIO_H 1" >>confdefs.h
+ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pa_stream_is_corked in -lpulse" >&5
+printf %s "checking for pa_stream_is_corked in -lpulse... " >&6; }
+if test ${ac_cv_lib_pulse_pa_stream_is_corked+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lpulse $PULSE_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14101,45 +16362,44 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char pa_stream_is_corked ();
 int
-main ()
+main (void)
 {
 return pa_stream_is_corked ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_pulse_pa_stream_is_corked=yes
-else
+else $as_nop
   ac_cv_lib_pulse_pa_stream_is_corked=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pulse_pa_stream_is_corked" >&5
-$as_echo "$ac_cv_lib_pulse_pa_stream_is_corked" >&6; }
-if test "x$ac_cv_lib_pulse_pa_stream_is_corked" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pulse_pa_stream_is_corked" >&5
+printf "%s\n" "$ac_cv_lib_pulse_pa_stream_is_corked" >&6; }
+if test "x$ac_cv_lib_pulse_pa_stream_is_corked" = xyes
+then :
   :
-else
+else $as_nop
   PULSE_LIBS=""
 fi
 
-else
+else $as_nop
   PULSE_LIBS=""
 fi
 
 done
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test -z "$PULSE_LIBS"; then :
+if test -z "$PULSE_LIBS"
+then :
   case "x$with_pulse" in
   x)   as_fn_append wine_notices "|libpulse ${notice_platform}development files not found or too old, Pulse won't be supported." ;;
   xno) ;;
@@ -14151,46 +16411,53 @@ fi
 
 if test "x$with_gstreamer" != "xno"
 then
-    if ${GSTREAMER_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${GSTREAMER_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GSTREAMER_CFLAGS=`$PKG_CONFIG --cflags gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 2>/dev/null`
 fi
 fi
 
-if ${GSTREAMER_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${GSTREAMER_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GSTREAMER_LIBS=`$PKG_CONFIG --libs gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 cflags: $GSTREAMER_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 libs: $GSTREAMER_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 cflags: $GSTREAMER_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 libs: $GSTREAMER_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $GSTREAMER_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "gst/gst.h" "ac_cv_header_gst_gst_h" "$ac_includes_default"
-if test "x$ac_cv_header_gst_gst_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether gint64 defined by gst/gst.h is indeed 64-bit" >&5
-$as_echo_n "checking whether gint64 defined by gst/gst.h is indeed 64-bit... " >&6; }
+ac_fn_c_check_header_compile "$LINENO" "gst/gst.h" "ac_cv_header_gst_gst_h" "$ac_includes_default"
+if test "x$ac_cv_header_gst_gst_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether gint64 defined by gst/gst.h is indeed 64-bit" >&5
+printf %s "checking whether gint64 defined by gst/gst.h is indeed 64-bit... " >&6; }
               cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <gst/gst.h>
 int
-main ()
+main (void)
 {
 static int a[sizeof(gint64) > 4 ? 1 : -1]; if (a[0]) return 0;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-                 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gst_pad_new in -lgstreamer-1.0" >&5
-$as_echo_n "checking for gst_pad_new in -lgstreamer-1.0... " >&6; }
-if ${ac_cv_lib_gstreamer_1_0_gst_pad_new+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
+                 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gst_pad_new in -lgstreamer-1.0" >&5
+printf %s "checking for gst_pad_new in -lgstreamer-1.0... " >&6; }
+if test ${ac_cv_lib_gstreamer_1_0_gst_pad_new+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lgstreamer-1.0 $GSTREAMER_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14199,49 +16466,48 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gst_pad_new ();
 int
-main ()
+main (void)
 {
 return gst_pad_new ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_gstreamer_1_0_gst_pad_new=yes
-else
+else $as_nop
   ac_cv_lib_gstreamer_1_0_gst_pad_new=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gstreamer_1_0_gst_pad_new" >&5
-$as_echo "$ac_cv_lib_gstreamer_1_0_gst_pad_new" >&6; }
-if test "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gstreamer_1_0_gst_pad_new" >&5
+printf "%s\n" "$ac_cv_lib_gstreamer_1_0_gst_pad_new" >&6; }
+if test "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" = xyes
+then :
   :
 fi
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
                  ac_glib2_broken=yes
                  as_fn_append wine_notices "|glib-2.0 pkgconfig configuration is for the wrong architecture, winegstreamer won't be built."
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
 if test "x$with_gstreamer" = xyes -o "x$with_quicktime" = xno -o "x$ac_cv_header_QuickTime_ImageCompression_h" != xyes
 then
-    if test "x$ac_glib2_broken" != xyes -a "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" != xyes; then :
+    if test "x$ac_glib2_broken" != xyes -a "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" != xyes
+then :
   case "x$with_gstreamer" in
   x)   as_fn_append wine_notices "|gstreamer-1.0 base plugins ${notice_platform}development files not found, GStreamer won't be supported." ;;
   xno) ;;
@@ -14257,11 +16523,12 @@ ALSA_LIBS=""
 
 if test "x$with_alsa" != "xno"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for snd_pcm_hw_params_get_access_mask in -lasound" >&5
-$as_echo_n "checking for snd_pcm_hw_params_get_access_mask in -lasound... " >&6; }
-if ${ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for snd_pcm_hw_params_get_access_mask in -lasound" >&5
+printf %s "checking for snd_pcm_hw_params_get_access_mask in -lasound... " >&6; }
+if test ${ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lasound  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14269,46 +16536,46 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
+   builtin and then its argument prototype would still apply.  */
 char snd_pcm_hw_params_get_access_mask ();
 int
-main ()
+main (void)
 {
 return snd_pcm_hw_params_get_access_mask ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask=yes
-else
+else $as_nop
   ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" >&5
-$as_echo "$ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" >&6; }
-if test "x$ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" >&5
+printf "%s\n" "$ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" >&6; }
+if test "x$ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" = xyes
+then :
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <alsa/asoundlib.h>
 int
-main ()
+main (void)
 {
 snd_pcm_hw_params_get_access_mask(NULL, NULL)
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ALSA_LIBS="-lasound"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 fi
@@ -14323,23 +16590,24 @@ then
     fi
     ac_oss_incl="-I${OSSLIBDIR:-/usr/lib/oss}/include"
     CPPFLAGS="$CPPFLAGS $ac_oss_incl"
-    ac_fn_c_check_header_mongrel "$LINENO" "sys/soundcard.h" "ac_cv_header_sys_soundcard_h" "$ac_includes_default"
-if test "x$ac_cv_header_sys_soundcard_h" = xyes; then :
+    ac_fn_c_check_header_compile "$LINENO" "sys/soundcard.h" "ac_cv_header_sys_soundcard_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_soundcard_h" = xyes
+then :
   ac_fn_c_check_member "$LINENO" "oss_sysinfo" "numaudioengines" "ac_cv_member_oss_sysinfo_numaudioengines" "#include <sys/soundcard.h>
 "
-if test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes; then :
+if test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_OSS_SYSINFO_NUMAUDIOENGINES 1
-_ACEOF
+printf "%s\n" "#define HAVE_OSS_SYSINFO_NUMAUDIOENGINES 1" >>confdefs.h
 
 OSS4_CFLAGS="$ac_oss_incl"
 
-             { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _oss_ioctl in -lossaudio" >&5
-$as_echo_n "checking for _oss_ioctl in -lossaudio... " >&6; }
-if ${ac_cv_lib_ossaudio__oss_ioctl+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+             { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for _oss_ioctl in -lossaudio" >&5
+printf %s "checking for _oss_ioctl in -lossaudio... " >&6; }
+if test ${ac_cv_lib_ossaudio__oss_ioctl+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lossaudio  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14348,30 +16616,29 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char _oss_ioctl ();
 int
-main ()
+main (void)
 {
 return _oss_ioctl ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_ossaudio__oss_ioctl=yes
-else
+else $as_nop
   ac_cv_lib_ossaudio__oss_ioctl=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ossaudio__oss_ioctl" >&5
-$as_echo "$ac_cv_lib_ossaudio__oss_ioctl" >&6; }
-if test "x$ac_cv_lib_ossaudio__oss_ioctl" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ossaudio__oss_ioctl" >&5
+printf "%s\n" "$ac_cv_lib_ossaudio__oss_ioctl" >&6; }
+if test "x$ac_cv_lib_ossaudio__oss_ioctl" = xyes
+then :
   OSS4_LIBS="-lossaudio"
 
 fi
@@ -14380,10 +16647,10 @@ fi
 
 fi
 
-
     CPPFLAGS="$ac_save_CPPFLAGS"
 fi
-if test "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes; then :
+if test "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes
+then :
   case "x$with_oss" in
   x)   as_fn_append wine_notices "|OSS sound system found but too old (OSSv4 needed), OSS won't be supported." ;;
   xno) ;;
@@ -14395,35 +16662,39 @@ fi
 
 if test "x$with_udev" != "xno"
 then
-    if ${UDEV_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${UDEV_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   UDEV_CFLAGS=`$PKG_CONFIG --cflags libudev 2>/dev/null`
 fi
 fi
 
-if ${UDEV_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${UDEV_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   UDEV_LIBS=`$PKG_CONFIG --libs libudev 2>/dev/null`
 fi
 fi
 
 UDEV_LIBS=${UDEV_LIBS:-"-ludev"}
-$as_echo "$as_me:${as_lineno-$LINENO}: libudev cflags: $UDEV_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libudev libs: $UDEV_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libudev cflags: $UDEV_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libudev libs: $UDEV_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $UDEV_CFLAGS"
-for ac_header in libudev.h
+       for ac_header in libudev.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "libudev.h" "ac_cv_header_libudev_h" "$ac_includes_default"
-if test "x$ac_cv_header_libudev_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBUDEV_H 1
-_ACEOF
- { $as_echo "$as_me:${as_lineno-$LINENO}: checking for udev_new in -ludev" >&5
-$as_echo_n "checking for udev_new in -ludev... " >&6; }
-if ${ac_cv_lib_udev_udev_new+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  ac_fn_c_check_header_compile "$LINENO" "libudev.h" "ac_cv_header_libudev_h" "$ac_includes_default"
+if test "x$ac_cv_header_libudev_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBUDEV_H 1" >>confdefs.h
+ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for udev_new in -ludev" >&5
+printf %s "checking for udev_new in -ludev... " >&6; }
+if test ${ac_cv_lib_udev_udev_new+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ludev $UDEV_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14432,47 +16703,46 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char udev_new ();
 int
-main ()
+main (void)
 {
 return udev_new ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_udev_udev_new=yes
-else
+else $as_nop
   ac_cv_lib_udev_udev_new=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_udev_udev_new" >&5
-$as_echo "$ac_cv_lib_udev_udev_new" >&6; }
-if test "x$ac_cv_lib_udev_udev_new" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_udev_udev_new" >&5
+printf "%s\n" "$ac_cv_lib_udev_udev_new" >&6; }
+if test "x$ac_cv_lib_udev_udev_new" = xyes
+then :
 
-$as_echo "#define HAVE_UDEV 1" >>confdefs.h
+printf "%s\n" "#define HAVE_UDEV 1" >>confdefs.h
 
-else
+else $as_nop
   UDEV_LIBS=""
 fi
 
-else
+else $as_nop
   UDEV_LIBS=""
 fi
 
 done
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$UDEV_LIBS" = "x"; then :
+if test "x$UDEV_LIBS" = "x"
+then :
   case "x$with_udev" in
   x)   as_fn_append wine_notices "|libudev ${notice_platform}development files not found, plug and play won't be supported." ;;
   xno) ;;
@@ -14484,89 +16754,97 @@ fi
 
 if test "x$with_unwind" != xno
 then
-    if ${UNWIND_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${UNWIND_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   UNWIND_CFLAGS=`$PKG_CONFIG --cflags libunwind 2>/dev/null`
 fi
 fi
 
-if ${UNWIND_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${UNWIND_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   UNWIND_LIBS=`$PKG_CONFIG --libs libunwind 2>/dev/null`
 fi
 fi
 
 UNWIND_LIBS=${UNWIND_LIBS:-"-lunwind"}
-$as_echo "$as_me:${as_lineno-$LINENO}: libunwind cflags: $UNWIND_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libunwind libs: $UNWIND_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libunwind cflags: $UNWIND_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libunwind libs: $UNWIND_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $UNWIND_CFLAGS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for unw_step" >&5
-$as_echo_n "checking for unw_step... " >&6; }
-if ${wine_cv_have_unw_step+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for unw_step" >&5
+printf %s "checking for unw_step... " >&6; }
+if test ${wine_cv_have_unw_step+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #define UNW_LOCAL_ONLY
 #include <libunwind.h>
 int
-main ()
+main (void)
 {
 unw_cursor_t cursor; unw_step( &cursor );
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_have_unw_step="yes"
-else
+else $as_nop
   wine_cv_have_unw_step="no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_unw_step" >&5
-$as_echo "$wine_cv_have_unw_step" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_unw_step" >&5
+printf "%s\n" "$wine_cv_have_unw_step" >&6; }
         if test "$wine_cv_have_unw_step" = no -a -n "$UNWIND_LIBS"
         then
             save_libs=$LIBS
                         UNWIND_LIBS="-static-libgcc $UNWIND_LIBS"
             LIBS="$UNWIND_LIBS $LIBS"
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for unw_step in libunwind" >&5
-$as_echo_n "checking for unw_step in libunwind... " >&6; }
-if ${wine_cv_have_libunwind_unw_step+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for unw_step in libunwind" >&5
+printf %s "checking for unw_step in libunwind... " >&6; }
+if test ${wine_cv_have_libunwind_unw_step+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #define UNW_LOCAL_ONLY
 #include <libunwind.h>
 int
-main ()
+main (void)
 {
 unw_cursor_t cursor; unw_step( &cursor );
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_have_libunwind_unw_step="yes"
-else
+else $as_nop
   wine_cv_have_libunwind_unw_step="no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_libunwind_unw_step" >&5
-$as_echo "$wine_cv_have_libunwind_unw_step" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_libunwind_unw_step" >&5
+printf "%s\n" "$wine_cv_have_libunwind_unw_step" >&6; }
             LIBS=$save_libs
         fi
         test "$wine_cv_have_libunwind_unw_step" = yes || UNWIND_LIBS=""
         if test "x$wine_cv_have_unw_step$wine_cv_have_libunwind_unw_step" != xnono
         then
 
-$as_echo "#define HAVE_LIBUNWIND 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LIBUNWIND 1" >>confdefs.h
 
         fi
 CPPFLAGS=$ac_save_CPPFLAGS
@@ -14574,7 +16852,8 @@ CPPFLAGS=$ac_save_CPPFLAGS
 fi
 case $host in
   aarch64*|*-darwin*)
-    if test "x$wine_cv_have_unw_step$wine_cv_have_libunwind_unw_step" = xnono; then :
+    if test "x$wine_cv_have_unw_step$wine_cv_have_libunwind_unw_step" = xnono
+then :
   case "x$with_unwind" in
   x)   as_fn_append wine_notices "|libunwind ${notice_platform}development files not found, stack unwinding won't work." ;;
   xno) ;;
@@ -14587,35 +16866,39 @@ esac
 
 if test "x$with_sdl" != "xno"
 then
-    if ${SDL2_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${SDL2_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   SDL2_CFLAGS=`$PKG_CONFIG --cflags sdl2 2>/dev/null`
 fi
 fi
 
-if ${SDL2_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${SDL2_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   SDL2_LIBS=`$PKG_CONFIG --libs sdl2 2>/dev/null`
 fi
 fi
 
 SDL2_LIBS=${SDL2_LIBS:-"-lSDL2"}
-$as_echo "$as_me:${as_lineno-$LINENO}: sdl2 cflags: $SDL2_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: sdl2 libs: $SDL2_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sdl2 cflags: $SDL2_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sdl2 libs: $SDL2_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $SDL2_CFLAGS"
-for ac_header in SDL.h
+       for ac_header in SDL.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "SDL.h" "ac_cv_header_SDL_h" "$ac_includes_default"
-if test "x$ac_cv_header_SDL_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_SDL_H 1
-_ACEOF
- { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lSDL2" >&5
-$as_echo_n "checking for -lSDL2... " >&6; }
-if ${ac_cv_lib_soname_SDL2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  ac_fn_c_check_header_compile "$LINENO" "SDL.h" "ac_cv_header_SDL_h" "$ac_includes_default"
+if test "x$ac_cv_header_SDL_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SDL_H 1" >>confdefs.h
+ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lSDL2" >&5
+printf %s "checking for -lSDL2... " >&6; }
+if test ${ac_cv_lib_soname_SDL2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lSDL2 $SDL2_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14624,56 +16907,54 @@ LIBS="-lSDL2 $SDL2_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char SDL_Init ();
 int
-main ()
+main (void)
 {
 return SDL_Init ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_SDL2=`$ac_cv_path_LDD conftest.exe | grep "SDL2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_SDL2=`$OTOOL -L conftest$ac_exeext | grep "libSDL2-2.0*\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libSDL2-2.0*\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_SDL2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libSDL2-2.0*\\.$LIBEXT" | sed -e "s/^.*\\[\\(libSDL2-2.0*\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_SDL2:+false} :; then :
+       if ${ac_cv_lib_soname_SDL2:+false} :
+then :
   ac_cv_lib_soname_SDL2=`$LDD conftest$ac_exeext | grep "libSDL2-2.0*\\.$LIBEXT" | sed -e "s/^.*\(libSDL2-2.0*\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_SDL2=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_SDL2:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_SDL2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_SDL2" >&5
-$as_echo "$ac_cv_lib_soname_SDL2" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_SDL2" >&5
+printf "%s\n" "$ac_cv_lib_soname_SDL2" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBSDL2 "$ac_cv_lib_soname_SDL2"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBSDL2 \"$ac_cv_lib_soname_SDL2\"" >>confdefs.h
 
 
 fi
 fi
 
 done
-
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_SDL2" = "x"; then :
+if test "x$ac_cv_lib_soname_SDL2" = "x"
+then :
   case "x$with_sdl" in
   x)   as_fn_append wine_notices "|libSDL2 ${notice_platform}development files not found, SDL2 won't be supported." ;;
   xno) ;;
@@ -14685,44 +16966,50 @@ fi
 
 if test "x$with_capi" != "xno"
 then
-    if ${CAPI20_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${CAPI20_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   CAPI20_CFLAGS=`$PKG_CONFIG --cflags capi20 2>/dev/null`
 fi
 fi
 
-if ${CAPI20_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${CAPI20_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   CAPI20_LIBS=`$PKG_CONFIG --libs capi20 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: capi20 cflags: $CAPI20_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: capi20 libs: $CAPI20_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: capi20 cflags: $CAPI20_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: capi20 libs: $CAPI20_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $CAPI20_CFLAGS"
-    for ac_header in capi20.h linux/capi.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "#define __user
+    ac_fn_c_check_header_compile "$LINENO" "capi20.h" "ac_cv_header_capi20_h" "#define __user
 "
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+if test "x$ac_cv_header_capi20_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CAPI20_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "linux/capi.h" "ac_cv_header_linux_capi_h" "#define __user
+"
+if test "x$ac_cv_header_linux_capi_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_CAPI_H 1" >>confdefs.h
 
-done
+fi
 
     if test "$ac_cv_header_capi20_h" = "yes" -a "$ac_cv_header_linux_capi_h" = "yes"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for capi20_register in -lcapi20" >&5
-$as_echo_n "checking for capi20_register in -lcapi20... " >&6; }
-if ${ac_cv_lib_capi20_capi20_register+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for capi20_register in -lcapi20" >&5
+printf %s "checking for capi20_register in -lcapi20... " >&6; }
+if test ${ac_cv_lib_capi20_capi20_register+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lcapi20 $CAPI20_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14731,32 +17018,31 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char capi20_register ();
 int
-main ()
+main (void)
 {
 return capi20_register ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_capi20_capi20_register=yes
-else
+else $as_nop
   ac_cv_lib_capi20_capi20_register=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_capi20_capi20_register" >&5
-$as_echo "$ac_cv_lib_capi20_capi20_register" >&6; }
-if test "x$ac_cv_lib_capi20_capi20_register" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_capi20_capi20_register" >&5
+printf "%s\n" "$ac_cv_lib_capi20_capi20_register" >&6; }
+if test "x$ac_cv_lib_capi20_capi20_register" = xyes
+then :
   :
-else
+else $as_nop
   CAPI20_LIBS=""
 fi
 
@@ -14764,7 +17050,8 @@ fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_capi20_capi20_register" = "x"; then :
+if test "x$ac_cv_lib_capi20_capi20_register" = "x"
+then :
   case "x$with_capi" in
   x)   as_fn_append wine_notices "|libcapi20 ${notice_platform}development files not found, ISDN won't be supported." ;;
   xno) ;;
@@ -14776,43 +17063,48 @@ fi
 
 if test "x$with_cups" != "xno"
 then
-    if ${CUPS_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${CUPS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   CUPS_CFLAGS=`$PKG_CONFIG --cflags cups 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || CUPS_CFLAGS=${CUPS_CFLAGS:-`${CUPS_CONFIG:-cups-config} --cflags 2>/dev/null`}
-if ${CUPS_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${CUPS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   CUPS_LIBS=`$PKG_CONFIG --libs cups 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || CUPS_LIBS=${CUPS_LIBS:-`${CUPS_CONFIG:-cups-config} --libs 2>/dev/null`}
 CUPS_LIBS=${CUPS_LIBS:-"-lcups"}
-$as_echo "$as_me:${as_lineno-$LINENO}: cups cflags: $CUPS_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: cups libs: $CUPS_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: cups cflags: $CUPS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: cups libs: $CUPS_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $CUPS_CFLAGS"
-for ac_header in cups/cups.h cups/ppd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+ac_fn_c_check_header_compile "$LINENO" "cups/cups.h" "ac_cv_header_cups_cups_h" "$ac_includes_default"
+if test "x$ac_cv_header_cups_cups_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CUPS_CUPS_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "cups/ppd.h" "ac_cv_header_cups_ppd_h" "$ac_includes_default"
+if test "x$ac_cv_header_cups_ppd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CUPS_PPD_H 1" >>confdefs.h
 
-done
+fi
 
                         if test "$ac_cv_header_cups_cups_h" = "yes"
                         then
-                            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lcups" >&5
-$as_echo_n "checking for -lcups... " >&6; }
-if ${ac_cv_lib_soname_cups+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lcups" >&5
+printf %s "checking for -lcups... " >&6; }
+if test ${ac_cv_lib_soname_cups+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lcups $CUPS_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14821,45 +17113,43 @@ LIBS="-lcups $CUPS_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char cupsGetDefault ();
 int
-main ()
+main (void)
 {
 return cupsGetDefault ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_cups=`$ac_cv_path_LDD conftest.exe | grep "cups" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_cups=`$OTOOL -L conftest$ac_exeext | grep "libcups\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libcups\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_cups=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libcups\\.$LIBEXT" | sed -e "s/^.*\\[\\(libcups\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_cups:+false} :; then :
+       if ${ac_cv_lib_soname_cups:+false} :
+then :
   ac_cv_lib_soname_cups=`$LDD conftest$ac_exeext | grep "libcups\\.$LIBEXT" | sed -e "s/^.*\(libcups\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_cups=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_cups:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_cups:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        CUPS_LIBS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_cups" >&5
-$as_echo "$ac_cv_lib_soname_cups" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_cups" >&5
+printf "%s\n" "$ac_cv_lib_soname_cups" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBCUPS "$ac_cv_lib_soname_cups"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBCUPS \"$ac_cv_lib_soname_cups\"" >>confdefs.h
 
 
 fi
@@ -14870,7 +17160,8 @@ fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_cups" = "x"; then :
+if test "x$ac_cv_lib_soname_cups" = "x"
+then :
   case "x$with_cups" in
   x)   as_fn_append wine_notices "|libcups ${notice_platform}development files not found, CUPS won't be supported." ;;
   xno) ;;
@@ -14882,42 +17173,42 @@ fi
 
 if test "x$with_fontconfig" != "xno"
 then
-    if ${FONTCONFIG_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${FONTCONFIG_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   FONTCONFIG_CFLAGS=`$PKG_CONFIG --cflags fontconfig 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || FONTCONFIG_CFLAGS=${FONTCONFIG_CFLAGS:-$X_CFLAGS}
-if ${FONTCONFIG_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${FONTCONFIG_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   FONTCONFIG_LIBS=`$PKG_CONFIG --libs fontconfig 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || FONTCONFIG_LIBS=${FONTCONFIG_LIBS:-$X_LIBS}
 
-$as_echo "$as_me:${as_lineno-$LINENO}: fontconfig cflags: $FONTCONFIG_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: fontconfig libs: $FONTCONFIG_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: fontconfig cflags: $FONTCONFIG_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: fontconfig libs: $FONTCONFIG_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $FONTCONFIG_CFLAGS"
-for ac_header in fontconfig/fontconfig.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "fontconfig/fontconfig.h" "ac_cv_header_fontconfig_fontconfig_h" "$ac_includes_default"
-if test "x$ac_cv_header_fontconfig_fontconfig_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_FONTCONFIG_FONTCONFIG_H 1
-_ACEOF
+ac_fn_c_check_header_compile "$LINENO" "fontconfig/fontconfig.h" "ac_cv_header_fontconfig_fontconfig_h" "$ac_includes_default"
+if test "x$ac_cv_header_fontconfig_fontconfig_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_FONTCONFIG_FONTCONFIG_H 1" >>confdefs.h
 
 fi
 
-done
-
         if test "$ac_cv_header_fontconfig_fontconfig_h" = "yes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lfontconfig" >&5
-$as_echo_n "checking for -lfontconfig... " >&6; }
-if ${ac_cv_lib_soname_fontconfig+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lfontconfig" >&5
+printf %s "checking for -lfontconfig... " >&6; }
+if test ${ac_cv_lib_soname_fontconfig+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lfontconfig $FONTCONFIG_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -14926,45 +17217,43 @@ LIBS="-lfontconfig $FONTCONFIG_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char FcInit ();
 int
-main ()
+main (void)
 {
 return FcInit ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_fontconfig=`$ac_cv_path_LDD conftest.exe | grep "fontconfig" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_fontconfig=`$OTOOL -L conftest$ac_exeext | grep "libfontconfig\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libfontconfig\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_fontconfig=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libfontconfig\\.$LIBEXT" | sed -e "s/^.*\\[\\(libfontconfig\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_fontconfig:+false} :; then :
+       if ${ac_cv_lib_soname_fontconfig:+false} :
+then :
   ac_cv_lib_soname_fontconfig=`$LDD conftest$ac_exeext | grep "libfontconfig\\.$LIBEXT" | sed -e "s/^.*\(libfontconfig\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_fontconfig=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_fontconfig:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_fontconfig:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        FONTCONFIG_CFLAGS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_fontconfig" >&5
-$as_echo "$ac_cv_lib_soname_fontconfig" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_fontconfig" >&5
+printf "%s\n" "$ac_cv_lib_soname_fontconfig" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBFONTCONFIG "$ac_cv_lib_soname_fontconfig"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBFONTCONFIG \"$ac_cv_lib_soname_fontconfig\"" >>confdefs.h
 
 
 fi
@@ -14974,7 +17263,8 @@ fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_fontconfig" = "x"; then :
+if test "x$ac_cv_lib_soname_fontconfig" = "x"
+then :
   case "x$with_fontconfig" in
   x)   as_fn_append wine_notices "|fontconfig ${notice_platform}development files not found, fontconfig won't be supported." ;;
   xno) ;;
@@ -14986,42 +17276,42 @@ fi
 
 if test "x$with_krb5" != "xno"
 then
-    if ${KRB5_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${KRB5_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   KRB5_CFLAGS=`$PKG_CONFIG --cflags krb5 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || KRB5_CFLAGS=${KRB5_CFLAGS:-`${KRB5_CONFIG:-krb5-config} --cflags 2>/dev/null`}
-if ${KRB5_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${KRB5_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   KRB5_LIBS=`$PKG_CONFIG --libs krb5 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || KRB5_LIBS=${KRB5_LIBS:-`${KRB5_CONFIG:-krb5-config} --libs 2>/dev/null`}
 
-$as_echo "$as_me:${as_lineno-$LINENO}: krb5 cflags: $KRB5_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: krb5 libs: $KRB5_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5 cflags: $KRB5_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5 libs: $KRB5_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $KRB5_CFLAGS"
-for ac_header in krb5/krb5.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "krb5/krb5.h" "ac_cv_header_krb5_krb5_h" "$ac_includes_default"
-if test "x$ac_cv_header_krb5_krb5_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_KRB5_KRB5_H 1
-_ACEOF
+ac_fn_c_check_header_compile "$LINENO" "krb5/krb5.h" "ac_cv_header_krb5_krb5_h" "$ac_includes_default"
+if test "x$ac_cv_header_krb5_krb5_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_KRB5_KRB5_H 1" >>confdefs.h
 
 fi
 
-done
-
          if test "$ac_cv_header_krb5_krb5_h" = "yes"
          then
-             { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lkrb5" >&5
-$as_echo_n "checking for -lkrb5... " >&6; }
-if ${ac_cv_lib_soname_krb5+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+             { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lkrb5" >&5
+printf %s "checking for -lkrb5... " >&6; }
+if test ${ac_cv_lib_soname_krb5+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lkrb5 $KRB5_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15030,45 +17320,43 @@ LIBS="-lkrb5 $KRB5_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char krb5_is_config_principal ();
 int
-main ()
+main (void)
 {
 return krb5_is_config_principal ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_krb5=`$ac_cv_path_LDD conftest.exe | grep "krb5" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_krb5=`$OTOOL -L conftest$ac_exeext | grep "libkrb5\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libkrb5\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_krb5=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libkrb5\\.$LIBEXT" | sed -e "s/^.*\\[\\(libkrb5\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_krb5:+false} :; then :
+       if ${ac_cv_lib_soname_krb5:+false} :
+then :
   ac_cv_lib_soname_krb5=`$LDD conftest$ac_exeext | grep "libkrb5\\.$LIBEXT" | sed -e "s/^.*\(libkrb5\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_krb5=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_krb5:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_krb5:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        KRB5_CFLAGS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_krb5" >&5
-$as_echo "$ac_cv_lib_soname_krb5" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_krb5" >&5
+printf "%s\n" "$ac_cv_lib_soname_krb5" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBKRB5 "$ac_cv_lib_soname_krb5"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBKRB5 \"$ac_cv_lib_soname_krb5\"" >>confdefs.h
 
 
 fi
@@ -15078,7 +17366,8 @@ fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_krb5" = "x"; then :
+if test "x$ac_cv_lib_soname_krb5" = "x"
+then :
   case "x$with_krb5" in
   x)   as_fn_append wine_notices "|libkrb5 ${notice_platform}development files not found (or too old), Kerberos won't be supported." ;;
   xno) ;;
@@ -15091,43 +17380,48 @@ test "x$ac_cv_lib_soname_krb5" != "x" || with_gssapi=${with_gssapi:-no}
 
 if test "x$with_gssapi" != "xno"
 then
-    if ${GSSAPI_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${GSSAPI_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GSSAPI_CFLAGS=`$PKG_CONFIG --cflags krb5-gssapi 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || GSSAPI_CFLAGS=${GSSAPI_CFLAGS:-`${KRB5_CONFIG:-krb5-config} --cflags gssapi 2>/dev/null`}
-if ${GSSAPI_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${GSSAPI_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   GSSAPI_LIBS=`$PKG_CONFIG --libs krb5-gssapi 2>/dev/null`
 fi
 fi
 test "$cross_compiling" = yes || GSSAPI_LIBS=${GSSAPI_LIBS:-`${KRB5_CONFIG:-krb5-config} --libs gssapi 2>/dev/null`}
 
-$as_echo "$as_me:${as_lineno-$LINENO}: krb5-gssapi cflags: $GSSAPI_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: krb5-gssapi libs: $GSSAPI_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5-gssapi cflags: $GSSAPI_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5-gssapi libs: $GSSAPI_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $GSSAPI_CFLAGS"
-for ac_header in gssapi/gssapi.h gssapi/gssapi_ext.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+ac_fn_c_check_header_compile "$LINENO" "gssapi/gssapi.h" "ac_cv_header_gssapi_gssapi_h" "$ac_includes_default"
+if test "x$ac_cv_header_gssapi_gssapi_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GSSAPI_GSSAPI_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "gssapi/gssapi_ext.h" "ac_cv_header_gssapi_gssapi_ext_h" "$ac_includes_default"
+if test "x$ac_cv_header_gssapi_gssapi_ext_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GSSAPI_GSSAPI_EXT_H 1" >>confdefs.h
 
-done
+fi
 
         if test "$ac_cv_header_gssapi_gssapi_h" = "yes" -a "$ac_cv_header_gssapi_gssapi_ext_h" = "yes"
         then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lgssapi_krb5" >&5
-$as_echo_n "checking for -lgssapi_krb5... " >&6; }
-if ${ac_cv_lib_soname_gssapi_krb5+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lgssapi_krb5" >&5
+printf %s "checking for -lgssapi_krb5... " >&6; }
+if test ${ac_cv_lib_soname_gssapi_krb5+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lgssapi_krb5 $GSSAPI_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15136,45 +17430,43 @@ LIBS="-lgssapi_krb5 $GSSAPI_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gss_init_sec_context ();
 int
-main ()
+main (void)
 {
 return gss_init_sec_context ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_gssapi_krb5=`$ac_cv_path_LDD conftest.exe | grep "gssapi_krb5" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_gssapi_krb5=`$OTOOL -L conftest$ac_exeext | grep "libgssapi_krb5\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libgssapi_krb5\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_gssapi_krb5=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libgssapi_krb5\\.$LIBEXT" | sed -e "s/^.*\\[\\(libgssapi_krb5\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_gssapi_krb5:+false} :; then :
+       if ${ac_cv_lib_soname_gssapi_krb5:+false} :
+then :
   ac_cv_lib_soname_gssapi_krb5=`$LDD conftest$ac_exeext | grep "libgssapi_krb5\\.$LIBEXT" | sed -e "s/^.*\(libgssapi_krb5\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_gssapi_krb5=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_gssapi_krb5:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_gssapi_krb5:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
        GSSAPI_CFLAGS=""
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gssapi_krb5" >&5
-$as_echo "$ac_cv_lib_soname_gssapi_krb5" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gssapi_krb5" >&5
+printf "%s\n" "$ac_cv_lib_soname_gssapi_krb5" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBGSSAPI_KRB5 "$ac_cv_lib_soname_gssapi_krb5"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBGSSAPI_KRB5 \"$ac_cv_lib_soname_gssapi_krb5\"" >>confdefs.h
 
 
 fi
@@ -15184,7 +17476,8 @@ fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_gssapi_krb5" = "x"; then :
+if test "x$ac_cv_lib_soname_gssapi_krb5" = "x"
+then :
   case "x$with_gssapi" in
   x)   as_fn_append wine_notices "|libgssapi_krb5 ${notice_platform}development files not found (or too old), no Kerberos SSP support." ;;
   xno) ;;
@@ -15196,11 +17489,12 @@ fi
 
 if test "$ac_cv_header_AL_al_h" = "yes"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lopenal" >&5
-$as_echo_n "checking for -lopenal... " >&6; }
-if ${ac_cv_lib_soname_openal+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lopenal" >&5
+printf %s "checking for -lopenal... " >&6; }
+if test ${ac_cv_lib_soname_openal+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lopenal  $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15209,57 +17503,54 @@ LIBS="-lopenal  $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char alGetSource3i ();
 int
-main ()
+main (void)
 {
 return alGetSource3i ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_openal=`$ac_cv_path_LDD conftest.exe | grep "openal" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_openal=`$OTOOL -L conftest$ac_exeext | grep "libopenal\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libopenal\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_openal=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libopenal\\.$LIBEXT" | sed -e "s/^.*\\[\\(libopenal\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_openal:+false} :; then :
+       if ${ac_cv_lib_soname_openal:+false} :
+then :
   ac_cv_lib_soname_openal=`$LDD conftest$ac_exeext | grep "libopenal\\.$LIBEXT" | sed -e "s/^.*\(libopenal\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_openal=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_openal:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_openal:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_openal" >&5
-$as_echo "$ac_cv_lib_soname_openal" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_openal" >&5
+printf "%s\n" "$ac_cv_lib_soname_openal" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBOPENAL "$ac_cv_lib_soname_openal"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBOPENAL \"$ac_cv_lib_soname_openal\"" >>confdefs.h
 
        OPENAL_LIBS="-lopenal"
 
                       ac_cv_lib_openal=yes
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_OPENAL 1
-_ACEOF
+printf "%s\n" "#define HAVE_OPENAL 1" >>confdefs.h
 
 fi
 fi
-if test "x$ac_cv_lib_openal" != xyes; then :
+if test "x$ac_cv_lib_openal" != xyes
+then :
   case "x$with_openal" in
   x)   as_fn_append wine_notices "|libopenal ${notice_platform}development files not found (or too old), OpenAL won't be supported." ;;
   xno) ;;
@@ -15271,11 +17562,12 @@ fi
 
 if test "$ac_cv_header_libprocstat_h" = "yes"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for procstat_open_sysctl in -lprocstat" >&5
-$as_echo_n "checking for procstat_open_sysctl in -lprocstat... " >&6; }
-if ${ac_cv_lib_procstat_procstat_open_sysctl+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for procstat_open_sysctl in -lprocstat" >&5
+printf %s "checking for procstat_open_sysctl in -lprocstat... " >&6; }
+if test ${ac_cv_lib_procstat_procstat_open_sysctl+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lprocstat  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15284,32 +17576,31 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char procstat_open_sysctl ();
 int
-main ()
+main (void)
 {
 return procstat_open_sysctl ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_procstat_procstat_open_sysctl=yes
-else
+else $as_nop
   ac_cv_lib_procstat_procstat_open_sysctl=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_procstat_procstat_open_sysctl" >&5
-$as_echo "$ac_cv_lib_procstat_procstat_open_sysctl" >&6; }
-if test "x$ac_cv_lib_procstat_procstat_open_sysctl" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_procstat_procstat_open_sysctl" >&5
+printf "%s\n" "$ac_cv_lib_procstat_procstat_open_sysctl" >&6; }
+if test "x$ac_cv_lib_procstat_procstat_open_sysctl" = xyes
+then :
 
-$as_echo "#define HAVE_LIBPROCSTAT 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LIBPROCSTAT 1" >>confdefs.h
 
                   PROCSTAT_LIBS="-lprocstat"
 
@@ -15317,11 +17608,12 @@ fi
 
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lodbc" >&5
-$as_echo_n "checking for -lodbc... " >&6; }
-if ${ac_cv_lib_soname_odbc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lodbc" >&5
+printf %s "checking for -lodbc... " >&6; }
+if test ${ac_cv_lib_soname_odbc+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lodbc  $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15330,76 +17622,77 @@ LIBS="-lodbc  $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char SQLConnect ();
 int
-main ()
+main (void)
 {
 return SQLConnect ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_odbc=`$ac_cv_path_LDD conftest.exe | grep "odbc" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_odbc=`$OTOOL -L conftest$ac_exeext | grep "libodbc\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libodbc\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_odbc=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libodbc\\.$LIBEXT" | sed -e "s/^.*\\[\\(libodbc\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_odbc:+false} :; then :
+       if ${ac_cv_lib_soname_odbc:+false} :
+then :
   ac_cv_lib_soname_odbc=`$LDD conftest$ac_exeext | grep "libodbc\\.$LIBEXT" | sed -e "s/^.*\(libodbc\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_odbc=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_odbc:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-       cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBODBC "libodbc.$LIBEXT"
-_ACEOF
+if ${ac_cv_lib_soname_odbc:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       printf "%s\n" "#define SONAME_LIBODBC \"libodbc.$LIBEXT\"" >>confdefs.h
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_odbc" >&5
-$as_echo "$ac_cv_lib_soname_odbc" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_odbc" >&5
+printf "%s\n" "$ac_cv_lib_soname_odbc" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBODBC "$ac_cv_lib_soname_odbc"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBODBC \"$ac_cv_lib_soname_odbc\"" >>confdefs.h
 
 
 fi
 
 if test "x$with_netapi" != "xno"
 then
-    if ${NETAPI_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${NETAPI_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   NETAPI_CFLAGS=`$PKG_CONFIG --cflags netapi 2>/dev/null`
 fi
 fi
 
-if ${NETAPI_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${NETAPI_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   NETAPI_LIBS=`$PKG_CONFIG --libs netapi 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: netapi cflags: $NETAPI_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: netapi libs: $NETAPI_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: netapi cflags: $NETAPI_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: netapi libs: $NETAPI_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $NETAPI_CFLAGS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lnetapi" >&5
-$as_echo_n "checking for -lnetapi... " >&6; }
-if ${ac_cv_lib_soname_netapi+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lnetapi" >&5
+printf %s "checking for -lnetapi... " >&6; }
+if test ${ac_cv_lib_soname_netapi+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lnetapi $NETAPI_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15408,48 +17701,44 @@ LIBS="-lnetapi $NETAPI_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char libnetapi_init ();
 int
-main ()
+main (void)
 {
 return libnetapi_init ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_netapi=`$ac_cv_path_LDD conftest.exe | grep "netapi" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_netapi=`$OTOOL -L conftest$ac_exeext | grep "libnetapi\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libnetapi\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_netapi=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libnetapi\\.$LIBEXT" | sed -e "s/^.*\\[\\(libnetapi\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_netapi:+false} :; then :
+       if ${ac_cv_lib_soname_netapi:+false} :
+then :
   ac_cv_lib_soname_netapi=`$LDD conftest$ac_exeext | grep "libnetapi\\.$LIBEXT" | sed -e "s/^.*\(libnetapi\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_netapi=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_netapi:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
-       cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBNETAPI "libnetapi.$LIBEXT"
-_ACEOF
+if ${ac_cv_lib_soname_netapi:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       printf "%s\n" "#define SONAME_LIBNETAPI \"libnetapi.$LIBEXT\"" >>confdefs.h
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_netapi" >&5
-$as_echo "$ac_cv_lib_soname_netapi" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_netapi" >&5
+printf "%s\n" "$ac_cv_lib_soname_netapi" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBNETAPI "$ac_cv_lib_soname_netapi"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBNETAPI \"$ac_cv_lib_soname_netapi\"" >>confdefs.h
 
 
 fi
@@ -15465,11 +17754,12 @@ fi
 
 if test "x$with_vulkan" != "xno"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lvulkan" >&5
-$as_echo_n "checking for -lvulkan... " >&6; }
-if ${ac_cv_lib_soname_vulkan+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lvulkan" >&5
+printf %s "checking for -lvulkan... " >&6; }
+if test ${ac_cv_lib_soname_vulkan+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lvulkan  $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15478,55 +17768,54 @@ LIBS="-lvulkan  $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char vkGetInstanceProcAddr ();
 int
-main ()
+main (void)
 {
 return vkGetInstanceProcAddr ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_vulkan=`$ac_cv_path_LDD conftest.exe | grep "vulkan" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_vulkan=`$OTOOL -L conftest$ac_exeext | grep "libvulkan\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libvulkan\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_vulkan=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libvulkan\\.$LIBEXT" | sed -e "s/^.*\\[\\(libvulkan\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_vulkan:+false} :; then :
+       if ${ac_cv_lib_soname_vulkan:+false} :
+then :
   ac_cv_lib_soname_vulkan=`$LDD conftest$ac_exeext | grep "libvulkan\\.$LIBEXT" | sed -e "s/^.*\(libvulkan\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_vulkan=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_vulkan:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_vulkan:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_vulkan" >&5
-$as_echo "$ac_cv_lib_soname_vulkan" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_vulkan" >&5
+printf "%s\n" "$ac_cv_lib_soname_vulkan" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBVULKAN "$ac_cv_lib_soname_vulkan"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBVULKAN \"$ac_cv_lib_soname_vulkan\"" >>confdefs.h
 
 
 fi
     if test "x$ac_cv_lib_soname_vulkan" = "x"
     then
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lMoltenVK" >&5
-$as_echo_n "checking for -lMoltenVK... " >&6; }
-if ${ac_cv_lib_soname_MoltenVK+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lMoltenVK" >&5
+printf %s "checking for -lMoltenVK... " >&6; }
+if test ${ac_cv_lib_soname_MoltenVK+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lMoltenVK  $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15535,51 +17824,50 @@ LIBS="-lMoltenVK  $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char vkGetInstanceProcAddr ();
 int
-main ()
+main (void)
 {
 return vkGetInstanceProcAddr ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_MoltenVK=`$ac_cv_path_LDD conftest.exe | grep "MoltenVK" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_MoltenVK=`$OTOOL -L conftest$ac_exeext | grep "libMoltenVK\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libMoltenVK\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_MoltenVK=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libMoltenVK\\.$LIBEXT" | sed -e "s/^.*\\[\\(libMoltenVK\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_MoltenVK:+false} :; then :
+       if ${ac_cv_lib_soname_MoltenVK:+false} :
+then :
   ac_cv_lib_soname_MoltenVK=`$LDD conftest$ac_exeext | grep "libMoltenVK\\.$LIBEXT" | sed -e "s/^.*\(libMoltenVK\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_MoltenVK=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_MoltenVK:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_MoltenVK:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_MoltenVK" >&5
-$as_echo "$ac_cv_lib_soname_MoltenVK" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_MoltenVK" >&5
+printf "%s\n" "$ac_cv_lib_soname_MoltenVK" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBMOLTENVK "$ac_cv_lib_soname_MoltenVK"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBMOLTENVK \"$ac_cv_lib_soname_MoltenVK\"" >>confdefs.h
 
 
 fi
     fi
 fi
-if test "x$ac_cv_lib_soname_vulkan" = "x" -a "x$ac_cv_lib_soname_MoltenVK" = "x"; then :
+if test "x$ac_cv_lib_soname_vulkan" = "x" -a "x$ac_cv_lib_soname_MoltenVK" = "x"
+then :
   case "x$with_vulkan" in
   x)   as_fn_append wine_notices "|libvulkan and libMoltenVK ${notice_platform}development files not found, Vulkan won't be supported." ;;
   xno) ;;
@@ -15591,28 +17879,33 @@ fi
 
 if test "x$with_vkd3d" != "xno"
 then
-    if ${VKD3D_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${VKD3D_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   VKD3D_CFLAGS=`$PKG_CONFIG --cflags libvkd3d 2>/dev/null`
 fi
 fi
 
-if ${VKD3D_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${VKD3D_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   VKD3D_LIBS=`$PKG_CONFIG --libs libvkd3d 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: libvkd3d cflags: $VKD3D_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libvkd3d libs: $VKD3D_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libvkd3d cflags: $VKD3D_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libvkd3d libs: $VKD3D_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $VKD3D_CFLAGS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lvkd3d" >&5
-$as_echo_n "checking for -lvkd3d... " >&6; }
-if ${ac_cv_lib_soname_vkd3d+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lvkd3d" >&5
+printf %s "checking for -lvkd3d... " >&6; }
+if test ${ac_cv_lib_soname_vkd3d+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lvkd3d $VKD3D_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15621,72 +17914,75 @@ LIBS="-lvkd3d $VKD3D_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char vkd3d_serialize_versioned_root_signature ();
 int
-main ()
+main (void)
 {
 return vkd3d_serialize_versioned_root_signature ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_vkd3d=`$ac_cv_path_LDD conftest.exe | grep "vkd3d" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_vkd3d=`$OTOOL -L conftest$ac_exeext | grep "libvkd3d\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libvkd3d\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_vkd3d=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libvkd3d\\.$LIBEXT" | sed -e "s/^.*\\[\\(libvkd3d\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_vkd3d:+false} :; then :
+       if ${ac_cv_lib_soname_vkd3d:+false} :
+then :
   ac_cv_lib_soname_vkd3d=`$LDD conftest$ac_exeext | grep "libvkd3d\\.$LIBEXT" | sed -e "s/^.*\(libvkd3d\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_vkd3d=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_vkd3d:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_vkd3d:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_vkd3d" >&5
-$as_echo "$ac_cv_lib_soname_vkd3d" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_vkd3d" >&5
+printf "%s\n" "$ac_cv_lib_soname_vkd3d" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBVKD3D "$ac_cv_lib_soname_vkd3d"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBVKD3D \"$ac_cv_lib_soname_vkd3d\"" >>confdefs.h
 
 
 fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
-    if ${VKD3D_SHADER_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+    if ${VKD3D_SHADER_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   VKD3D_SHADER_CFLAGS=`$PKG_CONFIG --cflags libvkd3d-shader 2>/dev/null`
 fi
 fi
 
-if ${VKD3D_SHADER_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${VKD3D_SHADER_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   VKD3D_SHADER_LIBS=`$PKG_CONFIG --libs libvkd3d-shader 2>/dev/null`
 fi
 fi
 
 
-$as_echo "$as_me:${as_lineno-$LINENO}: libvkd3d-shader cflags: $VKD3D_SHADER_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: libvkd3d-shader libs: $VKD3D_SHADER_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libvkd3d-shader cflags: $VKD3D_SHADER_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libvkd3d-shader libs: $VKD3D_SHADER_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $VKD3D_SHADER_CFLAGS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lvkd3d-shader" >&5
-$as_echo_n "checking for -lvkd3d-shader... " >&6; }
-if ${ac_cv_lib_soname_vkd3d_shader+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lvkd3d-shader" >&5
+printf %s "checking for -lvkd3d-shader... " >&6; }
+if test ${ac_cv_lib_soname_vkd3d_shader+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_soname_save_LIBS=$LIBS
 LIBS="-lvkd3d-shader $VKD3D_SHADER_LIBS $LIBS"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -15695,52 +17991,51 @@ LIBS="-lvkd3d-shader $VKD3D_SHADER_LIBS $LIBS"
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char vkd3d_shader_compile ();
 int
-main ()
+main (void)
 {
 return vkd3d_shader_compile ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   case "$LIBEXT" in
     dll) ac_cv_lib_soname_vkd3d_shader=`$ac_cv_path_LDD conftest.exe | grep "vkd3d-shader" | sed -e "s/dll.*/dll/"';2,$d'` ;;
     dylib) ac_cv_lib_soname_vkd3d_shader=`$OTOOL -L conftest$ac_exeext | grep "libvkd3d-shader\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libvkd3d-shader\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
     *) ac_cv_lib_soname_vkd3d_shader=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libvkd3d-shader\\.$LIBEXT" | sed -e "s/^.*\\[\\(libvkd3d-shader\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
-       if ${ac_cv_lib_soname_vkd3d_shader:+false} :; then :
+       if ${ac_cv_lib_soname_vkd3d_shader:+false} :
+then :
   ac_cv_lib_soname_vkd3d_shader=`$LDD conftest$ac_exeext | grep "libvkd3d-shader\\.$LIBEXT" | sed -e "s/^.*\(libvkd3d-shader\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
 fi ;;
   esac
-else
+else $as_nop
   ac_cv_lib_soname_vkd3d_shader=
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
   LIBS=$ac_check_soname_save_LIBS
 fi
-if ${ac_cv_lib_soname_vkd3d_shader:+false} :; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
-$as_echo "not found" >&6; }
+if ${ac_cv_lib_soname_vkd3d_shader:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_vkd3d_shader" >&5
-$as_echo "$ac_cv_lib_soname_vkd3d_shader" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_vkd3d_shader" >&5
+printf "%s\n" "$ac_cv_lib_soname_vkd3d_shader" >&6; }
 
-cat >>confdefs.h <<_ACEOF
-#define SONAME_LIBVKD3D_SHADER "$ac_cv_lib_soname_vkd3d_shader"
-_ACEOF
+printf "%s\n" "#define SONAME_LIBVKD3D_SHADER \"$ac_cv_lib_soname_vkd3d_shader\"" >>confdefs.h
 
 
 fi
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$ac_cv_lib_soname_vkd3d" = "x"; then :
+if test "x$ac_cv_lib_soname_vkd3d" = "x"
+then :
   case "x$with_vkd3d" in
   x)   as_fn_append wine_notices "|vkd3d ${notice_platform}development files not found (or too old), Direct3D 12 won't be supported." ;;
   xno) ;;
@@ -15751,623 +18046,793 @@ esac
 fi
 test "x$ac_cv_lib_soname_vkd3d" != "x" || enable_d3d12=${enable_d3d12:-no}
 
+if test "x$with_gcrypt" != "xno"
+then
+    if ${GCRYPT_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GCRYPT_CFLAGS=`$PKG_CONFIG --cflags libgcrypt 2>/dev/null`
+fi
+fi
+
+if ${GCRYPT_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GCRYPT_LIBS=`$PKG_CONFIG --libs libgcrypt 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgcrypt cflags: $GCRYPT_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgcrypt libs: $GCRYPT_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GCRYPT_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gcrypt.h" "ac_cv_header_gcrypt_h" "$ac_includes_default"
+if test "x$ac_cv_header_gcrypt_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GCRYPT_H 1" >>confdefs.h
+
+fi
+
+        if test "$ac_cv_header_gcrypt_h" = "yes"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lgcrypt" >&5
+printf %s "checking for -lgcrypt... " >&6; }
+if test ${ac_cv_lib_soname_gcrypt+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lgcrypt $GCRYPT_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char gcry_sexp_build ();
+int
+main (void)
+{
+return gcry_sexp_build ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_gcrypt=`$ac_cv_path_LDD conftest.exe | grep "gcrypt" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_gcrypt=`$OTOOL -L conftest$ac_exeext | grep "libgcrypt\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libgcrypt\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_gcrypt=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libgcrypt\\.$LIBEXT" | sed -e "s/^.*\\[\\(libgcrypt\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_gcrypt:+false} :
+then :
+  ac_cv_lib_soname_gcrypt=`$LDD conftest$ac_exeext | grep "libgcrypt\\.$LIBEXT" | sed -e "s/^.*\(libgcrypt\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else $as_nop
+  ac_cv_lib_soname_gcrypt=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_gcrypt:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gcrypt" >&5
+printf "%s\n" "$ac_cv_lib_soname_gcrypt" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGCRYPT \"$ac_cv_lib_soname_gcrypt\"" >>confdefs.h
+
+
+fi
+        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_gcrypt" = "x"
+then :
+  case "x$with_gcrypt" in
+  x)   as_fn_append wine_notices "|libgcrypt ${notice_platform}development files not found, GCRYPT won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libgcrypt ${notice_platform}development files not found, GCRYPT won't be supported.
+This is an error since --with-gcrypt was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
 
 if test "x${GCC}" = "xyes"
 then
   EXTRACFLAGS="$EXTRACFLAGS -Wall -pipe"
 
       saved_CFLAGS=$CFLAGS
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=unknown-warning-option" >&5
-$as_echo_n "checking whether the compiler supports -Werror=unknown-warning-option... " >&6; }
-if ${ac_cv_cflags__Werror_unknown_warning_option+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=unknown-warning-option" >&5
+printf %s "checking whether the compiler supports -Werror=unknown-warning-option... " >&6; }
+if test ${ac_cv_cflags__Werror_unknown_warning_option+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Werror=unknown-warning-option"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Werror_unknown_warning_option=yes
-else
+else $as_nop
   ac_cv_cflags__Werror_unknown_warning_option=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_unknown_warning_option" >&5
-$as_echo "$ac_cv_cflags__Werror_unknown_warning_option" >&6; }
-if test "x$ac_cv_cflags__Werror_unknown_warning_option" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_unknown_warning_option" >&5
+printf "%s\n" "$ac_cv_cflags__Werror_unknown_warning_option" >&6; }
+if test "x$ac_cv_cflags__Werror_unknown_warning_option" = xyes
+then :
   CFLAGS="$CFLAGS -Werror=unknown-warning-option"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=unused-command-line-argument" >&5
-$as_echo_n "checking whether the compiler supports -Werror=unused-command-line-argument... " >&6; }
-if ${ac_cv_cflags__Werror_unused_command_line_argument+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=unused-command-line-argument" >&5
+printf %s "checking whether the compiler supports -Werror=unused-command-line-argument... " >&6; }
+if test ${ac_cv_cflags__Werror_unused_command_line_argument+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Werror=unused-command-line-argument"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Werror_unused_command_line_argument=yes
-else
+else $as_nop
   ac_cv_cflags__Werror_unused_command_line_argument=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_unused_command_line_argument" >&5
-$as_echo "$ac_cv_cflags__Werror_unused_command_line_argument" >&6; }
-if test "x$ac_cv_cflags__Werror_unused_command_line_argument" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_unused_command_line_argument" >&5
+printf "%s\n" "$ac_cv_cflags__Werror_unused_command_line_argument" >&6; }
+if test "x$ac_cv_cflags__Werror_unused_command_line_argument" = xyes
+then :
   CFLAGS="$CFLAGS -Werror=unused-command-line-argument"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=ignored-optimization-argument" >&5
-$as_echo_n "checking whether the compiler supports -Werror=ignored-optimization-argument... " >&6; }
-if ${ac_cv_cflags__Werror_ignored_optimization_argument+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=ignored-optimization-argument" >&5
+printf %s "checking whether the compiler supports -Werror=ignored-optimization-argument... " >&6; }
+if test ${ac_cv_cflags__Werror_ignored_optimization_argument+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Werror=ignored-optimization-argument"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Werror_ignored_optimization_argument=yes
-else
+else $as_nop
   ac_cv_cflags__Werror_ignored_optimization_argument=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_ignored_optimization_argument" >&5
-$as_echo "$ac_cv_cflags__Werror_ignored_optimization_argument" >&6; }
-if test "x$ac_cv_cflags__Werror_ignored_optimization_argument" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_ignored_optimization_argument" >&5
+printf "%s\n" "$ac_cv_cflags__Werror_ignored_optimization_argument" >&6; }
+if test "x$ac_cv_cflags__Werror_ignored_optimization_argument" = xyes
+then :
   CFLAGS="$CFLAGS -Werror=ignored-optimization-argument"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fcf-protection=none" >&5
-$as_echo_n "checking whether the compiler supports -fcf-protection=none... " >&6; }
-if ${ac_cv_cflags__fcf_protection_none+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fcf-protection=none" >&5
+printf %s "checking whether the compiler supports -fcf-protection=none... " >&6; }
+if test ${ac_cv_cflags__fcf_protection_none+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fcf-protection=none"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fcf_protection_none=yes
-else
+else $as_nop
   ac_cv_cflags__fcf_protection_none=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fcf_protection_none" >&5
-$as_echo "$ac_cv_cflags__fcf_protection_none" >&6; }
-if test "x$ac_cv_cflags__fcf_protection_none" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fcf_protection_none" >&5
+printf "%s\n" "$ac_cv_cflags__fcf_protection_none" >&6; }
+if test "x$ac_cv_cflags__fcf_protection_none" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -fcf-protection=none"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-stack-protector" >&5
-$as_echo_n "checking whether the compiler supports -fno-stack-protector... " >&6; }
-if ${ac_cv_cflags__fno_stack_protector+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-stack-protector" >&5
+printf %s "checking whether the compiler supports -fno-stack-protector... " >&6; }
+if test ${ac_cv_cflags__fno_stack_protector+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fno-stack-protector"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fno_stack_protector=yes
-else
+else $as_nop
   ac_cv_cflags__fno_stack_protector=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_stack_protector" >&5
-$as_echo "$ac_cv_cflags__fno_stack_protector" >&6; }
-if test "x$ac_cv_cflags__fno_stack_protector" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_stack_protector" >&5
+printf "%s\n" "$ac_cv_cflags__fno_stack_protector" >&6; }
+if test "x$ac_cv_cflags__fno_stack_protector" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -fno-stack-protector"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-strict-aliasing" >&5
-$as_echo_n "checking whether the compiler supports -fno-strict-aliasing... " >&6; }
-if ${ac_cv_cflags__fno_strict_aliasing+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-strict-aliasing" >&5
+printf %s "checking whether the compiler supports -fno-strict-aliasing... " >&6; }
+if test ${ac_cv_cflags__fno_strict_aliasing+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fno-strict-aliasing"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fno_strict_aliasing=yes
-else
+else $as_nop
   ac_cv_cflags__fno_strict_aliasing=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_strict_aliasing" >&5
-$as_echo "$ac_cv_cflags__fno_strict_aliasing" >&6; }
-if test "x$ac_cv_cflags__fno_strict_aliasing" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_strict_aliasing" >&5
+printf "%s\n" "$ac_cv_cflags__fno_strict_aliasing" >&6; }
+if test "x$ac_cv_cflags__fno_strict_aliasing" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -fno-strict-aliasing"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wdeclaration-after-statement" >&5
-$as_echo_n "checking whether the compiler supports -Wdeclaration-after-statement... " >&6; }
-if ${ac_cv_cflags__Wdeclaration_after_statement+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wdeclaration-after-statement" >&5
+printf %s "checking whether the compiler supports -Wdeclaration-after-statement... " >&6; }
+if test ${ac_cv_cflags__Wdeclaration_after_statement+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wdeclaration-after-statement"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wdeclaration_after_statement=yes
-else
+else $as_nop
   ac_cv_cflags__Wdeclaration_after_statement=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wdeclaration_after_statement" >&5
-$as_echo "$ac_cv_cflags__Wdeclaration_after_statement" >&6; }
-if test "x$ac_cv_cflags__Wdeclaration_after_statement" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wdeclaration_after_statement" >&5
+printf "%s\n" "$ac_cv_cflags__Wdeclaration_after_statement" >&6; }
+if test "x$ac_cv_cflags__Wdeclaration_after_statement" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wdeclaration-after-statement"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wempty-body" >&5
-$as_echo_n "checking whether the compiler supports -Wempty-body... " >&6; }
-if ${ac_cv_cflags__Wempty_body+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wempty-body" >&5
+printf %s "checking whether the compiler supports -Wempty-body... " >&6; }
+if test ${ac_cv_cflags__Wempty_body+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wempty-body"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wempty_body=yes
-else
+else $as_nop
   ac_cv_cflags__Wempty_body=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wempty_body" >&5
-$as_echo "$ac_cv_cflags__Wempty_body" >&6; }
-if test "x$ac_cv_cflags__Wempty_body" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wempty_body" >&5
+printf "%s\n" "$ac_cv_cflags__Wempty_body" >&6; }
+if test "x$ac_cv_cflags__Wempty_body" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wempty-body"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wignored-qualifiers" >&5
-$as_echo_n "checking whether the compiler supports -Wignored-qualifiers... " >&6; }
-if ${ac_cv_cflags__Wignored_qualifiers+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wignored-qualifiers" >&5
+printf %s "checking whether the compiler supports -Wignored-qualifiers... " >&6; }
+if test ${ac_cv_cflags__Wignored_qualifiers+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wignored-qualifiers"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wignored_qualifiers=yes
-else
+else $as_nop
   ac_cv_cflags__Wignored_qualifiers=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wignored_qualifiers" >&5
-$as_echo "$ac_cv_cflags__Wignored_qualifiers" >&6; }
-if test "x$ac_cv_cflags__Wignored_qualifiers" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wignored_qualifiers" >&5
+printf "%s\n" "$ac_cv_cflags__Wignored_qualifiers" >&6; }
+if test "x$ac_cv_cflags__Wignored_qualifiers" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wignored-qualifiers"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Winit-self" >&5
-$as_echo_n "checking whether the compiler supports -Winit-self... " >&6; }
-if ${ac_cv_cflags__Winit_self+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Winit-self" >&5
+printf %s "checking whether the compiler supports -Winit-self... " >&6; }
+if test ${ac_cv_cflags__Winit_self+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Winit-self"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Winit_self=yes
-else
+else $as_nop
   ac_cv_cflags__Winit_self=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Winit_self" >&5
-$as_echo "$ac_cv_cflags__Winit_self" >&6; }
-if test "x$ac_cv_cflags__Winit_self" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Winit_self" >&5
+printf "%s\n" "$ac_cv_cflags__Winit_self" >&6; }
+if test "x$ac_cv_cflags__Winit_self" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Winit-self"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpacked-not-aligned" >&5
-$as_echo_n "checking whether the compiler supports -Wpacked-not-aligned... " >&6; }
-if ${ac_cv_cflags__Wpacked_not_aligned+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpacked-not-aligned" >&5
+printf %s "checking whether the compiler supports -Wpacked-not-aligned... " >&6; }
+if test ${ac_cv_cflags__Wpacked_not_aligned+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wpacked-not-aligned"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wpacked_not_aligned=yes
-else
+else $as_nop
   ac_cv_cflags__Wpacked_not_aligned=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpacked_not_aligned" >&5
-$as_echo "$ac_cv_cflags__Wpacked_not_aligned" >&6; }
-if test "x$ac_cv_cflags__Wpacked_not_aligned" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpacked_not_aligned" >&5
+printf "%s\n" "$ac_cv_cflags__Wpacked_not_aligned" >&6; }
+if test "x$ac_cv_cflags__Wpacked_not_aligned" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wno-packed-not-aligned"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpragma-pack" >&5
-$as_echo_n "checking whether the compiler supports -Wpragma-pack... " >&6; }
-if ${ac_cv_cflags__Wpragma_pack+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpragma-pack" >&5
+printf %s "checking whether the compiler supports -Wpragma-pack... " >&6; }
+if test ${ac_cv_cflags__Wpragma_pack+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wpragma-pack"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wpragma_pack=yes
-else
+else $as_nop
   ac_cv_cflags__Wpragma_pack=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpragma_pack" >&5
-$as_echo "$ac_cv_cflags__Wpragma_pack" >&6; }
-if test "x$ac_cv_cflags__Wpragma_pack" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpragma_pack" >&5
+printf "%s\n" "$ac_cv_cflags__Wpragma_pack" >&6; }
+if test "x$ac_cv_cflags__Wpragma_pack" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wno-pragma-pack"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wshift-overflow=2" >&5
-$as_echo_n "checking whether the compiler supports -Wshift-overflow=2... " >&6; }
-if ${ac_cv_cflags__Wshift_overflow_2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wshift-overflow=2" >&5
+printf %s "checking whether the compiler supports -Wshift-overflow=2... " >&6; }
+if test ${ac_cv_cflags__Wshift_overflow_2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wshift-overflow=2"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wshift_overflow_2=yes
-else
+else $as_nop
   ac_cv_cflags__Wshift_overflow_2=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wshift_overflow_2" >&5
-$as_echo "$ac_cv_cflags__Wshift_overflow_2" >&6; }
-if test "x$ac_cv_cflags__Wshift_overflow_2" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wshift_overflow_2" >&5
+printf "%s\n" "$ac_cv_cflags__Wshift_overflow_2" >&6; }
+if test "x$ac_cv_cflags__Wshift_overflow_2" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wshift-overflow=2"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wstrict-prototypes" >&5
-$as_echo_n "checking whether the compiler supports -Wstrict-prototypes... " >&6; }
-if ${ac_cv_cflags__Wstrict_prototypes+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wstrict-prototypes" >&5
+printf %s "checking whether the compiler supports -Wstrict-prototypes... " >&6; }
+if test ${ac_cv_cflags__Wstrict_prototypes+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wstrict-prototypes"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wstrict_prototypes=yes
-else
+else $as_nop
   ac_cv_cflags__Wstrict_prototypes=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wstrict_prototypes" >&5
-$as_echo "$ac_cv_cflags__Wstrict_prototypes" >&6; }
-if test "x$ac_cv_cflags__Wstrict_prototypes" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wstrict_prototypes" >&5
+printf "%s\n" "$ac_cv_cflags__Wstrict_prototypes" >&6; }
+if test "x$ac_cv_cflags__Wstrict_prototypes" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wstrict-prototypes"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wtype-limits" >&5
-$as_echo_n "checking whether the compiler supports -Wtype-limits... " >&6; }
-if ${ac_cv_cflags__Wtype_limits+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wtype-limits" >&5
+printf %s "checking whether the compiler supports -Wtype-limits... " >&6; }
+if test ${ac_cv_cflags__Wtype_limits+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wtype-limits"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wtype_limits=yes
-else
+else $as_nop
   ac_cv_cflags__Wtype_limits=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wtype_limits" >&5
-$as_echo "$ac_cv_cflags__Wtype_limits" >&6; }
-if test "x$ac_cv_cflags__Wtype_limits" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wtype_limits" >&5
+printf "%s\n" "$ac_cv_cflags__Wtype_limits" >&6; }
+if test "x$ac_cv_cflags__Wtype_limits" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wtype-limits"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wunused-but-set-parameter" >&5
-$as_echo_n "checking whether the compiler supports -Wunused-but-set-parameter... " >&6; }
-if ${ac_cv_cflags__Wunused_but_set_parameter+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wunused-but-set-parameter" >&5
+printf %s "checking whether the compiler supports -Wunused-but-set-parameter... " >&6; }
+if test ${ac_cv_cflags__Wunused_but_set_parameter+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wunused-but-set-parameter"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wunused_but_set_parameter=yes
-else
+else $as_nop
   ac_cv_cflags__Wunused_but_set_parameter=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wunused_but_set_parameter" >&5
-$as_echo "$ac_cv_cflags__Wunused_but_set_parameter" >&6; }
-if test "x$ac_cv_cflags__Wunused_but_set_parameter" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wunused_but_set_parameter" >&5
+printf "%s\n" "$ac_cv_cflags__Wunused_but_set_parameter" >&6; }
+if test "x$ac_cv_cflags__Wunused_but_set_parameter" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wunused-but-set-parameter"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wvla" >&5
-$as_echo_n "checking whether the compiler supports -Wvla... " >&6; }
-if ${ac_cv_cflags__Wvla+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wvla" >&5
+printf %s "checking whether the compiler supports -Wvla... " >&6; }
+if test ${ac_cv_cflags__Wvla+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wvla"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wvla=yes
-else
+else $as_nop
   ac_cv_cflags__Wvla=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wvla" >&5
-$as_echo "$ac_cv_cflags__Wvla" >&6; }
-if test "x$ac_cv_cflags__Wvla" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wvla" >&5
+printf "%s\n" "$ac_cv_cflags__Wvla" >&6; }
+if test "x$ac_cv_cflags__Wvla" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wvla"
 fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wwrite-strings" >&5
-$as_echo_n "checking whether the compiler supports -Wwrite-strings... " >&6; }
-if ${ac_cv_cflags__Wwrite_strings+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wwrite-strings" >&5
+printf %s "checking whether the compiler supports -Wwrite-strings... " >&6; }
+if test ${ac_cv_cflags__Wwrite_strings+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wwrite-strings"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wwrite_strings=yes
-else
+else $as_nop
   ac_cv_cflags__Wwrite_strings=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wwrite_strings" >&5
-$as_echo "$ac_cv_cflags__Wwrite_strings" >&6; }
-if test "x$ac_cv_cflags__Wwrite_strings" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wwrite_strings" >&5
+printf "%s\n" "$ac_cv_cflags__Wwrite_strings" >&6; }
+if test "x$ac_cv_cflags__Wwrite_strings" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wwrite-strings"
 fi
 
   if test -z "$CROSSTARGET"
   then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fexcess-precision=standard" >&5
-$as_echo_n "checking whether the compiler supports -fexcess-precision=standard... " >&6; }
-if ${ac_cv_cflags__fexcess_precision_standard+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fexcess-precision=standard" >&5
+printf %s "checking whether the compiler supports -fexcess-precision=standard... " >&6; }
+if test ${ac_cv_cflags__fexcess_precision_standard+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fexcess-precision=standard"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fexcess_precision_standard=yes
-else
+else $as_nop
   ac_cv_cflags__fexcess_precision_standard=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fexcess_precision_standard" >&5
-$as_echo "$ac_cv_cflags__fexcess_precision_standard" >&6; }
-if test "x$ac_cv_cflags__fexcess_precision_standard" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fexcess_precision_standard" >&5
+printf "%s\n" "$ac_cv_cflags__fexcess_precision_standard" >&6; }
+if test "x$ac_cv_cflags__fexcess_precision_standard" = xyes
+then :
   EXCESS_PRECISION_CFLAGS="-fexcess-precision=standard"
 
 fi
   fi
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpointer-arith" >&5
-$as_echo_n "checking whether the compiler supports -Wpointer-arith... " >&6; }
-if ${ac_cv_cflags__Wpointer_arith+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpointer-arith" >&5
+printf %s "checking whether the compiler supports -Wpointer-arith... " >&6; }
+if test ${ac_cv_cflags__Wpointer_arith+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wpointer-arith"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wpointer_arith=yes
-else
+else $as_nop
   ac_cv_cflags__Wpointer_arith=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpointer_arith" >&5
-$as_echo "$ac_cv_cflags__Wpointer_arith" >&6; }
-if test "x$ac_cv_cflags__Wpointer_arith" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpointer_arith" >&5
+printf "%s\n" "$ac_cv_cflags__Wpointer_arith" >&6; }
+if test "x$ac_cv_cflags__Wpointer_arith" = xyes
+then :
   saved_string_h_CFLAGS=$CFLAGS
       CFLAGS="$CFLAGS -Wpointer-arith -Werror"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for broken string.h that generates warnings with -Wpointer-arith" >&5
-$as_echo_n "checking for broken string.h that generates warnings with -Wpointer-arith... " >&6; }
-if ${ac_cv_c_string_h_warnings+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for broken string.h that generates warnings with -Wpointer-arith" >&5
+printf %s "checking for broken string.h that generates warnings with -Wpointer-arith... " >&6; }
+if test ${ac_cv_c_string_h_warnings+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <string.h>
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_c_string_h_warnings=no
-else
+else $as_nop
   ac_cv_c_string_h_warnings=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_string_h_warnings" >&5
-$as_echo "$ac_cv_c_string_h_warnings" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_string_h_warnings" >&5
+printf "%s\n" "$ac_cv_c_string_h_warnings" >&6; }
       test "$ac_cv_c_string_h_warnings" = yes || EXTRACFLAGS="$EXTRACFLAGS -Wpointer-arith"
       CFLAGS=$saved_string_h_CFLAGS
 fi
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wlogical-op" >&5
-$as_echo_n "checking whether the compiler supports -Wlogical-op... " >&6; }
-if ${ac_cv_cflags__Wlogical_op+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wlogical-op" >&5
+printf %s "checking whether the compiler supports -Wlogical-op... " >&6; }
+if test ${ac_cv_cflags__Wlogical_op+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wlogical-op"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wlogical_op=yes
-else
+else $as_nop
   ac_cv_cflags__Wlogical_op=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wlogical_op" >&5
-$as_echo "$ac_cv_cflags__Wlogical_op" >&6; }
-if test "x$ac_cv_cflags__Wlogical_op" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wlogical_op" >&5
+printf "%s\n" "$ac_cv_cflags__Wlogical_op" >&6; }
+if test "x$ac_cv_cflags__Wlogical_op" = xyes
+then :
   saved_string_h_CFLAGS=$CFLAGS
       CFLAGS="$CFLAGS -Wlogical-op -Werror"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for broken string.h that generates warnings with -Wlogical-op" >&5
-$as_echo_n "checking for broken string.h that generates warnings with -Wlogical-op... " >&6; }
-if ${ac_cv_c_logicalop_noisy+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for broken string.h that generates warnings with -Wlogical-op" >&5
+printf %s "checking for broken string.h that generates warnings with -Wlogical-op... " >&6; }
+if test ${ac_cv_c_logicalop_noisy+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <string.h>
 char*f(const char *h,char n) {return strchr(h,n);}
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_c_logicalop_noisy=no
-else
+else $as_nop
   ac_cv_c_logicalop_noisy=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_logicalop_noisy" >&5
-$as_echo "$ac_cv_c_logicalop_noisy" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_logicalop_noisy" >&5
+printf "%s\n" "$ac_cv_c_logicalop_noisy" >&6; }
       CFLAGS=$saved_string_h_CFLAGS
       test "$ac_cv_c_logicalop_noisy" = yes || EXTRACFLAGS="$EXTRACFLAGS -Wlogical-op"
 fi
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for flags needed for 64-bit compare-and-swap support" >&5
-$as_echo_n "checking for flags needed for 64-bit compare-and-swap support... " >&6; }
-if ${wine_cv_64bit_compare_swap+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for flags needed for 64-bit compare-and-swap support" >&5
+printf %s "checking for flags needed for 64-bit compare-and-swap support... " >&6; }
+if test ${wine_cv_64bit_compare_swap+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
 #error no
 #endif
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   wine_cv_64bit_compare_swap="none needed"
-else
+else $as_nop
   case $host_cpu in
             *i[3456]86*) wine_cv_64bit_compare_swap="-march=i586" ;;
             *arm*)         wine_cv_64bit_compare_swap="-march=armv7-a" ;;
@@ -16382,26 +18847,27 @@ else
 #error no
 #endif
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-else
+else $as_nop
   wine_cv_64bit_compare_swap="unknown"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
                CFLAGS=$saved_CFLAGS
            fi
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_64bit_compare_swap" >&5
-$as_echo "$wine_cv_64bit_compare_swap" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_64bit_compare_swap" >&5
+printf "%s\n" "$wine_cv_64bit_compare_swap" >&6; }
   case "$wine_cv_64bit_compare_swap" in
       unknown) as_fn_error $? "gcc doesn't support 64-bit compare-and-swap on this platform" "$LINENO" 5 ;;
       "none needed") ;;
@@ -16417,54 +18883,60 @@ $as_echo "$wine_cv_64bit_compare_swap" >&6; }
   done
   if test "x$ac_debug_format_seen" = xdefault
   then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -gdwarf-2" >&5
-$as_echo_n "checking whether the compiler supports -gdwarf-2... " >&6; }
-if ${ac_cv_cflags__gdwarf_2+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -gdwarf-2" >&5
+printf %s "checking whether the compiler supports -gdwarf-2... " >&6; }
+if test ${ac_cv_cflags__gdwarf_2+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -gdwarf-2"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__gdwarf_2=yes
-else
+else $as_nop
   ac_cv_cflags__gdwarf_2=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__gdwarf_2" >&5
-$as_echo "$ac_cv_cflags__gdwarf_2" >&6; }
-if test "x$ac_cv_cflags__gdwarf_2" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__gdwarf_2" >&5
+printf "%s\n" "$ac_cv_cflags__gdwarf_2" >&6; }
+if test "x$ac_cv_cflags__gdwarf_2" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -gdwarf-2"
 fi
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -gstrict-dwarf" >&5
-$as_echo_n "checking whether the compiler supports -gstrict-dwarf... " >&6; }
-if ${ac_cv_cflags__gstrict_dwarf+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -gstrict-dwarf" >&5
+printf %s "checking whether the compiler supports -gstrict-dwarf... " >&6; }
+if test ${ac_cv_cflags__gstrict_dwarf+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -gstrict-dwarf"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__gstrict_dwarf=yes
-else
+else $as_nop
   ac_cv_cflags__gstrict_dwarf=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__gstrict_dwarf" >&5
-$as_echo "$ac_cv_cflags__gstrict_dwarf" >&6; }
-if test "x$ac_cv_cflags__gstrict_dwarf" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__gstrict_dwarf" >&5
+printf "%s\n" "$ac_cv_cflags__gstrict_dwarf" >&6; }
+if test "x$ac_cv_cflags__gstrict_dwarf" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -gstrict-dwarf"
 fi
   fi
@@ -16472,161 +18944,179 @@ fi
     MSVCRTFLAGS=""
 
   case $host_os in
-    mingw32*)         { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-delayload,autoconftest.dll" >&5
-$as_echo_n "checking whether the compiler supports -Wl,-delayload,autoconftest.dll... " >&6; }
-if ${ac_cv_cflags__Wl__delayload_autoconftest_dll+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    mingw32*)         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-delayload,autoconftest.dll" >&5
+printf %s "checking whether the compiler supports -Wl,-delayload,autoconftest.dll... " >&6; }
+if test ${ac_cv_cflags__Wl__delayload_autoconftest_dll+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,-delayload,autoconftest.dll"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl__delayload_autoconftest_dll=yes
-else
+else $as_nop
   ac_cv_cflags__Wl__delayload_autoconftest_dll=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__delayload_autoconftest_dll" >&5
-$as_echo "$ac_cv_cflags__Wl__delayload_autoconftest_dll" >&6; }
-if test "x$ac_cv_cflags__Wl__delayload_autoconftest_dll" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__delayload_autoconftest_dll" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__delayload_autoconftest_dll" >&6; }
+if test "x$ac_cv_cflags__Wl__delayload_autoconftest_dll" = xyes
+then :
   DELAYLOADFLAG="-Wl,-delayload,"
 
 fi ;;
     *) MSVCRTFLAGS="-D_WIN32"
-       { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-builtin" >&5
-$as_echo_n "checking whether the compiler supports -fno-builtin... " >&6; }
-if ${ac_cv_cflags__fno_builtin+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-builtin" >&5
+printf %s "checking whether the compiler supports -fno-builtin... " >&6; }
+if test ${ac_cv_cflags__fno_builtin+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fno-builtin"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fno_builtin=yes
-else
+else $as_nop
   ac_cv_cflags__fno_builtin=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_builtin" >&5
-$as_echo "$ac_cv_cflags__fno_builtin" >&6; }
-if test "x$ac_cv_cflags__fno_builtin" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_builtin" >&5
+printf "%s\n" "$ac_cv_cflags__fno_builtin" >&6; }
+if test "x$ac_cv_cflags__fno_builtin" = xyes
+then :
   MSVCRTFLAGS="$MSVCRTFLAGS -fno-builtin"
 fi
-       { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fshort-wchar" >&5
-$as_echo_n "checking whether the compiler supports -fshort-wchar... " >&6; }
-if ${ac_cv_cflags__fshort_wchar+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fshort-wchar" >&5
+printf %s "checking whether the compiler supports -fshort-wchar... " >&6; }
+if test ${ac_cv_cflags__fshort_wchar+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fshort-wchar"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fshort_wchar=yes
-else
+else $as_nop
   ac_cv_cflags__fshort_wchar=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fshort_wchar" >&5
-$as_echo "$ac_cv_cflags__fshort_wchar" >&6; }
-if test "x$ac_cv_cflags__fshort_wchar" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fshort_wchar" >&5
+printf "%s\n" "$ac_cv_cflags__fshort_wchar" >&6; }
+if test "x$ac_cv_cflags__fshort_wchar" = xyes
+then :
   MSVCRTFLAGS="$MSVCRTFLAGS -fshort-wchar"
 fi ;;
   esac
 
   case $host_cpu in
-        *i[3456789]86*) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-omit-frame-pointer" >&5
-$as_echo_n "checking whether the compiler supports -fno-omit-frame-pointer... " >&6; }
-if ${ac_cv_cflags__fno_omit_frame_pointer+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        *i[3456789]86*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-omit-frame-pointer" >&5
+printf %s "checking whether the compiler supports -fno-omit-frame-pointer... " >&6; }
+if test ${ac_cv_cflags__fno_omit_frame_pointer+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -fno-omit-frame-pointer"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__fno_omit_frame_pointer=yes
-else
+else $as_nop
   ac_cv_cflags__fno_omit_frame_pointer=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_omit_frame_pointer" >&5
-$as_echo "$ac_cv_cflags__fno_omit_frame_pointer" >&6; }
-if test "x$ac_cv_cflags__fno_omit_frame_pointer" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_omit_frame_pointer" >&5
+printf "%s\n" "$ac_cv_cflags__fno_omit_frame_pointer" >&6; }
+if test "x$ac_cv_cflags__fno_omit_frame_pointer" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -fno-omit-frame-pointer"
 fi ;;
     *x86_64*)
       case $host_os in
-                cygwin*|mingw32*) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wno-format" >&5
-$as_echo_n "checking whether the compiler supports -Wno-format... " >&6; }
-if ${ac_cv_cflags__Wno_format+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                cygwin*|mingw32*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wno-format" >&5
+printf %s "checking whether the compiler supports -Wno-format... " >&6; }
+if test ${ac_cv_cflags__Wno_format+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wno-format"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wno_format=yes
-else
+else $as_nop
   ac_cv_cflags__Wno_format=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wno_format" >&5
-$as_echo "$ac_cv_cflags__Wno_format" >&6; }
-if test "x$ac_cv_cflags__Wno_format" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wno_format" >&5
+printf "%s\n" "$ac_cv_cflags__Wno_format" >&6; }
+if test "x$ac_cv_cflags__Wno_format" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Wno-format"
 fi ;;
-                *) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -mabi=ms" >&5
-$as_echo_n "checking whether the compiler supports -mabi=ms... " >&6; }
-if ${ac_cv_cflags__mabi_ms+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+                *) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -mabi=ms" >&5
+printf %s "checking whether the compiler supports -mabi=ms... " >&6; }
+if test ${ac_cv_cflags__mabi_ms+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -mabi=ms"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__mabi_ms=yes
-else
+else $as_nop
   ac_cv_cflags__mabi_ms=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__mabi_ms" >&5
-$as_echo "$ac_cv_cflags__mabi_ms" >&6; }
-if test "x$ac_cv_cflags__mabi_ms" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__mabi_ms" >&5
+printf "%s\n" "$ac_cv_cflags__mabi_ms" >&6; }
+if test "x$ac_cv_cflags__mabi_ms" = xyes
+then :
   MSVCRTFLAGS="$MSVCRTFLAGS -mabi=ms"
 fi ;;
       esac ;;
@@ -16636,57 +19126,63 @@ fi ;;
 
     if test "x$enable_werror" = "xyes"
   then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror" >&5
-$as_echo_n "checking whether the compiler supports -Werror... " >&6; }
-if ${ac_cv_cflags__Werror+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror" >&5
+printf %s "checking whether the compiler supports -Werror... " >&6; }
+if test ${ac_cv_cflags__Werror+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Werror"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Werror=yes
-else
+else $as_nop
   ac_cv_cflags__Werror=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror" >&5
-$as_echo "$ac_cv_cflags__Werror" >&6; }
-if test "x$ac_cv_cflags__Werror" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror" >&5
+printf "%s\n" "$ac_cv_cflags__Werror" >&6; }
+if test "x$ac_cv_cflags__Werror" = xyes
+then :
   EXTRACFLAGS="$EXTRACFLAGS -Werror"
 fi
   fi
   if test "x$enable_build_id" = "xyes"
   then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--build-id" >&5
-$as_echo_n "checking whether the compiler supports -Wl,--build-id... " >&6; }
-if ${ac_cv_cflags__Wl___build_id+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--build-id" >&5
+printf %s "checking whether the compiler supports -Wl,--build-id... " >&6; }
+if test ${ac_cv_cflags__Wl___build_id+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_wine_try_cflags_saved=$CFLAGS
 CFLAGS="$CFLAGS -Wl,--build-id"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 int main(int argc, char **argv) { return 0; }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_cflags__Wl___build_id=yes
-else
+else $as_nop
   ac_cv_cflags__Wl___build_id=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 CFLAGS=$ac_wine_try_cflags_saved
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___build_id" >&5
-$as_echo "$ac_cv_cflags__Wl___build_id" >&6; }
-if test "x$ac_cv_cflags__Wl___build_id" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___build_id" >&5
+printf "%s\n" "$ac_cv_cflags__Wl___build_id" >&6; }
+if test "x$ac_cv_cflags__Wl___build_id" = xyes
+then :
   CFLAGS="$CFLAGS -Wl,--build-id"
                       LDFLAGS="$LDFLAGS -Wl,--build-id"
 fi
@@ -16694,16 +19190,17 @@ fi
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for the need to disable Fortify" >&5
-$as_echo_n "checking for the need to disable Fortify... " >&6; }
-if ${ac_cv_c_fortify_enabled+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for the need to disable Fortify" >&5
+printf %s "checking for the need to disable Fortify... " >&6; }
+if test ${ac_cv_c_fortify_enabled+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <string.h>
 int
-main ()
+main (void)
 {
 #if (defined(__USE_FORTIFY_LEVEL) && __USE_FORTIFY_LEVEL > 0) || (defined(_FORTIFY_SOURCE) && _FORTIFY_SOURCE > 0)
 #error Fortify enabled
@@ -16712,46 +19209,49 @@ main ()
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_c_fortify_enabled=no
-else
+else $as_nop
   ac_cv_c_fortify_enabled=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_fortify_enabled" >&5
-$as_echo "$ac_cv_c_fortify_enabled" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_fortify_enabled" >&5
+printf "%s\n" "$ac_cv_c_fortify_enabled" >&6; }
 if test "$ac_cv_c_fortify_enabled" = yes
 then
     CFLAGS="$CFLAGS -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0"
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether CFI directives are supported in assembly code" >&5
-$as_echo_n "checking whether CFI directives are supported in assembly code... " >&6; }
-if ${ac_cv_c_cfi_support+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether CFI directives are supported in assembly code" >&5
+printf %s "checking whether CFI directives are supported in assembly code... " >&6; }
+if test ${ac_cv_c_cfi_support+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 asm(".text\nac_test:\t.cfi_startproc\n\t.long 0\n\t.cfi_endproc");
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_c_cfi_support="yes"
-else
+else $as_nop
   ac_cv_c_cfi_support="no"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_cfi_support" >&5
-$as_echo "$ac_cv_c_cfi_support" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_cfi_support" >&5
+printf "%s\n" "$ac_cv_c_cfi_support" >&6; }
 if test "$ac_cv_c_cfi_support" = "yes"
 then
    DLLFLAGS="$DLLFLAGS -fasynchronous-unwind-tables"
@@ -16784,50 +19284,159 @@ esac
 
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS="$CFLAGS $BUILTINFLAG"
-for ac_func in \
-	epoll_create \
-	fstatfs \
-	futimens \
-	futimes \
-	futimesat \
-	getattrlist \
-	getauxval \
-	getifaddrs \
-	getrandom \
-	kqueue \
-	mach_continuous_time \
-	pipe2 \
-	port_create \
-	posix_fadvise \
-	posix_fallocate \
-	ppoll \
-	prctl \
-	proc_pidinfo \
-	setproctitle \
-	setprogname \
-	sigprocmask \
-	sysinfo \
-	tcdrain \
-	thr_kill2
+ac_fn_c_check_func "$LINENO" "epoll_create" "ac_cv_func_epoll_create"
+if test "x$ac_cv_func_epoll_create" = xyes
+then :
+  printf "%s\n" "#define HAVE_EPOLL_CREATE 1" >>confdefs.h
 
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+fi
+ac_fn_c_check_func "$LINENO" "fstatfs" "ac_cv_func_fstatfs"
+if test "x$ac_cv_func_fstatfs" = xyes
+then :
+  printf "%s\n" "#define HAVE_FSTATFS 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "futimens" "ac_cv_func_futimens"
+if test "x$ac_cv_func_futimens" = xyes
+then :
+  printf "%s\n" "#define HAVE_FUTIMENS 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "futimes" "ac_cv_func_futimes"
+if test "x$ac_cv_func_futimes" = xyes
+then :
+  printf "%s\n" "#define HAVE_FUTIMES 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "futimesat" "ac_cv_func_futimesat"
+if test "x$ac_cv_func_futimesat" = xyes
+then :
+  printf "%s\n" "#define HAVE_FUTIMESAT 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getattrlist" "ac_cv_func_getattrlist"
+if test "x$ac_cv_func_getattrlist" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETATTRLIST 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getauxval" "ac_cv_func_getauxval"
+if test "x$ac_cv_func_getauxval" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETAUXVAL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getifaddrs" "ac_cv_func_getifaddrs"
+if test "x$ac_cv_func_getifaddrs" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETIFADDRS 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getrandom" "ac_cv_func_getrandom"
+if test "x$ac_cv_func_getrandom" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETRANDOM 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "kqueue" "ac_cv_func_kqueue"
+if test "x$ac_cv_func_kqueue" = xyes
+then :
+  printf "%s\n" "#define HAVE_KQUEUE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "mach_continuous_time" "ac_cv_func_mach_continuous_time"
+if test "x$ac_cv_func_mach_continuous_time" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACH_CONTINUOUS_TIME 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "pipe2" "ac_cv_func_pipe2"
+if test "x$ac_cv_func_pipe2" = xyes
+then :
+  printf "%s\n" "#define HAVE_PIPE2 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "port_create" "ac_cv_func_port_create"
+if test "x$ac_cv_func_port_create" = xyes
+then :
+  printf "%s\n" "#define HAVE_PORT_CREATE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "posix_fadvise" "ac_cv_func_posix_fadvise"
+if test "x$ac_cv_func_posix_fadvise" = xyes
+then :
+  printf "%s\n" "#define HAVE_POSIX_FADVISE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "posix_fallocate" "ac_cv_func_posix_fallocate"
+if test "x$ac_cv_func_posix_fallocate" = xyes
+then :
+  printf "%s\n" "#define HAVE_POSIX_FALLOCATE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ppoll" "ac_cv_func_ppoll"
+if test "x$ac_cv_func_ppoll" = xyes
+then :
+  printf "%s\n" "#define HAVE_PPOLL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "prctl" "ac_cv_func_prctl"
+if test "x$ac_cv_func_prctl" = xyes
+then :
+  printf "%s\n" "#define HAVE_PRCTL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "proc_pidinfo" "ac_cv_func_proc_pidinfo"
+if test "x$ac_cv_func_proc_pidinfo" = xyes
+then :
+  printf "%s\n" "#define HAVE_PROC_PIDINFO 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "setproctitle" "ac_cv_func_setproctitle"
+if test "x$ac_cv_func_setproctitle" = xyes
+then :
+  printf "%s\n" "#define HAVE_SETPROCTITLE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "setprogname" "ac_cv_func_setprogname"
+if test "x$ac_cv_func_setprogname" = xyes
+then :
+  printf "%s\n" "#define HAVE_SETPROGNAME 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "sigprocmask" "ac_cv_func_sigprocmask"
+if test "x$ac_cv_func_sigprocmask" = xyes
+then :
+  printf "%s\n" "#define HAVE_SIGPROCMASK 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "sysinfo" "ac_cv_func_sysinfo"
+if test "x$ac_cv_func_sysinfo" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYSINFO 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "tcdrain" "ac_cv_func_tcdrain"
+if test "x$ac_cv_func_tcdrain" = xyes
+then :
+  printf "%s\n" "#define HAVE_TCDRAIN 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "thr_kill2" "ac_cv_func_thr_kill2"
+if test "x$ac_cv_func_thr_kill2" = xyes
+then :
+  printf "%s\n" "#define HAVE_THR_KILL2 1" >>confdefs.h
 
 fi
-done
 
 CFLAGS="$ac_save_CFLAGS"
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing dlopen" >&5
-$as_echo_n "checking for library containing dlopen... " >&6; }
-if ${ac_cv_search_dlopen+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing dlopen" >&5
+printf %s "checking for library containing dlopen... " >&6; }
+if test ${ac_cv_search_dlopen+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -16835,70 +19444,69 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char dlopen ();
 int
-main ()
+main (void)
 {
 return dlopen ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' dl; do
+for ac_lib in '' dl
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_dlopen=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_dlopen+:} false; then :
+  if test ${ac_cv_search_dlopen+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_dlopen+:} false; then :
+if test ${ac_cv_search_dlopen+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_dlopen=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen" >&5
-$as_echo "$ac_cv_search_dlopen" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen" >&5
+printf "%s\n" "$ac_cv_search_dlopen" >&6; }
 ac_res=$ac_cv_search_dlopen
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
 fi
 
 ac_wine_check_funcs_save_LIBS="$LIBS"
 LIBS="$LIBS $DL_LIBS"
-for ac_func in dlinfo
-do :
-  ac_fn_c_check_func "$LINENO" "dlinfo" "ac_cv_func_dlinfo"
-if test "x$ac_cv_func_dlinfo" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DLINFO 1
-_ACEOF
+ac_fn_c_check_func "$LINENO" "dlinfo" "ac_cv_func_dlinfo"
+if test "x$ac_cv_func_dlinfo" = xyes
+then :
+  printf "%s\n" "#define HAVE_DLINFO 1" >>confdefs.h
 
 fi
-done
 
 LIBS="$ac_wine_check_funcs_save_LIBS"
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing gethostbyname" >&5
-$as_echo_n "checking for library containing gethostbyname... " >&6; }
-if ${ac_cv_search_gethostbyname+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing gethostbyname" >&5
+printf %s "checking for library containing gethostbyname... " >&6; }
+if test ${ac_cv_search_gethostbyname+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -16906,56 +19514,59 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gethostbyname ();
 int
-main ()
+main (void)
 {
 return gethostbyname ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' nsl; do
+for ac_lib in '' nsl
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_gethostbyname=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_gethostbyname+:} false; then :
+  if test ${ac_cv_search_gethostbyname+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_gethostbyname+:} false; then :
+if test ${ac_cv_search_gethostbyname+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_gethostbyname=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_gethostbyname" >&5
-$as_echo "$ac_cv_search_gethostbyname" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_gethostbyname" >&5
+printf "%s\n" "$ac_cv_search_gethostbyname" >&6; }
 ac_res=$ac_cv_search_gethostbyname
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing connect" >&5
-$as_echo_n "checking for library containing connect... " >&6; }
-if ${ac_cv_search_connect+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing connect" >&5
+printf %s "checking for library containing connect... " >&6; }
+if test ${ac_cv_search_connect+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -16963,56 +19574,59 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char connect ();
 int
-main ()
+main (void)
 {
 return connect ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' socket; do
+for ac_lib in '' socket
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_connect=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_connect+:} false; then :
+  if test ${ac_cv_search_connect+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_connect+:} false; then :
+if test ${ac_cv_search_connect+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_connect=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_connect" >&5
-$as_echo "$ac_cv_search_connect" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_connect" >&5
+printf "%s\n" "$ac_cv_search_connect" >&6; }
 ac_res=$ac_cv_search_connect
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing inet_aton" >&5
-$as_echo_n "checking for library containing inet_aton... " >&6; }
-if ${ac_cv_search_inet_aton+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing inet_aton" >&5
+printf %s "checking for library containing inet_aton... " >&6; }
+if test ${ac_cv_search_inet_aton+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -17020,71 +19634,70 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char inet_aton ();
 int
-main ()
+main (void)
 {
 return inet_aton ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' resolv; do
+for ac_lib in '' resolv
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_inet_aton=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_inet_aton+:} false; then :
+  if test ${ac_cv_search_inet_aton+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_inet_aton+:} false; then :
+if test ${ac_cv_search_inet_aton+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_inet_aton=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_inet_aton" >&5
-$as_echo "$ac_cv_search_inet_aton" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_inet_aton" >&5
+printf "%s\n" "$ac_cv_search_inet_aton" >&6; }
 ac_res=$ac_cv_search_inet_aton
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
 fi
 
 
-for ac_func in getaddrinfo
-do :
-  ac_fn_c_check_func "$LINENO" "getaddrinfo" "ac_cv_func_getaddrinfo"
-if test "x$ac_cv_func_getaddrinfo" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_GETADDRINFO 1
-_ACEOF
+ac_fn_c_check_func "$LINENO" "getaddrinfo" "ac_cv_func_getaddrinfo"
+if test "x$ac_cv_func_getaddrinfo" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETADDRINFO 1" >>confdefs.h
 
 fi
-done
 
 
 case $host_os in
     darwin*|macosx*) ;;
     *) ac_save_LIBS=$LIBS
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
-$as_echo_n "checking for library containing clock_gettime... " >&6; }
-if ${ac_cv_search_clock_gettime+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
+printf %s "checking for library containing clock_gettime... " >&6; }
+if test ${ac_cv_search_clock_gettime+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -17092,49 +19705,51 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char clock_gettime ();
 int
-main ()
+main (void)
 {
 return clock_gettime ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' rt; do
+for ac_lib in '' rt
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_clock_gettime=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_clock_gettime+:} false; then :
+  if test ${ac_cv_search_clock_gettime+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_clock_gettime+:} false; then :
+if test ${ac_cv_search_clock_gettime+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_clock_gettime=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime" >&5
-$as_echo "$ac_cv_search_clock_gettime" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime" >&5
+printf "%s\n" "$ac_cv_search_clock_gettime" >&6; }
 ac_res=$ac_cv_search_clock_gettime
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
-$as_echo "#define HAVE_CLOCK_GETTIME 1" >>confdefs.h
+printf "%s\n" "#define HAVE_CLOCK_GETTIME 1" >>confdefs.h
 
                 test "$ac_res" = "none required" || RT_LIBS="$ac_res"
 
@@ -17147,11 +19762,12 @@ esac
 if test "$ac_cv_header_sys_mman_h" = "yes" -a "x$RT_LIBS" = "x"
 then
     ac_save_LIBS=$LIBS
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing shm_open" >&5
-$as_echo_n "checking for library containing shm_open... " >&6; }
-if ${ac_cv_search_shm_open+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing shm_open" >&5
+printf %s "checking for library containing shm_open... " >&6; }
+if test ${ac_cv_search_shm_open+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -17159,49 +19775,51 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char shm_open ();
 int
-main ()
+main (void)
 {
 return shm_open ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' rt; do
+for ac_lib in '' rt
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_shm_open=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_shm_open+:} false; then :
+  if test ${ac_cv_search_shm_open+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_shm_open+:} false; then :
+if test ${ac_cv_search_shm_open+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_shm_open=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_shm_open" >&5
-$as_echo "$ac_cv_search_shm_open" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_shm_open" >&5
+printf "%s\n" "$ac_cv_search_shm_open" >&6; }
 ac_res=$ac_cv_search_shm_open
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
-$as_echo "#define HAVE_SHM_OPEN 1" >>confdefs.h
+printf "%s\n" "#define HAVE_SHM_OPEN 1" >>confdefs.h
 
                     test "$ac_res" = "none required" || RT_LIBS="$ac_res"
 
@@ -17212,46 +19830,52 @@ LIBS=$ac_save_LIBS
 
 if test "x$with_ldap" != "xno"
 then
-        if ${LDAP_CFLAGS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+        if ${LDAP_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   LDAP_CFLAGS=`$PKG_CONFIG --cflags openldap 2>/dev/null`
 fi
 fi
 
-if ${LDAP_LIBS:+false} :; then :
-  if ${PKG_CONFIG+:} false; then :
+if ${LDAP_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
   LDAP_LIBS=`$PKG_CONFIG --libs openldap 2>/dev/null`
 fi
 fi
 
 LDAP_LIBS=${LDAP_LIBS:-"-lldap_r -llber"}
-$as_echo "$as_me:${as_lineno-$LINENO}: openldap cflags: $LDAP_CFLAGS" >&5
-$as_echo "$as_me:${as_lineno-$LINENO}: openldap libs: $LDAP_LIBS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: openldap cflags: $LDAP_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: openldap libs: $LDAP_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $LDAP_CFLAGS"
-for ac_header in ldap.h lber.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+ac_fn_c_check_header_compile "$LINENO" "ldap.h" "ac_cv_header_ldap_h" "$ac_includes_default"
+if test "x$ac_cv_header_ldap_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "lber.h" "ac_cv_header_lber_h" "$ac_includes_default"
+if test "x$ac_cv_header_lber_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LBER_H 1" >>confdefs.h
 
-done
+fi
 
         if test "$ac_cv_header_ldap_h" = "yes" -a "$ac_cv_header_lber_h" = "yes"
         then
             ac_fn_c_check_type "$LINENO" "LDAPSortKey" "ac_cv_type_LDAPSortKey" "#include <ldap.h>
 "
-if test "x$ac_cv_type_LDAPSortKey" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ldap_initialize in -lldap_r" >&5
-$as_echo_n "checking for ldap_initialize in -lldap_r... " >&6; }
-if ${ac_cv_lib_ldap_r_ldap_initialize+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+if test "x$ac_cv_type_LDAPSortKey" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for ldap_initialize in -lldap_r" >&5
+printf %s "checking for ldap_initialize in -lldap_r... " >&6; }
+if test ${ac_cv_lib_ldap_r_ldap_initialize+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lldap_r $PTHREAD_LIBS $LDAP_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -17260,35 +19884,35 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char ldap_initialize ();
 int
-main ()
+main (void)
 {
 return ldap_initialize ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_ldap_r_ldap_initialize=yes
-else
+else $as_nop
   ac_cv_lib_ldap_r_ldap_initialize=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ldap_r_ldap_initialize" >&5
-$as_echo "$ac_cv_lib_ldap_r_ldap_initialize" >&6; }
-if test "x$ac_cv_lib_ldap_r_ldap_initialize" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ber_init in -llber" >&5
-$as_echo_n "checking for ber_init in -llber... " >&6; }
-if ${ac_cv_lib_lber_ber_init+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ldap_r_ldap_initialize" >&5
+printf "%s\n" "$ac_cv_lib_ldap_r_ldap_initialize" >&6; }
+if test "x$ac_cv_lib_ldap_r_ldap_initialize" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for ber_init in -llber" >&5
+printf %s "checking for ber_init in -llber... " >&6; }
+if test ${ac_cv_lib_lber_ber_init+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-llber $PTHREAD_LIBS $LDAP_LIBS $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -17297,66 +19921,94 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char ber_init ();
 int
-main ()
+main (void)
 {
 return ber_init ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_lber_ber_init=yes
-else
+else $as_nop
   ac_cv_lib_lber_ber_init=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lber_ber_init" >&5
-$as_echo "$ac_cv_lib_lber_ber_init" >&6; }
-if test "x$ac_cv_lib_lber_ber_init" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lber_ber_init" >&5
+printf "%s\n" "$ac_cv_lib_lber_ber_init" >&6; }
+if test "x$ac_cv_lib_lber_ber_init" = xyes
+then :
 
-$as_echo "#define HAVE_LDAP 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LDAP 1" >>confdefs.h
 
-else
+else $as_nop
   LDAP_LIBS=""
 fi
 
-else
+else $as_nop
   LDAP_LIBS=""
 fi
 
-else
+else $as_nop
   LDAP_LIBS=""
 fi
 
             ac_wine_check_funcs_save_LIBS="$LIBS"
 LIBS="$LIBS $LDAP_LIBS $PTHREAD_LIBS"
-for ac_func in \
-                ldap_count_references \
-                ldap_first_reference \
-                ldap_next_reference \
-                ldap_parse_reference \
-                ldap_parse_sort_control \
-                ldap_parse_sortresponse_control \
-                ldap_parse_vlv_control \
-                ldap_parse_vlvresponse_control
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+ac_fn_c_check_func "$LINENO" "ldap_count_references" "ac_cv_func_ldap_count_references"
+if test "x$ac_cv_func_ldap_count_references" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_COUNT_REFERENCES 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ldap_first_reference" "ac_cv_func_ldap_first_reference"
+if test "x$ac_cv_func_ldap_first_reference" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_FIRST_REFERENCE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ldap_next_reference" "ac_cv_func_ldap_next_reference"
+if test "x$ac_cv_func_ldap_next_reference" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_NEXT_REFERENCE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ldap_parse_reference" "ac_cv_func_ldap_parse_reference"
+if test "x$ac_cv_func_ldap_parse_reference" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_PARSE_REFERENCE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ldap_parse_sort_control" "ac_cv_func_ldap_parse_sort_control"
+if test "x$ac_cv_func_ldap_parse_sort_control" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_PARSE_SORT_CONTROL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ldap_parse_sortresponse_control" "ac_cv_func_ldap_parse_sortresponse_control"
+if test "x$ac_cv_func_ldap_parse_sortresponse_control" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_PARSE_SORTRESPONSE_CONTROL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ldap_parse_vlv_control" "ac_cv_func_ldap_parse_vlv_control"
+if test "x$ac_cv_func_ldap_parse_vlv_control" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_PARSE_VLV_CONTROL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "ldap_parse_vlvresponse_control" "ac_cv_func_ldap_parse_vlvresponse_control"
+if test "x$ac_cv_func_ldap_parse_vlvresponse_control" = xyes
+then :
+  printf "%s\n" "#define HAVE_LDAP_PARSE_VLVRESPONSE_CONTROL 1" >>confdefs.h
 
 fi
-done
 
 LIBS="$ac_wine_check_funcs_save_LIBS"
         else
@@ -17365,7 +20017,8 @@ LIBS="$ac_wine_check_funcs_save_LIBS"
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
-if test "x$LDAP_LIBS" = "x"; then :
+if test "x$LDAP_LIBS" = "x"
+then :
   case "x$with_ldap" in
   x)   as_fn_append wine_notices "|libldap (OpenLDAP) ${notice_platform}development files not found, LDAP won't be supported." ;;
   xno) ;;
@@ -17375,66 +20028,70 @@ esac
 
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sched_setaffinity" >&5
-$as_echo_n "checking for sched_setaffinity... " >&6; }
-if ${wine_cv_have_sched_setaffinity+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sched_setaffinity" >&5
+printf %s "checking for sched_setaffinity... " >&6; }
+if test ${wine_cv_have_sched_setaffinity+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sched.h>
 int
-main ()
+main (void)
 {
 sched_setaffinity(0, 0, 0);
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_have_sched_setaffinity=yes
-else
+else $as_nop
   wine_cv_have_sched_setaffinity=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_sched_setaffinity" >&5
-$as_echo "$wine_cv_have_sched_setaffinity" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_sched_setaffinity" >&5
+printf "%s\n" "$wine_cv_have_sched_setaffinity" >&6; }
 if test "$wine_cv_have_sched_setaffinity" = "yes"
 then
 
-$as_echo "#define HAVE_SCHED_SETAFFINITY 1" >>confdefs.h
+printf "%s\n" "#define HAVE_SCHED_SETAFFINITY 1" >>confdefs.h
 
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
-$as_echo_n "checking for inline... " >&6; }
-if ${ac_cv_c_inline+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for inline" >&5
+printf %s "checking for inline... " >&6; }
+if test ${ac_cv_c_inline+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __cplusplus
 typedef int foo_t;
-static $ac_kw foo_t static_foo () {return 0; }
-$ac_kw foo_t foo () {return 0; }
+static $ac_kw foo_t static_foo (void) {return 0; }
+$ac_kw foo_t foo (void) {return 0; }
 #endif
 
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_c_inline=$ac_kw
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
   test "$ac_cv_c_inline" != no && break
 done
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_inline" >&5
-$as_echo "$ac_cv_c_inline" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_inline" >&5
+printf "%s\n" "$ac_cv_c_inline" >&6; }
 
 case $ac_cv_c_inline in
   inline | yes) ;;
@@ -17454,22 +20111,20 @@ esac
 ac_fn_c_check_type "$LINENO" "sigset_t" "ac_cv_type_sigset_t" "#include <sys/types.h>
 #include <signal.h>
 "
-if test "x$ac_cv_type_sigset_t" = xyes; then :
+if test "x$ac_cv_type_sigset_t" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_SIGSET_T 1
-_ACEOF
+printf "%s\n" "#define HAVE_SIGSET_T 1" >>confdefs.h
 
 
 fi
 
 ac_fn_c_check_type "$LINENO" "request_sense" "ac_cv_type_request_sense" "#include <linux/cdrom.h>
 "
-if test "x$ac_cv_type_request_sense" = xyes; then :
+if test "x$ac_cv_type_request_sense" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_REQUEST_SENSE 1
-_ACEOF
+printf "%s\n" "#define HAVE_REQUEST_SENSE 1" >>confdefs.h
 
 
 fi
@@ -17498,11 +20153,10 @@ ac_fn_c_check_type "$LINENO" "struct xinpgen" "ac_cv_type_struct_xinpgen" "#incl
 #include <netinet/in_pcb.h>
 #endif
 "
-if test "x$ac_cv_type_struct_xinpgen" = xyes; then :
+if test "x$ac_cv_type_struct_xinpgen" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_XINPGEN 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_XINPGEN 1" >>confdefs.h
 
 
 fi
@@ -17512,60 +20166,62 @@ ac_fn_c_check_member "$LINENO" "struct ff_effect" "direction" "ac_cv_member_stru
 #include <linux/input.h>
 #endif
 "
-if test "x$ac_cv_member_struct_ff_effect_direction" = xyes; then :
+if test "x$ac_cv_member_struct_ff_effect_direction" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_FF_EFFECT_DIRECTION 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_FF_EFFECT_DIRECTION 1" >>confdefs.h
 
 
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sigaddset" >&5
-$as_echo_n "checking for sigaddset... " >&6; }
-if ${wine_cv_have_sigaddset+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sigaddset" >&5
+printf %s "checking for sigaddset... " >&6; }
+if test ${wine_cv_have_sigaddset+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <signal.h>
 int
-main ()
+main (void)
 {
 sigset_t set; sigaddset(&set,SIGTERM);
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_have_sigaddset=yes
-else
+else $as_nop
   wine_cv_have_sigaddset=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_sigaddset" >&5
-$as_echo "$wine_cv_have_sigaddset" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_sigaddset" >&5
+printf "%s\n" "$wine_cv_have_sigaddset" >&6; }
 if test "$wine_cv_have_sigaddset" = "yes"
 then
 
-$as_echo "#define HAVE_SIGADDSET 1" >>confdefs.h
+printf "%s\n" "#define HAVE_SIGADDSET 1" >>confdefs.h
 
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can use re-entrant gethostbyname_r Linux style" >&5
-$as_echo_n "checking whether we can use re-entrant gethostbyname_r Linux style... " >&6; }
-if ${wine_cv_linux_gethostbyname_r_6+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we can use re-entrant gethostbyname_r Linux style" >&5
+printf %s "checking whether we can use re-entrant gethostbyname_r Linux style... " >&6; }
+if test ${wine_cv_linux_gethostbyname_r_6+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <netdb.h>
 int
-main ()
+main (void)
 {
 
     char *name=0;
@@ -17584,32 +20240,34 @@ main ()
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   wine_cv_linux_gethostbyname_r_6=yes
-else
+else $as_nop
   wine_cv_linux_gethostbyname_r_6=no
 
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_linux_gethostbyname_r_6" >&5
-$as_echo "$wine_cv_linux_gethostbyname_r_6" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_linux_gethostbyname_r_6" >&5
+printf "%s\n" "$wine_cv_linux_gethostbyname_r_6" >&6; }
    if test "$wine_cv_linux_gethostbyname_r_6" = "yes"
    then
 
-$as_echo "#define HAVE_LINUX_GETHOSTBYNAME_R_6 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LINUX_GETHOSTBYNAME_R_6 1" >>confdefs.h
 
    fi
 
 if test "$ac_cv_header_linux_joystick_h" = "yes"
 then
-   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether linux/joystick.h uses the Linux 2.2+ API" >&5
-$as_echo_n "checking whether linux/joystick.h uses the Linux 2.2+ API... " >&6; }
-if ${wine_cv_linux_joystick_22_api+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether linux/joystick.h uses the Linux 2.2+ API" >&5
+printf %s "checking whether linux/joystick.h uses the Linux 2.2+ API... " >&6; }
+if test ${wine_cv_linux_joystick_22_api+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -17623,27 +20281,28 @@ else
 	#endif
 
 int
-main ()
+main (void)
 {
 /*empty*/
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   wine_cv_linux_joystick_22_api=yes
-else
+else $as_nop
   wine_cv_linux_joystick_22_api=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_linux_joystick_22_api" >&5
-$as_echo "$wine_cv_linux_joystick_22_api" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_linux_joystick_22_api" >&5
+printf "%s\n" "$wine_cv_linux_joystick_22_api" >&6; }
    if test "$wine_cv_linux_joystick_22_api" = "yes"
    then
 
-$as_echo "#define HAVE_LINUX_22_JOYSTICK_API 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LINUX_22_JOYSTICK_API 1" >>confdefs.h
 
    fi
 fi
@@ -17656,11 +20315,10 @@ ac_fn_c_check_member "$LINENO" "struct msghdr" "msg_accrights" "ac_cv_member_str
 # include <sys/un.h>
 #endif
 "
-if test "x$ac_cv_member_struct_msghdr_msg_accrights" = xyes; then :
+if test "x$ac_cv_member_struct_msghdr_msg_accrights" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS 1" >>confdefs.h
 
 
 fi
@@ -17672,11 +20330,10 @@ ac_fn_c_check_member "$LINENO" "struct sockaddr_un" "sun_len" "ac_cv_member_stru
 # include <sys/un.h>
 #endif
 "
-if test "x$ac_cv_member_struct_sockaddr_un_sun_len" = xyes; then :
+if test "x$ac_cv_member_struct_sockaddr_un_sun_len" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SOCKADDR_UN_SUN_LEN 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_SOCKADDR_UN_SUN_LEN 1" >>confdefs.h
 
 
 fi
@@ -17687,11 +20344,10 @@ ac_fn_c_check_member "$LINENO" "scsireq_t" "cmd" "ac_cv_member_scsireq_t_cmd" "#
 #include <scsi/sg.h>
 #endif
 "
-if test "x$ac_cv_member_scsireq_t_cmd" = xyes; then :
+if test "x$ac_cv_member_scsireq_t_cmd" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_SCSIREQ_T_CMD 1
-_ACEOF
+printf "%s\n" "#define HAVE_SCSIREQ_T_CMD 1" >>confdefs.h
 
 
 fi
@@ -17700,11 +20356,10 @@ ac_fn_c_check_member "$LINENO" "sg_io_hdr_t" "interface_id" "ac_cv_member_sg_io_
 #include <scsi/sg.h>
 #endif
 "
-if test "x$ac_cv_member_sg_io_hdr_t_interface_id" = xyes; then :
+if test "x$ac_cv_member_sg_io_hdr_t_interface_id" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_SG_IO_HDR_T_INTERFACE_ID 1
-_ACEOF
+printf "%s\n" "#define HAVE_SG_IO_HDR_T_INTERFACE_ID 1" >>confdefs.h
 
 
 fi
@@ -17712,11 +20367,10 @@ fi
 
 ac_fn_c_check_member "$LINENO" "siginfo_t" "si_fd" "ac_cv_member_siginfo_t_si_fd" "#include <signal.h>
 "
-if test "x$ac_cv_member_siginfo_t_si_fd" = xyes; then :
+if test "x$ac_cv_member_siginfo_t_si_fd" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_SIGINFO_T_SI_FD 1
-_ACEOF
+printf "%s\n" "#define HAVE_SIGINFO_T_SI_FD 1" >>confdefs.h
 
 
 fi
@@ -17727,11 +20381,10 @@ ac_fn_c_check_member "$LINENO" "struct mtget" "mt_blksiz" "ac_cv_member_struct_m
 #include <sys/mtio.h>
 #endif
 "
-if test "x$ac_cv_member_struct_mtget_mt_blksiz" = xyes; then :
+if test "x$ac_cv_member_struct_mtget_mt_blksiz" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_MTGET_MT_BLKSIZ 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_MTGET_MT_BLKSIZ 1" >>confdefs.h
 
 
 fi
@@ -17740,11 +20393,10 @@ ac_fn_c_check_member "$LINENO" "struct mtget" "mt_gstat" "ac_cv_member_struct_mt
 #include <sys/mtio.h>
 #endif
 "
-if test "x$ac_cv_member_struct_mtget_mt_gstat" = xyes; then :
+if test "x$ac_cv_member_struct_mtget_mt_gstat" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_MTGET_MT_GSTAT 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_MTGET_MT_GSTAT 1" >>confdefs.h
 
 
 fi
@@ -17753,112 +20405,100 @@ ac_fn_c_check_member "$LINENO" "struct mtget" "mt_blkno" "ac_cv_member_struct_mt
 #include <sys/mtio.h>
 #endif
 "
-if test "x$ac_cv_member_struct_mtget_mt_blkno" = xyes; then :
+if test "x$ac_cv_member_struct_mtget_mt_blkno" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_MTGET_MT_BLKNO 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_MTGET_MT_BLKNO 1" >>confdefs.h
 
 
 fi
 
 
 ac_fn_c_check_member "$LINENO" "struct stat" "st_mtim" "ac_cv_member_struct_stat_st_mtim" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_mtim" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_mtim" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_MTIM 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_MTIM 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_mtimespec" "ac_cv_member_struct_stat_st_mtimespec" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_mtimespec" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_mtimespec" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_MTIMESPEC 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_MTIMESPEC 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_ctim" "ac_cv_member_struct_stat_st_ctim" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_ctim" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_ctim" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_CTIM 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_CTIM 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_ctimespec" "ac_cv_member_struct_stat_st_ctimespec" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_ctimespec" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_ctimespec" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_CTIMESPEC 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_CTIMESPEC 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_atim" "ac_cv_member_struct_stat_st_atim" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_atim" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_atim" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_ATIM 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_ATIM 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_atimespec" "ac_cv_member_struct_stat_st_atimespec" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_atimespec" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_atimespec" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_ATIMESPEC 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_ATIMESPEC 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_birthtime" "ac_cv_member_struct_stat_st_birthtime" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_birthtime" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_birthtime" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_BIRTHTIME 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_BIRTHTIME 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_birthtim" "ac_cv_member_struct_stat_st_birthtim" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_birthtim" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_birthtim" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_BIRTHTIM 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_BIRTHTIM 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "st_birthtimespec" "ac_cv_member_struct_stat_st_birthtimespec" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat_st_birthtimespec" = xyes; then :
+if test "x$ac_cv_member_struct_stat_st_birthtimespec" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "__st_birthtime" "ac_cv_member_struct_stat___st_birthtime" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat___st_birthtime" = xyes; then :
+if test "x$ac_cv_member_struct_stat___st_birthtime" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT___ST_BIRTHTIME 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT___ST_BIRTHTIME 1" >>confdefs.h
 
 
 fi
 ac_fn_c_check_member "$LINENO" "struct stat" "__st_birthtim" "ac_cv_member_struct_stat___st_birthtim" "$ac_includes_default"
-if test "x$ac_cv_member_struct_stat___st_birthtim" = xyes; then :
+if test "x$ac_cv_member_struct_stat___st_birthtim" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT___ST_BIRTHTIM 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_STAT___ST_BIRTHTIM 1" >>confdefs.h
 
 
 fi
@@ -17871,11 +20511,10 @@ ac_fn_c_check_member "$LINENO" "struct sockaddr_in6" "sin6_scope_id" "ac_cv_memb
 #include <netinet/in.h>
 #endif
 "
-if test "x$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" = xyes; then :
+if test "x$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1" >>confdefs.h
 
 
 fi
@@ -17891,11 +20530,10 @@ ac_fn_c_check_type "$LINENO" "struct __res_state" "ac_cv_type_struct___res_state
 #include <resolv.h>
 #endif
 "
-if test "x$ac_cv_type_struct___res_state" = xyes; then :
+if test "x$ac_cv_type_struct___res_state" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT___RES_STATE 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT___RES_STATE 1" >>confdefs.h
 
 
 fi
@@ -17905,11 +20543,10 @@ ac_fn_c_check_member "$LINENO" "struct __res_state" "_u._ext.nscount6" "ac_cv_me
 #include <resolv.h>
 #endif
 "
-if test "x$ac_cv_member_struct___res_state__u__ext_nscount6" = xyes; then :
+if test "x$ac_cv_member_struct___res_state__u__ext_nscount6" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT___RES_STATE__U__EXT_NSCOUNT6 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT___RES_STATE__U__EXT_NSCOUNT6 1" >>confdefs.h
 
 
 fi
@@ -17931,11 +20568,10 @@ ac_fn_c_check_member "$LINENO" "struct icmpstat" "icps_inhist" "ac_cv_member_str
 #include <netinet/icmp_var.h>
 #endif
 "
-if test "x$ac_cv_member_struct_icmpstat_icps_inhist" = xyes; then :
+if test "x$ac_cv_member_struct_icmpstat_icps_inhist" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_ICMPSTAT_ICPS_INHIST 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_ICMPSTAT_ICPS_INHIST 1" >>confdefs.h
 
 
 fi
@@ -17975,11 +20611,10 @@ ac_fn_c_check_member "$LINENO" "struct icmpstat" "icps_outhist" "ac_cv_member_st
 #include <netinet/icmp_var.h>
 #endif
 "
-if test "x$ac_cv_member_struct_icmpstat_icps_outhist" = xyes; then :
+if test "x$ac_cv_member_struct_icmpstat_icps_outhist" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_ICMPSTAT_ICPS_OUTHIST 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_ICMPSTAT_ICPS_OUTHIST 1" >>confdefs.h
 
 
 fi
@@ -17989,11 +20624,10 @@ ac_fn_c_check_member "$LINENO" "struct in6_pktinfo" "ipi6_addr" "ac_cv_member_st
 #include <netinet/in.h>
 #endif
 "
-if test "x$ac_cv_member_struct_in6_pktinfo_ipi6_addr" = xyes; then :
+if test "x$ac_cv_member_struct_in6_pktinfo_ipi6_addr" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_IN6_PKTINFO_IPI6_ADDR 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_IN6_PKTINFO_IPI6_ADDR 1" >>confdefs.h
 
 
 fi
@@ -18012,11 +20646,10 @@ ac_fn_c_check_member "$LINENO" "struct ipstat" "ips_total" "ac_cv_member_struct_
 #include <netinet/ip_var.h>
 #endif
 "
-if test "x$ac_cv_member_struct_ipstat_ips_total" = xyes; then :
+if test "x$ac_cv_member_struct_ipstat_ips_total" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_IPSTAT_IPS_TOTAL 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_IPSTAT_IPS_TOTAL 1" >>confdefs.h
 
 
 fi
@@ -18026,11 +20659,10 @@ ac_fn_c_check_member "$LINENO" "struct ip_stats" "ips_total" "ac_cv_member_struc
 #include <netinet/ip_var.h>
 #endif
 "
-if test "x$ac_cv_member_struct_ip_stats_ips_total" = xyes; then :
+if test "x$ac_cv_member_struct_ip_stats_ips_total" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_IP_STATS_IPS_TOTAL 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_IP_STATS_IPS_TOTAL 1" >>confdefs.h
 
 
 fi
@@ -18052,11 +20684,10 @@ ac_fn_c_check_member "$LINENO" "struct tcpstat" "tcps_connattempt" "ac_cv_member
 #include <netinet/tcp_var.h>
 #endif
 "
-if test "x$ac_cv_member_struct_tcpstat_tcps_connattempt" = xyes; then :
+if test "x$ac_cv_member_struct_tcpstat_tcps_connattempt" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_TCPSTAT_TCPS_CONNATTEMPT 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_TCPSTAT_TCPS_CONNATTEMPT 1" >>confdefs.h
 
 
 fi
@@ -18066,11 +20697,10 @@ ac_fn_c_check_member "$LINENO" "struct tcp_stats" "tcps_connattempt" "ac_cv_memb
 #include <netinet/tcp_var.h>
 #endif
 "
-if test "x$ac_cv_member_struct_tcp_stats_tcps_connattempt" = xyes; then :
+if test "x$ac_cv_member_struct_tcp_stats_tcps_connattempt" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_TCP_STATS_TCPS_CONNATTEMPT 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_TCP_STATS_TCPS_CONNATTEMPT 1" >>confdefs.h
 
 
 fi
@@ -18092,11 +20722,10 @@ ac_fn_c_check_member "$LINENO" "struct udpstat" "udps_ipackets" "ac_cv_member_st
 #include <netinet/udp_var.h>
 #endif
 "
-if test "x$ac_cv_member_struct_udpstat_udps_ipackets" = xyes; then :
+if test "x$ac_cv_member_struct_udpstat_udps_ipackets" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_UDPSTAT_UDPS_IPACKETS 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_UDPSTAT_UDPS_IPACKETS 1" >>confdefs.h
 
 
 fi
@@ -18109,11 +20738,10 @@ ac_fn_c_check_member "$LINENO" "struct ifreq" "ifr_hwaddr" "ac_cv_member_struct_
 # include <net/if.h>
 #endif
 "
-if test "x$ac_cv_member_struct_ifreq_ifr_hwaddr" = xyes; then :
+if test "x$ac_cv_member_struct_ifreq_ifr_hwaddr" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_IFREQ_IFR_HWADDR 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_IFREQ_IFR_HWADDR 1" >>confdefs.h
 
 
 fi
@@ -18123,11 +20751,10 @@ ac_fn_c_check_member "$LINENO" "struct sysinfo" "totalram" "ac_cv_member_struct_
 # include <sys/sysinfo.h>
 #endif
 "
-if test "x$ac_cv_member_struct_sysinfo_totalram" = xyes; then :
+if test "x$ac_cv_member_struct_sysinfo_totalram" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SYSINFO_TOTALRAM 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_SYSINFO_TOTALRAM 1" >>confdefs.h
 
 
 fi
@@ -18135,11 +20762,10 @@ ac_fn_c_check_member "$LINENO" "struct sysinfo" "mem_unit" "ac_cv_member_struct_
 # include <sys/sysinfo.h>
 #endif
 "
-if test "x$ac_cv_member_struct_sysinfo_mem_unit" = xyes; then :
+if test "x$ac_cv_member_struct_sysinfo_mem_unit" = xyes
+then :
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_SYSINFO_MEM_UNIT 1
-_ACEOF
+printf "%s\n" "#define HAVE_STRUCT_SYSINFO_MEM_UNIT 1" >>confdefs.h
 
 
 fi
@@ -18147,180 +20773,191 @@ fi
 
 ac_save_LIBS="$LIBS"
 LIBS="$LIBS -lm"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for isfinite" >&5
-$as_echo_n "checking for isfinite... " >&6; }
-if ${ac_cv_have_isfinite+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for isfinite" >&5
+printf %s "checking for isfinite... " >&6; }
+if test ${ac_cv_have_isfinite+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <math.h>
 int
-main ()
+main (void)
 {
 float f = 0.0; return isfinite(f)
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_have_isfinite="yes"
-else
+else $as_nop
   ac_cv_have_isfinite="no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_isfinite" >&5
-$as_echo "$ac_cv_have_isfinite" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_isfinite" >&5
+printf "%s\n" "$ac_cv_have_isfinite" >&6; }
 if test "$ac_cv_have_isfinite" = "yes"
 then
 
-$as_echo "#define HAVE_ISFINITE 1" >>confdefs.h
+printf "%s\n" "#define HAVE_ISFINITE 1" >>confdefs.h
 
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for isinf" >&5
-$as_echo_n "checking for isinf... " >&6; }
-if ${ac_cv_have_isinf+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for isinf" >&5
+printf %s "checking for isinf... " >&6; }
+if test ${ac_cv_have_isinf+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <math.h>
 int
-main ()
+main (void)
 {
 float f = 0.0; return isinf(f)
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_have_isinf="yes"
-else
+else $as_nop
   ac_cv_have_isinf="no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_isinf" >&5
-$as_echo "$ac_cv_have_isinf" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_isinf" >&5
+printf "%s\n" "$ac_cv_have_isinf" >&6; }
 if test "$ac_cv_have_isinf" = "yes"
 then
 
-$as_echo "#define HAVE_ISINF 1" >>confdefs.h
+printf "%s\n" "#define HAVE_ISINF 1" >>confdefs.h
 
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for isnan" >&5
-$as_echo_n "checking for isnan... " >&6; }
-if ${ac_cv_have_isnan+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for isnan" >&5
+printf %s "checking for isnan... " >&6; }
+if test ${ac_cv_have_isnan+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <math.h>
 int
-main ()
+main (void)
 {
 float f = 0.0; return isnan(f)
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_have_isnan="yes"
-else
+else $as_nop
   ac_cv_have_isnan="no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_isnan" >&5
-$as_echo "$ac_cv_have_isnan" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_isnan" >&5
+printf "%s\n" "$ac_cv_have_isnan" >&6; }
 if test "$ac_cv_have_isnan" = "yes"
 then
 
-$as_echo "#define HAVE_ISNAN 1" >>confdefs.h
+printf "%s\n" "#define HAVE_ISNAN 1" >>confdefs.h
 
 fi
 
 LIBS="$ac_save_LIBS"
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for __builtin_popcount" >&5
-$as_echo_n "checking for __builtin_popcount... " >&6; }
-if ${ac_cv_have___builtin_popcount+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for __builtin_popcount" >&5
+printf %s "checking for __builtin_popcount... " >&6; }
+if test ${ac_cv_have___builtin_popcount+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 return __builtin_popcount(1)
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_have___builtin_popcount="yes"
-else
+else $as_nop
   ac_cv_have___builtin_popcount="no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have___builtin_popcount" >&5
-$as_echo "$ac_cv_have___builtin_popcount" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have___builtin_popcount" >&5
+printf "%s\n" "$ac_cv_have___builtin_popcount" >&6; }
 if test "$ac_cv_have___builtin_popcount" = "yes"
 then
 
-$as_echo "#define HAVE___BUILTIN_POPCOUNT 1" >>confdefs.h
+printf "%s\n" "#define HAVE___BUILTIN_POPCOUNT 1" >>confdefs.h
 
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for __clear_cache" >&5
-$as_echo_n "checking for __clear_cache... " >&6; }
-if ${ac_cv_have___clear_cache+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for __clear_cache" >&5
+printf %s "checking for __clear_cache... " >&6; }
+if test ${ac_cv_have___clear_cache+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 __clear_cache((void*)0, (void*)0); return 0;
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_have___clear_cache="yes"
-else
+else $as_nop
   ac_cv_have___clear_cache="no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have___clear_cache" >&5
-$as_echo "$ac_cv_have___clear_cache" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have___clear_cache" >&5
+printf "%s\n" "$ac_cv_have___clear_cache" >&6; }
 if test "$ac_cv_have___clear_cache" = "yes"
 then
 
-$as_echo "#define HAVE___CLEAR_CACHE 1" >>confdefs.h
+printf "%s\n" "#define HAVE___CLEAR_CACHE 1" >>confdefs.h
 
 fi
 
 
 case $host_cpu in
-  *i[3456789]86*) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __i386__" >&5
-$as_echo_n "checking whether we need to define __i386__... " >&6; }
-if ${ac_cv_cpp_def___i386__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *i[3456789]86*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __i386__" >&5
+printf %s "checking whether we need to define __i386__... " >&6; }
+if test ${ac_cv_cpp_def___i386__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __i386__
@@ -18328,25 +20965,28 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___i386__=yes
-else
+else $as_nop
   ac_cv_cpp_def___i386__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___i386__" >&5
-$as_echo "$ac_cv_cpp_def___i386__" >&6; }
-if test "x$ac_cv_cpp_def___i386__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___i386__" >&5
+printf "%s\n" "$ac_cv_cpp_def___i386__" >&6; }
+if test "x$ac_cv_cpp_def___i386__" = xyes
+then :
   CFLAGS="$CFLAGS -D__i386__"
   LINTFLAGS="$LINTFLAGS -D__i386__"
 fi ;;
-  *x86_64*)         { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __x86_64__" >&5
-$as_echo_n "checking whether we need to define __x86_64__... " >&6; }
-if ${ac_cv_cpp_def___x86_64__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *x86_64*)         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __x86_64__" >&5
+printf %s "checking whether we need to define __x86_64__... " >&6; }
+if test ${ac_cv_cpp_def___x86_64__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __x86_64__
@@ -18354,25 +20994,28 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___x86_64__=yes
-else
+else $as_nop
   ac_cv_cpp_def___x86_64__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___x86_64__" >&5
-$as_echo "$ac_cv_cpp_def___x86_64__" >&6; }
-if test "x$ac_cv_cpp_def___x86_64__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___x86_64__" >&5
+printf "%s\n" "$ac_cv_cpp_def___x86_64__" >&6; }
+if test "x$ac_cv_cpp_def___x86_64__" = xyes
+then :
   CFLAGS="$CFLAGS -D__x86_64__"
   LINTFLAGS="$LINTFLAGS -D__x86_64__"
 fi ;;
-  *sparc64*)        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __sparc64__" >&5
-$as_echo_n "checking whether we need to define __sparc64__... " >&6; }
-if ${ac_cv_cpp_def___sparc64__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *sparc64*)        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __sparc64__" >&5
+printf %s "checking whether we need to define __sparc64__... " >&6; }
+if test ${ac_cv_cpp_def___sparc64__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __sparc64__
@@ -18380,25 +21023,28 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___sparc64__=yes
-else
+else $as_nop
   ac_cv_cpp_def___sparc64__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___sparc64__" >&5
-$as_echo "$ac_cv_cpp_def___sparc64__" >&6; }
-if test "x$ac_cv_cpp_def___sparc64__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___sparc64__" >&5
+printf "%s\n" "$ac_cv_cpp_def___sparc64__" >&6; }
+if test "x$ac_cv_cpp_def___sparc64__" = xyes
+then :
   CFLAGS="$CFLAGS -D__sparc64__"
   LINTFLAGS="$LINTFLAGS -D__sparc64__"
 fi ;;
-  *sparc*)          { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __sparc__" >&5
-$as_echo_n "checking whether we need to define __sparc__... " >&6; }
-if ${ac_cv_cpp_def___sparc__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *sparc*)          { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __sparc__" >&5
+printf %s "checking whether we need to define __sparc__... " >&6; }
+if test ${ac_cv_cpp_def___sparc__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __sparc__
@@ -18406,25 +21052,28 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___sparc__=yes
-else
+else $as_nop
   ac_cv_cpp_def___sparc__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___sparc__" >&5
-$as_echo "$ac_cv_cpp_def___sparc__" >&6; }
-if test "x$ac_cv_cpp_def___sparc__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___sparc__" >&5
+printf "%s\n" "$ac_cv_cpp_def___sparc__" >&6; }
+if test "x$ac_cv_cpp_def___sparc__" = xyes
+then :
   CFLAGS="$CFLAGS -D__sparc__"
   LINTFLAGS="$LINTFLAGS -D__sparc__"
 fi ;;
-  *powerpc64*)      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __powerpc64__" >&5
-$as_echo_n "checking whether we need to define __powerpc64__... " >&6; }
-if ${ac_cv_cpp_def___powerpc64__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *powerpc64*)      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __powerpc64__" >&5
+printf %s "checking whether we need to define __powerpc64__... " >&6; }
+if test ${ac_cv_cpp_def___powerpc64__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __powerpc64__
@@ -18432,25 +21081,28 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___powerpc64__=yes
-else
+else $as_nop
   ac_cv_cpp_def___powerpc64__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___powerpc64__" >&5
-$as_echo "$ac_cv_cpp_def___powerpc64__" >&6; }
-if test "x$ac_cv_cpp_def___powerpc64__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___powerpc64__" >&5
+printf "%s\n" "$ac_cv_cpp_def___powerpc64__" >&6; }
+if test "x$ac_cv_cpp_def___powerpc64__" = xyes
+then :
   CFLAGS="$CFLAGS -D__powerpc64__"
   LINTFLAGS="$LINTFLAGS -D__powerpc64__"
 fi ;;
-  *powerpc*)        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __powerpc__" >&5
-$as_echo_n "checking whether we need to define __powerpc__... " >&6; }
-if ${ac_cv_cpp_def___powerpc__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *powerpc*)        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __powerpc__" >&5
+printf %s "checking whether we need to define __powerpc__... " >&6; }
+if test ${ac_cv_cpp_def___powerpc__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __powerpc__
@@ -18458,25 +21110,28 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___powerpc__=yes
-else
+else $as_nop
   ac_cv_cpp_def___powerpc__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___powerpc__" >&5
-$as_echo "$ac_cv_cpp_def___powerpc__" >&6; }
-if test "x$ac_cv_cpp_def___powerpc__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___powerpc__" >&5
+printf "%s\n" "$ac_cv_cpp_def___powerpc__" >&6; }
+if test "x$ac_cv_cpp_def___powerpc__" = xyes
+then :
   CFLAGS="$CFLAGS -D__powerpc__"
   LINTFLAGS="$LINTFLAGS -D__powerpc__"
 fi ;;
-  *aarch64*)        { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __aarch64__" >&5
-$as_echo_n "checking whether we need to define __aarch64__... " >&6; }
-if ${ac_cv_cpp_def___aarch64__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *aarch64*)        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __aarch64__" >&5
+printf %s "checking whether we need to define __aarch64__... " >&6; }
+if test ${ac_cv_cpp_def___aarch64__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __aarch64__
@@ -18484,25 +21139,28 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___aarch64__=yes
-else
+else $as_nop
   ac_cv_cpp_def___aarch64__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___aarch64__" >&5
-$as_echo "$ac_cv_cpp_def___aarch64__" >&6; }
-if test "x$ac_cv_cpp_def___aarch64__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___aarch64__" >&5
+printf "%s\n" "$ac_cv_cpp_def___aarch64__" >&6; }
+if test "x$ac_cv_cpp_def___aarch64__" = xyes
+then :
   CFLAGS="$CFLAGS -D__aarch64__"
   LINTFLAGS="$LINTFLAGS -D__aarch64__"
 fi ;;
-  *arm*)            { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __arm__" >&5
-$as_echo_n "checking whether we need to define __arm__... " >&6; }
-if ${ac_cv_cpp_def___arm__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *arm*)            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __arm__" >&5
+printf %s "checking whether we need to define __arm__... " >&6; }
+if test ${ac_cv_cpp_def___arm__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __arm__
@@ -18510,28 +21168,31 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___arm__=yes
-else
+else $as_nop
   ac_cv_cpp_def___arm__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___arm__" >&5
-$as_echo "$ac_cv_cpp_def___arm__" >&6; }
-if test "x$ac_cv_cpp_def___arm__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___arm__" >&5
+printf "%s\n" "$ac_cv_cpp_def___arm__" >&6; }
+if test "x$ac_cv_cpp_def___arm__" = xyes
+then :
   CFLAGS="$CFLAGS -D__arm__"
   LINTFLAGS="$LINTFLAGS -D__arm__"
 fi ;;
 esac
 
 case $host_vendor in
-  *sun*) { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we need to define __sun__" >&5
-$as_echo_n "checking whether we need to define __sun__... " >&6; }
-if ${ac_cv_cpp_def___sun__+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  *sun*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __sun__" >&5
+printf %s "checking whether we need to define __sun__... " >&6; }
+if test ${ac_cv_cpp_def___sun__+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #ifndef __sun__
@@ -18539,17 +21200,19 @@ yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then :
+  $EGREP "yes" >/dev/null 2>&1
+then :
   ac_cv_cpp_def___sun__=yes
-else
+else $as_nop
   ac_cv_cpp_def___sun__=no
 fi
-rm -f conftest*
+rm -rf conftest*
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___sun__" >&5
-$as_echo "$ac_cv_cpp_def___sun__" >&6; }
-if test "x$ac_cv_cpp_def___sun__" = xyes; then :
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___sun__" >&5
+printf "%s\n" "$ac_cv_cpp_def___sun__" >&6; }
+if test "x$ac_cv_cpp_def___sun__" = xyes
+then :
   CFLAGS="$CFLAGS -D__sun__"
   LINTFLAGS="$LINTFLAGS -D__sun__"
 fi ;;
@@ -18561,7 +21224,7 @@ esac
 
 ac_config_commands="$ac_config_commands include/stamp-h"
 
-$as_echo_n "creating Makefile rules..." >&6
+printf %s "creating Makefile rules..." >&6
 
 ALL_VARS_RULES="I386_LIBS = $I386_LIBS
 OPENGL_LIBS = $OPENGL_LIBS
@@ -18660,6 +21323,8 @@ VKD3D_CFLAGS = $VKD3D_CFLAGS
 VKD3D_LIBS = $VKD3D_LIBS
 VKD3D_SHADER_CFLAGS = $VKD3D_SHADER_CFLAGS
 VKD3D_SHADER_LIBS = $VKD3D_SHADER_LIBS
+GCRYPT_CFLAGS = $GCRYPT_CFLAGS
+GCRYPT_LIBS = $GCRYPT_LIBS
 RT_LIBS = $RT_LIBS
 LDAP_CFLAGS = $LDAP_CFLAGS
 LDAP_LIBS = $LDAP_LIBS
@@ -20115,7 +22780,7 @@ server/wineserver"
     esac
 fi
 
-$as_echo " done" >&6
+printf "%s\n" " done" >&6
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -20143,8 +22808,8 @@ _ACEOF
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      *_cv_*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+printf "%s\n" "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
@@ -20174,15 +22839,15 @@ $as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
      /^ac_cv_env_/b end
      t clear
      :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     s/^\([^=]*\)=\(.*[{}].*\)$/test ${\1+y} || &/
      t end
      s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
     if test "x$cache_file" != "x/dev/null"; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+printf "%s\n" "$as_me: updating cache $cache_file" >&6;}
       if test ! -f "$cache_file" || test -h "$cache_file"; then
 	cat confcache >"$cache_file"
       else
@@ -20196,8 +22861,8 @@ $as_echo "$as_me: updating cache $cache_file" >&6;}
       fi
     fi
   else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+printf "%s\n" "$as_me: not updating unwritable cache $cache_file" >&6;}
   fi
 fi
 rm -f confcache
@@ -20214,7 +22879,7 @@ U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  ac_i=`printf "%s\n" "$ac_i" | sed "$ac_script"`
   # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
   #    will be set to the directory where LIBOBJS objects are built.
   as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
@@ -20230,8 +22895,8 @@ LTLIBOBJS=$ac_ltlibobjs
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+printf "%s\n" "$as_me: creating $CONFIG_STATUS" >&6;}
 as_write_fail=0
 cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
 #! $SHELL
@@ -20254,14 +22919,16 @@ cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+as_nop=:
+if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
-else
+else $as_nop
   case `(set -o) 2>/dev/null` in #(
   *posix*) :
     set -o posix ;; #(
@@ -20271,46 +22938,46 @@ esac
 fi
 
 
+
+# Reset variables that may have inherited troublesome values from
+# the environment.
+
+# IFS needs to be set, to space, tab, and newline, in precisely that order.
+# (If _AS_PATH_WALK were called with IFS unset, it would have the
+# side effect of setting IFS to empty, thus disabling word splitting.)
+# Quoting is to prevent editors from complaining about space-tab.
 as_nl='
 '
 export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
+IFS=" ""	$as_nl"
+
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# Ensure predictable behavior from utilities with locale-dependent output.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# We cannot yet rely on "unset" to work, but we need these variables
+# to be unset--not just set to an empty or harmless value--now, to
+# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
+# also avoids known problems related to "unset" and subshell syntax
+# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
+for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
+do eval test \${$as_var+y} \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+
+# Ensure that fds 0, 1, and 2 are open.
+if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
+if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
+if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi
 
 # The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
+if ${PATH_SEPARATOR+false} :; then
   PATH_SEPARATOR=:
   (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
     (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
@@ -20319,13 +22986,6 @@ if test "${PATH_SEPARATOR+set}" != set; then
 fi
 
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
 # Find who we are.  Look in the path if we contain no directory separator.
 as_myself=
 case $0 in #((
@@ -20334,8 +22994,12 @@ case $0 in #((
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
   done
 IFS=$as_save_IFS
 
@@ -20347,30 +23011,10 @@ if test "x$as_myself" = x; then
   as_myself=$0
 fi
 if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
   exit 1
 fi
 
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
 # as_fn_error STATUS ERROR [LINENO LOG_FD]
@@ -20383,13 +23027,14 @@ as_fn_error ()
   as_status=$1; test $as_status -eq 0 && as_status=1
   if test "$4"; then
     as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $2" >&2
+  printf "%s\n" "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
 
+
 # as_fn_set_status STATUS
 # -----------------------
 # Set $? to STATUS, without forking.
@@ -20416,18 +23061,20 @@ as_fn_unset ()
   { eval $1=; unset $1;}
 }
 as_unset=as_fn_unset
+
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
 # advantage of any shell optimizations that allow amortized linear growth over
 # repeated appends, instead of the typical quadratic growth present in naive
 # implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
+then :
   eval 'as_fn_append ()
   {
     eval $1+=\$2
   }'
-else
+else $as_nop
   as_fn_append ()
   {
     eval $1=\$$1\$2
@@ -20439,12 +23086,13 @@ fi # as_fn_append
 # Perform arithmetic evaluation on the ARGs, and store the result in the
 # global $as_val. Take advantage of shells that can avoid forks. The arguments
 # must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
+then :
   eval 'as_fn_arith ()
   {
     as_val=$(( $* ))
   }'
-else
+else $as_nop
   as_fn_arith ()
   {
     as_val=`expr "$@" || test $? -eq 1`
@@ -20475,7 +23123,7 @@ as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
+printf "%s\n" X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
@@ -20497,6 +23145,10 @@ as_cr_Letters=$as_cr_letters$as_cr_LETTERS
 as_cr_digits='0123456789'
 as_cr_alnum=$as_cr_Letters$as_cr_digits
 
+
+# Determine whether it's possible to make 'echo' print without a newline.
+# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
+# for compatibility with existing Makefiles.
 ECHO_C= ECHO_N= ECHO_T=
 case `echo -n x` in #(((((
 -n*)
@@ -20510,6 +23162,12 @@ case `echo -n x` in #(((((
   ECHO_N='-n';;
 esac
 
+# For backward compatibility with old third-party macros, we provide
+# the shell variables $as_echo and $as_echo_n.  New code should use
+# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
+as_echo='printf %s\n'
+as_echo_n='printf %s'
+
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
   rm -f conf$$.dir/conf$$.file
@@ -20551,7 +23209,7 @@ as_fn_mkdir_p ()
     as_dirs=
     while :; do
       case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
       *) as_qdir=$as_dir;;
       esac
       as_dirs="'$as_qdir' $as_dirs"
@@ -20560,7 +23218,7 @@ $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
 	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
+printf "%s\n" X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -20623,7 +23281,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # values after options handling.
 ac_log="
 This file was extended by Wine $as_me 6.21, which was
-generated by GNU Autoconf 2.69.  Invocation command line was
+generated by GNU Autoconf 2.71.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -20690,14 +23348,16 @@ Report bugs to <wine-devel@winehq.org>.
 Wine home page: <https://www.winehq.org>."
 
 _ACEOF
+ac_cs_config=`printf "%s\n" "$ac_configure_args" | sed "$ac_safe_unquote"`
+ac_cs_config_escaped=`printf "%s\n" "$ac_cs_config" | sed "s/^ //; s/'/'\\\\\\\\''/g"`
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_config='$ac_cs_config_escaped'
 ac_cs_version="\\
 Wine config.status 6.21
-configured by $0, generated by GNU Autoconf 2.69,
+configured by $0, generated by GNU Autoconf 2.71,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2012 Free Software Foundation, Inc.
+Copyright (C) 2021 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -20734,15 +23394,15 @@ do
   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
+    printf "%s\n" "$ac_cs_version"; exit ;;
   --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
+    printf "%s\n" "$ac_cs_config"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
     case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *\'*) ac_optarg=`printf "%s\n" "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
     '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
@@ -20750,7 +23410,7 @@ do
   --header | --heade | --head | --hea )
     $ac_shift
     case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *\'*) ac_optarg=`printf "%s\n" "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
     as_fn_append CONFIG_HEADERS " '$ac_optarg'"
     ac_need_defaults=false;;
@@ -20759,7 +23419,7 @@ do
     as_fn_error $? "ambiguous option: \`$1'
 Try \`$0 --help' for more information.";;
   --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
+    printf "%s\n" "$ac_cs_usage"; exit ;;
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil | --si | --s)
     ac_cs_silent=: ;;
@@ -20787,7 +23447,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
   set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  \printf "%s\n" "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
   export CONFIG_SHELL
   exec "\$@"
@@ -20801,7 +23461,7 @@ exec 5>>config.log
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
-  $as_echo "$ac_log"
+  printf "%s\n" "$ac_log"
 } >&5
 
 _ACEOF
@@ -20848,10 +23508,10 @@ done
 # We use the long form for the default assignment because of an extremely
 # bizarre bug on SunOS 4.1.3.
 if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
-  test "${CONFIG_LINKS+set}" = set || CONFIG_LINKS=$config_links
-  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+  test ${CONFIG_FILES+y} || CONFIG_FILES=$config_files
+  test ${CONFIG_HEADERS+y} || CONFIG_HEADERS=$config_headers
+  test ${CONFIG_LINKS+y} || CONFIG_LINKS=$config_links
+  test ${CONFIG_COMMANDS+y} || CONFIG_COMMANDS=$config_commands
 fi
 
 # Have a temporary directory for convenience.  Make it in the build tree
@@ -21187,7 +23847,7 @@ do
 	   esac ||
 	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      case $ac_f in *\'*) ac_f=`printf "%s\n" "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
     done
 
@@ -21195,17 +23855,17 @@ do
     # use $as_me), people would be surprised to read:
     #    /* config.h.  Generated by config.status.  */
     configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	  printf "%s\n" "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
 	`' by configure.'
     if test x"$ac_file" != x-; then
       configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+printf "%s\n" "$as_me: creating $ac_file" >&6;}
     fi
     # Neutralize special characters interpreted by sed in replacement strings.
     case $configure_input in #(
     *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
+       ac_sed_conf_input=`printf "%s\n" "$configure_input" |
        sed 's/[\\\\&|]/\\\\&/g'`;; #(
     *) ac_sed_conf_input=$configure_input;;
     esac
@@ -21222,7 +23882,7 @@ $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$ac_file" : 'X\(//\)[^/]' \| \
 	 X"$ac_file" : 'X\(//\)$' \| \
 	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
+printf "%s\n" X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
@@ -21246,9 +23906,9 @@ $as_echo X"$ac_file" |
 case "$ac_dir" in
 .) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
 *)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  ac_dir_suffix=/`printf "%s\n" "$ac_dir" | sed 's|^\.[\\/]||'`
   # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  ac_top_builddir_sub=`printf "%s\n" "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
   case $ac_top_builddir_sub in
   "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
   *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
@@ -21301,8 +23961,8 @@ ac_sed_dataroot='
 case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
 *datarootdir*) ac_datarootdir_seen=yes;;
 *@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+printf "%s\n" "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
   ac_datarootdir_hack='
@@ -21344,9 +24004,9 @@ test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
   { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
       "$ac_tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+printf "%s\n" "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&2;}
 
   rm -f "$ac_tmp/stdin"
@@ -21362,20 +24022,20 @@ which seems to be undefined.  Please make sure it is defined" >&2;}
   #
   if test x"$ac_file" != x-; then
     {
-      $as_echo "/* $configure_input  */" \
+      printf "%s\n" "/* $configure_input  */" >&1 \
       && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
     } >"$ac_tmp/config.h" \
       || as_fn_error $? "could not create $ac_file" "$LINENO" 5
     if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
-$as_echo "$as_me: $ac_file is unchanged" >&6;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+printf "%s\n" "$as_me: $ac_file is unchanged" >&6;}
     else
       rm -f "$ac_file"
       mv "$ac_tmp/config.h" "$ac_file" \
 	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
     fi
   else
-    $as_echo "/* $configure_input  */" \
+    printf "%s\n" "/* $configure_input  */" >&1 \
       && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
       || as_fn_error $? "could not create -" "$LINENO" 5
   fi
@@ -21393,8 +24053,8 @@ $as_echo "$as_me: $ac_file is unchanged" >&6;}
       ac_source=$srcdir/$ac_source
     fi
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: linking $ac_source to $ac_file" >&5
-$as_echo "$as_me: linking $ac_source to $ac_file" >&6;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: linking $ac_source to $ac_file" >&5
+printf "%s\n" "$as_me: linking $ac_source to $ac_file" >&6;}
 
     if test ! -r "$ac_source"; then
       as_fn_error $? "$ac_source: file not found" "$LINENO" 5
@@ -21412,8 +24072,8 @@ $as_echo "$as_me: linking $ac_source to $ac_file" >&6;}
       as_fn_error $? "cannot link or copy $ac_source to $ac_file" "$LINENO" 5
   fi
  ;;
-  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
-$as_echo "$as_me: executing $ac_file commands" >&6;}
+  :C)  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+printf "%s\n" "$as_me: executing $ac_file commands" >&6;}
  ;;
   esac
 
@@ -21456,8 +24116,8 @@ if test "$no_create" != yes; then
   $ac_cs_success || as_fn_exit 1
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+printf "%s\n" "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
 
@@ -21472,28 +24132,31 @@ if test "x$wine_notices" != x; then
     IFS="|"
     for msg in $wine_notices; do
         IFS="$ac_save_IFS"
-        if ${msg:+false} :; then :
+        if ${msg:+false} :
+then :
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: $msg" >&5
-$as_echo "$as_me: $msg" >&6;}
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: $msg" >&5
+printf "%s\n" "$as_me: $msg" >&6;}
 fi
     done
 fi
 IFS="|"
 for msg in $wine_warnings; do
     IFS="$ac_save_IFS"
-    if ${msg:+false} :; then :
+    if ${msg:+false} :
+then :
 
-else
+else $as_nop
   echo >&2
-        { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $msg" >&5
-$as_echo "$as_me: WARNING: $msg" >&2;}
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $msg" >&5
+printf "%s\n" "$as_me: WARNING: $msg" >&2;}
 fi
 done
 IFS="$ac_save_IFS"
 
-$as_echo "
+printf "%s\n" "
 $as_me: Finished.  Do '${ac_make}' to compile Wine.
 " >&6
 
+
diff --git a/configure.ac b/configure.ac
index 72d607a8d3c..7b6af87d23c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -427,7 +427,7 @@ AC_CHECK_HEADERS(\
 	IOKit/IOKitLib.h \
 	IOKit/hid/IOHIDLib.h \
 	OpenAL/al.h \
-	OpenCL/opencl.h \
+	CL/opencl.h \
 	QuickTime/ImageCompression.h \
 	Security/Security.h \
 	SystemConfiguration/SCDynamicStoreCopyDHCPInfo.h \
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 255d5afef79..ea5e972b660 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -44,6 +44,7 @@ WINE_DECLARE_DEBUG_CHANNEL(relay);
 WINE_DECLARE_DEBUG_CHANNEL(snoop);
 WINE_DECLARE_DEBUG_CHANNEL(loaddll);
 WINE_DECLARE_DEBUG_CHANNEL(imports);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifdef _WIN64
 #define DEFAULT_SECURITY_COOKIE_64  (((ULONGLONG)0x00002b99 << 32) | 0x2ddfa232)
@@ -3431,6 +3432,7 @@ NTSTATUS WINAPI LdrQueryImageFileExecutionOptions( const UNICODE_STRING *key, LP
     return status;
 }
 
+extern const char * CDECL wine_get_version(void);
 
 /******************************************************************
  *		RtlDllShutdownInProgress  (NTDLL.@)
@@ -3955,6 +3957,9 @@ static void release_address_space(void)
  */
 void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR unknown3, ULONG_PTR unknown4 )
 {
+    OBJECT_ATTRIBUTES staging_event_attr;
+    UNICODE_STRING staging_event_string;
+    HANDLE staging_event;
     static int attach_done;
     NTSTATUS status;
     ULONG_PTR cookie;
@@ -3971,6 +3976,16 @@ void WINAPI LdrInitializeThunk( CONTEXT *context, ULONG_PTR unknown2, ULONG_PTR
     entry = (void **)&context->u.s.X0;
 #endif
 
+    RtlInitUnicodeString( &staging_event_string, L"\\__wine_staging_warn_event" );
+    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF, NULL, NULL );
+    if (NtCreateEvent( &staging_event, EVENT_ALL_ACCESS, &staging_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
+    {
+        FIXME_(winediag)("Wine TkG %s is a testing version containing experimental patches.\n", wine_get_version());
+        FIXME_(winediag)("Please don't report bugs about it on winehq.org and use https://github.com/Frogging-Family/wine-tkg-git/issues instead.\n");
+    }
+    else
+        WARN_(winediag)("Wine TkG %s is a testing version containing experimental patches.\n", wine_get_version());
+
     if (process_detaching) NtTerminateThread( GetCurrentThread(), 0 );
 
     RtlEnterCriticalSection( &loader_section );
diff --git a/dlls/winevulkan/vk-1.2.197.xml b/dlls/winevulkan/vk-1.2.197.xml
new file mode 100644
index 00000000000..af8373af9a4
--- /dev/null
+++ b/dlls/winevulkan/vk-1.2.197.xml
@@ -0,0 +1,18071 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<registry>
+    <comment>
+Copyright 2015-2021 The Khronos Group Inc.
+
+SPDX-License-Identifier: Apache-2.0 OR MIT
+    </comment>
+
+    <comment>
+This file, vk.xml, is the Vulkan API Registry. It is a critically important
+and normative part of the Vulkan Specification, including a canonical
+machine-readable definition of the API, parameter and member validation
+language incorporated into the Specification and reference pages, and other
+material which is registered by Khronos, such as tags used by extension and
+layer authors. The authoritative public version of vk.xml is maintained in
+the default branch (currently named main) of the Khronos Vulkan GitHub
+project. The authoritative private version is maintained in the default
+branch of the member gitlab server.
+    </comment>
+
+    <platforms comment="Vulkan platform names, reserved for use with platform- and window system-specific extensions">
+        <platform name="xlib" protect="VK_USE_PLATFORM_XLIB_KHR" comment="X Window System, Xlib client library"/>
+        <platform name="xlib_xrandr" protect="VK_USE_PLATFORM_XLIB_XRANDR_EXT" comment="X Window System, Xlib client library, XRandR extension"/>
+        <platform name="xcb" protect="VK_USE_PLATFORM_XCB_KHR" comment="X Window System, Xcb client library"/>
+        <platform name="wayland" protect="VK_USE_PLATFORM_WAYLAND_KHR" comment="Wayland display server protocol"/>
+        <platform name="directfb" protect="VK_USE_PLATFORM_DIRECTFB_EXT" comment="DirectFB library"/>
+        <platform name="android" protect="VK_USE_PLATFORM_ANDROID_KHR" comment="Android OS"/>
+        <platform name="win32" protect="VK_USE_PLATFORM_WIN32_KHR" comment="Microsoft Win32 API (also refers to Win64 apps)"/>
+        <platform name="vi" protect="VK_USE_PLATFORM_VI_NN" comment="Nintendo Vi"/>
+        <platform name="ios" protect="VK_USE_PLATFORM_IOS_MVK" comment="Apple IOS"/>
+        <platform name="macos" protect="VK_USE_PLATFORM_MACOS_MVK" comment="Apple MacOS"/>
+        <platform name="metal" protect="VK_USE_PLATFORM_METAL_EXT" comment="Metal on CoreAnimation on Apple platforms"/>
+        <platform name="fuchsia" protect="VK_USE_PLATFORM_FUCHSIA" comment="Fuchsia"/>
+        <platform name="ggp" protect="VK_USE_PLATFORM_GGP" comment="Google Games Platform"/>
+        <platform name="provisional" protect="VK_ENABLE_BETA_EXTENSIONS" comment="Enable declarations for beta/provisional extensions"/>
+        <platform name="screen" protect="VK_USE_PLATFORM_SCREEN_QNX" comment="QNX Screen Graphics Subsystem"/>
+    </platforms>
+
+    <tags comment="Vulkan vendor/author tags for extensions and layers">
+        <tag name="IMG"         author="Imagination Technologies"      contact="Michael Worcester @michaelworcester"/>
+        <tag name="AMD"         author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @drakos-amd"/>
+        <tag name="AMDX"        author="Advanced Micro Devices, Inc."  contact="Daniel Rakos @drakos-amd"/>
+        <tag name="ARM"         author="ARM Limited"                   contact="Jan-Harald Fredriksen @janharaldfredriksen-arm"/>
+        <tag name="FSL"         author="Freescale Semiconductor, Inc." contact="Norbert Nopper @FslNopper"/>
+        <tag name="BRCM"        author="Broadcom Corporation"          contact="Graeme Leese @gnl21"/>
+        <tag name="NXP"         author="NXP Semiconductors N.V."       contact="Norbert Nopper @FslNopper"/>
+        <tag name="NV"          author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
+        <tag name="NVX"         author="NVIDIA Corporation"            contact="Daniel Koch @dgkoch"/>
+        <tag name="VIV"         author="Vivante Corporation"           contact="Yanjun Zhang gitlab:@yanjunzhang"/>
+        <tag name="VSI"         author="VeriSilicon Holdings Co., Ltd." contact="Yanjun Zhang gitlab:@yanjunzhang"/>
+        <tag name="KDAB"        author="KDAB"                          contact="Sean Harmer @seanharmer"/>
+        <tag name="ANDROID"     author="Google LLC"                    contact="Jesse Hall @critsec"/>
+        <tag name="CHROMIUM"    author="Google LLC"                    contact="Jesse Hall @critsec"/>
+        <tag name="FUCHSIA"     author="Google LLC"                    contact="Craig Stout @cdotstout, Jesse Hall @critsec, John Rosasco @rosasco"/>
+        <tag name="GGP"         author="Google, LLC"                   contact="Jean-Francois Roy @jfroy, Hai Nguyen @chaoticbob, Jesse Hall @critsec"/>
+        <tag name="GOOGLE"      author="Google LLC"                    contact="Jesse Hall @critsec"/>
+        <tag name="QCOM"        author="Qualcomm Technologies, Inc."   contact="Jeff Leger @jackohounhd"/>
+        <tag name="LUNARG"      author="LunarG, Inc."                  contact="Karen Ghavam @karenghavam-lunarg"/>
+        <tag name="SAMSUNG"     author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
+        <tag name="SEC"         author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
+        <tag name="TIZEN"       author="Samsung Electronics Co., Ltd." contact="Alon Or-bach @alonorbach"/>
+        <tag name="RENDERDOC"   author="RenderDoc (renderdoc.org)"     contact="Baldur Karlsson @baldurk"/>
+        <tag name="NN"          author="Nintendo Co., Ltd."            contact="Yasuhiro Yoshioka gitlab:@yoshioka_yasuhiro"/>
+        <tag name="MVK"         author="The Brenwill Workshop Ltd."    contact="Bill Hollings @billhollings"/>
+        <tag name="KHR"         author="Khronos"                       contact="Tom Olson @tomolson"/>
+        <tag name="KHX"         author="Khronos"                       contact="Tom Olson @tomolson"/>
+        <tag name="EXT"         author="Multivendor"                   contact="Jon Leech @oddhack"/>
+        <tag name="MESA"        author="Mesa open source project"      contact="Chad Versace @chadversary, Daniel Stone @fooishbar, David Airlie @airlied, Jason Ekstrand @jekstrand"/>
+        <tag name="INTEL"       author="Intel Corporation"             contact="Slawek Grajewski @sgrajewski"/>
+        <tag name="HUAWEI"      author="Huawei Technologies Co. Ltd."  contact="Hueilong Wang @wyvernathuawei, Yunpeng Zhu @yunxingzhu"/>
+        <tag name="VALVE"       author="Valve Corporation"             contact="Pierre-Loup Griffais @plagman, Joshua Ashton @Joshua-Ashton, Hans-Kristian Arntzen @HansKristian-Work"/>
+        <tag name="QNX"         author="BlackBerry Limited"            contact="Mike Gorchak @mgorchak-blackberry"/>
+        <tag name="JUICE"       author="Juice Technologies, Inc."      contact="David McCloskey @damcclos, Dean Beeler @canadacow"/>
+        <tag name="FB"          author="Facebook, Inc"                 contact="Artem Bolgar @artyom17"/>
+    </tags>
+
+    <types comment="Vulkan type definitions">
+        <type name="vk_platform" category="include">#include "vk_platform.h"</type>
+
+            <comment>WSI extensions</comment>
+
+        <type category="include" name="X11/Xlib.h"/>
+        <type category="include" name="X11/extensions/Xrandr.h"/>
+        <type category="include" name="wayland-client.h"/>
+        <type category="include" name="windows.h"/>
+        <type category="include" name="xcb/xcb.h"/>
+        <type category="include" name="directfb.h"/>
+        <type category="include" name="zircon/types.h"/>
+        <type category="include" name="ggp_c/vulkan_types.h"/>
+        <type category="include" name="screen/screen.h"/>
+            <comment>
+                In the current header structure, each platform's interfaces
+                are confined to a platform-specific header (vulkan_xlib.h,
+                vulkan_win32.h, etc.). These headers are not self-contained,
+                and should not include native headers (X11/Xlib.h,
+                windows.h, etc.). Code should either include vulkan.h after
+                defining the appropriate VK_USE_PLATFORM_platform
+                macros, or include the required native headers prior to
+                explicitly including the corresponding platform header.
+
+                To accomplish this, the dependencies of native types require
+                native headers, but the XML defines the content for those
+                native headers as empty. The actual native header includes
+                can be restored by modifying the native header tags above
+                to #include the header file in the 'name' attribute.
+            </comment>
+
+        <type requires="X11/Xlib.h" name="Display"/>
+        <type requires="X11/Xlib.h" name="VisualID"/>
+        <type requires="X11/Xlib.h" name="Window"/>
+        <type requires="X11/extensions/Xrandr.h" name="RROutput"/>
+        <type requires="wayland-client.h" name="wl_display"/>
+        <type requires="wayland-client.h" name="wl_surface"/>
+        <type requires="windows.h" name="HINSTANCE"/>
+        <type requires="windows.h" name="HWND"/>
+        <type requires="windows.h" name="HMONITOR"/>
+        <type requires="windows.h" name="HANDLE"/>
+        <type requires="windows.h" name="SECURITY_ATTRIBUTES"/>
+        <type requires="windows.h" name="DWORD"/>
+        <type requires="windows.h" name="LPCWSTR"/>
+        <type requires="xcb/xcb.h" name="xcb_connection_t"/>
+        <type requires="xcb/xcb.h" name="xcb_visualid_t"/>
+        <type requires="xcb/xcb.h" name="xcb_window_t"/>
+        <type requires="directfb.h" name="IDirectFB"/>
+        <type requires="directfb.h" name="IDirectFBSurface"/>
+        <type requires="zircon/types.h" name="zx_handle_t"/>
+        <type requires="ggp_c/vulkan_types.h" name="GgpStreamDescriptor"/>
+        <type requires="ggp_c/vulkan_types.h" name="GgpFrameToken"/>
+        <type requires="screen/screen.h" name="_screen_context"/>
+        <type requires="screen/screen.h" name="_screen_window"/>
+
+        <type category="define">// DEPRECATED: This define is deprecated. VK_MAKE_API_VERSION should be used instead.
+#define <name>VK_MAKE_VERSION</name>(major, minor, patch) \
+    ((((uint32_t)(major)) &lt;&lt; 22) | (((uint32_t)(minor)) &lt;&lt; 12) | ((uint32_t)(patch)))</type>
+        <type category="define">// DEPRECATED: This define is deprecated. VK_API_VERSION_MAJOR should be used instead.
+#define <name>VK_VERSION_MAJOR</name>(version) ((uint32_t)(version) &gt;&gt; 22)</type>
+        <type category="define">// DEPRECATED: This define is deprecated. VK_API_VERSION_MINOR should be used instead.
+#define <name>VK_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12) &amp; 0x3FFU)</type>
+        <type category="define">// DEPRECATED: This define is deprecated. VK_API_VERSION_PATCH should be used instead.
+#define <name>VK_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xFFFU)</type>
+
+        <type category="define">#define <name>VK_MAKE_API_VERSION</name>(variant, major, minor, patch) \
+    ((((uint32_t)(variant)) &lt;&lt; 29) | (((uint32_t)(major)) &lt;&lt; 22) | (((uint32_t)(minor)) &lt;&lt; 12) | ((uint32_t)(patch)))</type>
+        <type category="define">#define <name>VK_API_VERSION_VARIANT</name>(version) ((uint32_t)(version) &gt;&gt; 29)</type>
+        <type category="define">#define <name>VK_API_VERSION_MAJOR</name>(version) (((uint32_t)(version) &gt;&gt; 22) &amp; 0x7FU)</type>
+        <type category="define">#define <name>VK_API_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12) &amp; 0x3FFU)</type>
+        <type category="define">#define <name>VK_API_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xFFFU)</type>
+
+        <type category="define">// DEPRECATED: This define has been removed. Specific version defines (e.g. VK_API_VERSION_1_0), or the VK_MAKE_VERSION macro, should be used instead.
+//#define <name>VK_API_VERSION</name> <type>VK_MAKE_VERSION</type>(1, 0, 0) // Patch version should always be set to 0</type>
+        <type category="define" requires="VK_MAKE_API_VERSION">// Vulkan 1.0 version number
+#define <name>VK_API_VERSION_1_0</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 0, 0)// Patch version should always be set to 0</type>
+        <type category="define" requires="VK_MAKE_API_VERSION">// Vulkan 1.1 version number
+#define <name>VK_API_VERSION_1_1</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 1, 0)// Patch version should always be set to 0</type>
+        <type category="define" requires="VK_MAKE_API_VERSION">// Vulkan 1.2 version number
+#define <name>VK_API_VERSION_1_2</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 2, 0)// Patch version should always be set to 0</type>
+        <type category="define">// Version of this file
+#define <name>VK_HEADER_VERSION</name> 197</type>
+        <type category="define" requires="VK_HEADER_VERSION">// Complete version of this file
+#define <name>VK_HEADER_VERSION_COMPLETE</name> <type>VK_MAKE_API_VERSION</type>(0, 1, 2, VK_HEADER_VERSION)</type>
+
+        <type category="define">
+#define <name>VK_DEFINE_HANDLE</name>(object) typedef struct object##_T* object;</type>
+
+        <type category="define" name="VK_USE_64_BIT_PTR_DEFINES">
+#ifndef VK_USE_64_BIT_PTR_DEFINES
+    #if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) &amp;&amp; !defined(__ILP32__) ) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
+        #define VK_USE_64_BIT_PTR_DEFINES 1
+    #else
+        #define VK_USE_64_BIT_PTR_DEFINES 0
+    #endif
+#endif</type>
+        <type category="define" requires="VK_USE_64_BIT_PTR_DEFINES" name="VK_NULL_HANDLE">
+#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
+    #if (VK_USE_64_BIT_PTR_DEFINES==1)
+        #if (defined(__cplusplus) &amp;&amp; (__cplusplus >= 201103L)) || (defined(_MSVC_LANG) &amp;&amp; (_MSVC_LANG >= 201103L))
+            #define VK_NULL_HANDLE nullptr
+        #else
+            #define VK_NULL_HANDLE ((void*)0)
+        #endif
+    #else
+        #define VK_NULL_HANDLE 0ULL
+    #endif
+#endif
+#ifndef VK_NULL_HANDLE
+    #define VK_NULL_HANDLE 0
+#endif</type>
+        <type category="define" requires="VK_NULL_HANDLE" name="VK_DEFINE_NON_DISPATCHABLE_HANDLE">
+#ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
+    #if (VK_USE_64_BIT_PTR_DEFINES==1)
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
+    #else
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
+    #endif
+#endif</type>
+
+        <type category="basetype">struct <name>ANativeWindow</name>;</type>
+        <type category="basetype">struct <name>AHardwareBuffer</name>;</type>
+        <type category="basetype">
+#ifdef __OBJC__
+@class CAMetalLayer;
+#else
+typedef void <name>CAMetalLayer</name>;
+#endif</type>
+
+        <type category="basetype">typedef <type>uint32_t</type> <name>VkSampleMask</name>;</type>
+        <type category="basetype">typedef <type>uint32_t</type> <name>VkBool32</name>;</type>
+        <type category="basetype">typedef <type>uint32_t</type> <name>VkFlags</name>;</type>
+        <type category="basetype">typedef <type>uint64_t</type> <name>VkFlags64</name>;</type>
+        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceSize</name>;</type>
+        <type category="basetype">typedef <type>uint64_t</type> <name>VkDeviceAddress</name>;</type>
+
+            <comment>Basic C types, pulled in via vk_platform.h</comment>
+        <type requires="vk_platform" name="void"/>
+        <type requires="vk_platform" name="char"/>
+        <type requires="vk_platform" name="float"/>
+        <type requires="vk_platform" name="double"/>
+        <type requires="vk_platform" name="int8_t"/>
+        <type requires="vk_platform" name="uint8_t"/>
+        <type requires="vk_platform" name="int16_t"/>
+        <type requires="vk_platform" name="uint16_t"/>
+        <type requires="vk_platform" name="uint32_t"/>
+        <type requires="vk_platform" name="uint64_t"/>
+        <type requires="vk_platform" name="int32_t"/>
+        <type requires="vk_platform" name="int64_t"/>
+        <type requires="vk_platform" name="size_t"/>
+        <type name="int"/>
+
+            <comment>Bitmask types</comment>
+        <type requires="VkFramebufferCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkFramebufferCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPoolCreateFlags</name>;</type>
+        <type requires="VkRenderPassCreateFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkRenderPassCreateFlags</name>;</type>
+        <type requires="VkSamplerCreateFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkSamplerCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineLayoutCreateFlags</name>;</type>
+        <type requires="VkPipelineCacheCreateFlagBits"    category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCacheCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDepthStencilStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDynamicStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineColorBlendStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineMultisampleStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineTessellationStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineInputAssemblyStateCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineVertexInputStateCreateFlags</name>;</type>
+        <type requires="VkPipelineShaderStageCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineShaderStageCreateFlags</name>;</type>
+        <type requires="VkDescriptorSetLayoutCreateFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorSetLayoutCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkBufferViewCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkInstanceCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceCreateFlags</name>;</type>
+        <type requires="VkDeviceQueueCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceQueueCreateFlags</name>;</type>
+        <type requires="VkQueueFlagBits"                  category="bitmask">typedef <type>VkFlags</type> <name>VkQueueFlags</name>;</type>
+        <type requires="VkMemoryPropertyFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryPropertyFlags</name>;</type>
+        <type requires="VkMemoryHeapFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryHeapFlags</name>;</type>
+        <type requires="VkAccessFlagBits"                 category="bitmask">typedef <type>VkFlags</type> <name>VkAccessFlags</name>;</type>
+        <type requires="VkBufferUsageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkBufferUsageFlags</name>;</type>
+        <type requires="VkBufferCreateFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkBufferCreateFlags</name>;</type>
+        <type requires="VkShaderStageFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkShaderStageFlags</name>;</type>
+        <type requires="VkImageUsageFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkImageUsageFlags</name>;</type>
+        <type requires="VkImageCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageCreateFlags</name>;</type>
+        <type requires="VkImageViewCreateFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkImageViewCreateFlags</name>;</type>
+        <type requires="VkPipelineCreateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreateFlags</name>;</type>
+        <type requires="VkColorComponentFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkColorComponentFlags</name>;</type>
+        <type requires="VkFenceCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreCreateFlags</name>;</type>
+        <type requires="VkFormatFeatureFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkFormatFeatureFlags</name>;</type>
+        <type requires="VkQueryControlFlagBits"           category="bitmask">typedef <type>VkFlags</type> <name>VkQueryControlFlags</name>;</type>
+        <type requires="VkQueryResultFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkQueryResultFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkShaderModuleCreateFlags</name>;</type>
+        <type requires="VkEventCreateFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkEventCreateFlags</name>;</type>
+        <type requires="VkCommandPoolCreateFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolCreateFlags</name>;</type>
+        <type requires="VkCommandPoolResetFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolResetFlags</name>;</type>
+        <type requires="VkCommandBufferResetFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferResetFlags</name>;</type>
+        <type requires="VkCommandBufferUsageFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkCommandBufferUsageFlags</name>;</type>
+        <type requires="VkQueryPipelineStatisticFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkQueryPipelineStatisticFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryMapFlags</name>;</type>
+        <type requires="VkImageAspectFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkImageAspectFlags</name>;</type>
+        <type requires="VkSparseMemoryBindFlagBits"       category="bitmask">typedef <type>VkFlags</type> <name>VkSparseMemoryBindFlags</name>;</type>
+        <type requires="VkSparseImageFormatFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkSparseImageFormatFlags</name>;</type>
+        <type requires="VkSubpassDescriptionFlagBits"     category="bitmask">typedef <type>VkFlags</type> <name>VkSubpassDescriptionFlags</name>;</type>
+        <type requires="VkPipelineStageFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineStageFlags</name>;</type>
+        <type requires="VkSampleCountFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkSampleCountFlags</name>;</type>
+        <type requires="VkAttachmentDescriptionFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkAttachmentDescriptionFlags</name>;</type>
+        <type requires="VkStencilFaceFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkStencilFaceFlags</name>;</type>
+        <type requires="VkCullModeFlagBits"               category="bitmask">typedef <type>VkFlags</type> <name>VkCullModeFlags</name>;</type>
+        <type requires="VkDescriptorPoolCreateFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolCreateFlags</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorPoolResetFlags</name>;</type>
+        <type requires="VkDependencyFlagBits"             category="bitmask">typedef <type>VkFlags</type> <name>VkDependencyFlags</name>;</type>
+        <type requires="VkSubgroupFeatureFlagBits"        category="bitmask">typedef <type>VkFlags</type> <name>VkSubgroupFeatureFlags</name>;</type>
+        <type requires="VkIndirectCommandsLayoutUsageFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectCommandsLayoutUsageFlagsNV</name>;</type>
+        <type requires="VkIndirectStateFlagBitsNV"        category="bitmask">typedef <type>VkFlags</type> <name>VkIndirectStateFlagsNV</name>;</type>
+        <type requires="VkGeometryFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryFlagsKHR</name>;</type>
+        <type                                             category="bitmask" name="VkGeometryFlagsNV" alias="VkGeometryFlagsKHR"/>
+        <type requires="VkGeometryInstanceFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkGeometryInstanceFlagsKHR</name>;</type>
+        <type                                             category="bitmask" name="VkGeometryInstanceFlagsNV" alias="VkGeometryInstanceFlagsKHR"/>
+        <type requires="VkBuildAccelerationStructureFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkBuildAccelerationStructureFlagsKHR</name>;</type>
+        <type                                             category="bitmask" name="VkBuildAccelerationStructureFlagsNV" alias="VkBuildAccelerationStructureFlagsKHR"/>
+        <type requires="VkPrivateDataSlotCreateFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkPrivateDataSlotCreateFlagsEXT</name>;</type>
+        <type requires="VkAccelerationStructureCreateFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorUpdateTemplateCreateFlags</name>;</type>
+        <type                                             category="bitmask" name="VkDescriptorUpdateTemplateCreateFlagsKHR" alias="VkDescriptorUpdateTemplateCreateFlags"/>
+        <type requires="VkPipelineCreationFeedbackFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCreationFeedbackFlagsEXT</name>;</type>
+        <type requires="VkPerformanceCounterDescriptionFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkPerformanceCounterDescriptionFlagsKHR</name>;</type>
+        <type requires="VkAcquireProfilingLockFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkAcquireProfilingLockFlagsKHR</name>;</type>
+        <type requires="VkSemaphoreWaitFlagBits"          category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreWaitFlags</name>;</type>
+        <type                                             category="bitmask" name="VkSemaphoreWaitFlagsKHR" alias="VkSemaphoreWaitFlags"/>
+        <type requires="VkPipelineCompilerControlFlagBitsAMD" category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCompilerControlFlagsAMD</name>;</type>
+        <type requires="VkShaderCorePropertiesFlagBitsAMD" category="bitmask">typedef <type>VkFlags</type> <name>VkShaderCorePropertiesFlagsAMD</name>;</type>
+        <type requires="VkDeviceDiagnosticsConfigFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceDiagnosticsConfigFlagsNV</name>;</type>
+        <type bitvalues="VkAccessFlagBits2KHR"             category="bitmask">typedef <type>VkFlags64</type> <name>VkAccessFlags2KHR</name>;</type>
+        <type bitvalues="VkPipelineStageFlagBits2KHR"      category="bitmask">typedef <type>VkFlags64</type> <name>VkPipelineStageFlags2KHR</name>;</type>
+        <type                                              category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureMotionInfoFlagsNV</name>;</type>
+        <type                                              category="bitmask">typedef <type>VkFlags</type> <name>VkAccelerationStructureMotionInstanceFlagsNV</name>;</type>
+        <type bitvalues="VkFormatFeatureFlagBits2KHR"      category="bitmask">typedef <type>VkFlags64</type> <name>VkFormatFeatureFlags2KHR</name>;</type>
+        <type requires="VkRenderingFlagBitsKHR"           category="bitmask">typedef <type>VkFlags</type> <name>VkRenderingFlagsKHR</name>;</type>
+
+            <comment>WSI extensions</comment>
+        <type requires="VkCompositeAlphaFlagBitsKHR"      category="bitmask">typedef <type>VkFlags</type> <name>VkCompositeAlphaFlagsKHR</name>;</type>
+        <type requires="VkDisplayPlaneAlphaFlagBitsKHR"   category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayPlaneAlphaFlagsKHR</name>;</type>
+        <type requires="VkSurfaceTransformFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceTransformFlagsKHR</name>;</type>
+        <type requires="VkSwapchainCreateFlagBitsKHR"     category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplayModeCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDisplaySurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkAndroidSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkViSurfaceCreateFlagsNN</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWaylandSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkWin32SurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXlibSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkXcbSurfaceCreateFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDirectFBSurfaceCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkIOSSurfaceCreateFlagsMVK</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMacOSSurfaceCreateFlagsMVK</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkMetalSurfaceCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImagePipeSurfaceCreateFlagsFUCHSIA</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkStreamDescriptorSurfaceCreateFlagsGGP</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkHeadlessSurfaceCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkScreenSurfaceCreateFlagsQNX</name>;</type>
+        <type requires="VkPeerMemoryFeatureFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkPeerMemoryFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkPeerMemoryFeatureFlagsKHR"               alias="VkPeerMemoryFeatureFlags"/>
+        <type requires="VkMemoryAllocateFlagBits"         category="bitmask">typedef <type>VkFlags</type> <name>VkMemoryAllocateFlags</name>;</type>
+        <type                                             category="bitmask" name="VkMemoryAllocateFlagsKHR"                  alias="VkMemoryAllocateFlags"/>
+        <type requires="VkDeviceGroupPresentModeFlagBitsKHR" category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceGroupPresentModeFlagsKHR</name>;</type>
+
+        <type requires="VkDebugReportFlagBitsEXT"         category="bitmask">typedef <type>VkFlags</type> <name>VkDebugReportFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkCommandPoolTrimFlags</name>;</type>
+        <type                                             category="bitmask" name="VkCommandPoolTrimFlagsKHR"                 alias="VkCommandPoolTrimFlags"/>
+        <type requires="VkExternalMemoryHandleTypeFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlagsNV</name>;</type>
+        <type requires="VkExternalMemoryFeatureFlagBitsNV" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlagsNV</name>;</type>
+        <type requires="VkExternalMemoryHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryHandleTypeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalMemoryHandleTypeFlagsKHR"        alias="VkExternalMemoryHandleTypeFlags"/>
+        <type requires="VkExternalMemoryFeatureFlagBits"  category="bitmask">typedef <type>VkFlags</type> <name>VkExternalMemoryFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalMemoryFeatureFlagsKHR"           alias="VkExternalMemoryFeatureFlags"/>
+        <type requires="VkExternalSemaphoreHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreHandleTypeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalSemaphoreHandleTypeFlagsKHR"     alias="VkExternalSemaphoreHandleTypeFlags"/>
+        <type requires="VkExternalSemaphoreFeatureFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalSemaphoreFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalSemaphoreFeatureFlagsKHR"        alias="VkExternalSemaphoreFeatureFlags"/>
+        <type requires="VkSemaphoreImportFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkSemaphoreImportFlags</name>;</type>
+        <type                                             category="bitmask" name="VkSemaphoreImportFlagsKHR"                 alias="VkSemaphoreImportFlags"/>
+        <type requires="VkExternalFenceHandleTypeFlagBits" category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceHandleTypeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalFenceHandleTypeFlagsKHR"         alias="VkExternalFenceHandleTypeFlags"/>
+        <type requires="VkExternalFenceFeatureFlagBits"   category="bitmask">typedef <type>VkFlags</type> <name>VkExternalFenceFeatureFlags</name>;</type>
+        <type                                             category="bitmask" name="VkExternalFenceFeatureFlagsKHR"            alias="VkExternalFenceFeatureFlags"/>
+        <type requires="VkFenceImportFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkFenceImportFlags</name>;</type>
+        <type                                             category="bitmask" name="VkFenceImportFlagsKHR"                     alias="VkFenceImportFlags"/>
+        <type requires="VkSurfaceCounterFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkSurfaceCounterFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineViewportSwizzleStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineDiscardRectangleStateCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageToColorStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageModulationStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineCoverageReductionStateCreateFlagsNV</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkValidationCacheCreateFlagsEXT</name>;</type>
+        <type requires="VkDebugUtilsMessageSeverityFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageSeverityFlagsEXT</name>;</type>
+        <type requires="VkDebugUtilsMessageTypeFlagBitsEXT" category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessageTypeFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDebugUtilsMessengerCallbackDataFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkDeviceMemoryReportFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationConservativeStateCreateFlagsEXT</name>;</type>
+        <type requires="VkDescriptorBindingFlagBits"      category="bitmask">typedef <type>VkFlags</type> <name>VkDescriptorBindingFlags</name>;</type>
+        <type                                             category="bitmask" name="VkDescriptorBindingFlagsEXT"               alias="VkDescriptorBindingFlags"/>
+        <type requires="VkConditionalRenderingFlagBitsEXT"  category="bitmask">typedef <type>VkFlags</type> <name>VkConditionalRenderingFlagsEXT</name>;</type>
+        <type requires="VkResolveModeFlagBits"            category="bitmask">typedef <type>VkFlags</type> <name>VkResolveModeFlags</name>;</type>
+        <type                                             category="bitmask" name="VkResolveModeFlagsKHR"                     alias="VkResolveModeFlags"/>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationStateStreamCreateFlagsEXT</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</name>;</type>
+        <type requires="VkSwapchainImageUsageFlagBitsANDROID" category="bitmask">typedef <type>VkFlags</type> <name>VkSwapchainImageUsageFlagsANDROID</name>;</type>
+        <type requires="VkToolPurposeFlagBitsEXT"         category="bitmask">typedef <type>VkFlags</type> <name>VkToolPurposeFlagsEXT</name>;</type>
+        <type requires="VkSubmitFlagBitsKHR"              category="bitmask">typedef <type>VkFlags</type> <name>VkSubmitFlagsKHR</name>;</type>
+        <type                                             category="bitmask">typedef <type>VkFlags</type> <name>VkImageFormatConstraintsFlagsFUCHSIA</name>;</type>
+        <type requires="VkImageConstraintsInfoFlagBitsFUCHSIA"     category="bitmask">typedef <type>VkFlags</type> <name>VkImageConstraintsInfoFlagsFUCHSIA</name>;</type>
+
+            <comment>Video Core extension</comment>
+        <type requires="VkVideoCodecOperationFlagBitsKHR"           category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCodecOperationFlagsKHR</name>;</type>
+        <type requires="VkVideoCapabilityFlagBitsKHR"               category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCapabilityFlagsKHR</name>;</type>
+        <type requires="VkVideoSessionCreateFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoSessionCreateFlagsKHR</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoBeginCodingFlagsKHR</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEndCodingFlagsKHR</name>;</type>
+        <type requires="VkVideoCodingQualityPresetFlagBitsKHR"      category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCodingQualityPresetFlagsKHR</name>;</type>
+        <type requires="VkVideoCodingControlFlagBitsKHR"            category="bitmask">typedef <type>VkFlags</type> <name>VkVideoCodingControlFlagsKHR</name>;</type>
+
+            <comment>Video Decode Core extension</comment>
+        <type requires="VkVideoDecodeFlagBitsKHR"                   category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeFlagsKHR</name>;</type>
+
+            <comment>Video Decode H.264 extension</comment>
+        <type requires="VkVideoDecodeH264PictureLayoutFlagBitsEXT"  category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeH264PictureLayoutFlagsEXT</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeH264CreateFlagsEXT</name>;</type>
+
+            <comment>Video Decode H.265 extension</comment>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoDecodeH265CreateFlagsEXT</name>;</type>
+
+            <comment>Video Encode Core extension</comment>
+        <type requires="VkVideoEncodeFlagBitsKHR"                   category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeFlagsKHR</name>;</type>
+        <type requires="VkVideoEncodeRateControlFlagBitsKHR"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRateControlFlagsKHR</name>;</type>
+        <type requires="VkVideoEncodeRateControlModeFlagBitsKHR"    category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeRateControlModeFlagsKHR</name>;</type>
+        <type requires="VkVideoChromaSubsamplingFlagBitsKHR"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoChromaSubsamplingFlagsKHR</name>;</type>
+        <type requires="VkVideoComponentBitDepthFlagBitsKHR"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoComponentBitDepthFlagsKHR</name>;</type>
+
+            <comment>Video Encode H.264 extension</comment>
+        <type requires="VkVideoEncodeH264CapabilityFlagBitsEXT"     category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264CapabilityFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH264InputModeFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264InputModeFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH264OutputModeFlagBitsEXT"     category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264OutputModeFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH264CreateFlagBitsEXT"         category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH264CreateFlagsEXT</name>;</type>
+
+            <comment>Video Encode H.265 extension</comment>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265CapabilityFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH265InputModeFlagBitsEXT"      category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265InputModeFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH265OutputModeFlagBitsEXT"     category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265OutputModeFlagsEXT</name>;</type>
+        <type                                                       category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265CreateFlagsEXT</name>;</type>
+        <type requires="VkVideoEncodeH265CtbSizeFlagBitsEXT"        category="bitmask">typedef <type>VkFlags</type> <name>VkVideoEncodeH265CtbSizeFlagsEXT</name>;</type>
+
+            <comment>Types which can be void pointers or class pointers, selected at compile time</comment>
+        <type category="handle"                           objtypeenum="VK_OBJECT_TYPE_INSTANCE"><type>VK_DEFINE_HANDLE</type>(<name>VkInstance</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_PHYSICAL_DEVICE"><type>VK_DEFINE_HANDLE</type>(<name>VkPhysicalDevice</name>)</type>
+        <type category="handle" parent="VkPhysicalDevice" objtypeenum="VK_OBJECT_TYPE_DEVICE"><type>VK_DEFINE_HANDLE</type>(<name>VkDevice</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_QUEUE"><type>VK_DEFINE_HANDLE</type>(<name>VkQueue</name>)</type>
+        <type category="handle" parent="VkCommandPool"    objtypeenum="VK_OBJECT_TYPE_COMMAND_BUFFER"><type>VK_DEFINE_HANDLE</type>(<name>VkCommandBuffer</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DEVICE_MEMORY"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeviceMemory</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_COMMAND_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCommandPool</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBuffer</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER_VIEW"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferView</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_IMAGE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImage</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_IMAGE_VIEW"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkImageView</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SHADER_MODULE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkShaderModule</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipeline</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE_LAYOUT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineLayout</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SAMPLER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSampler</name>)</type>
+        <type category="handle" parent="VkDescriptorPool" objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_SET"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSet</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorSetLayout</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorPool</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_FENCE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFence</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SEMAPHORE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSemaphore</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_EVENT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkEvent</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_QUERY_POOL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkQueryPool</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_FRAMEBUFFER"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkFramebuffer</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_RENDER_PASS"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkRenderPass</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PIPELINE_CACHE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPipelineCache</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkIndirectCommandsLayoutNV</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDescriptorUpdateTemplate</name>)</type>
+        <type category="handle" name="VkDescriptorUpdateTemplateKHR" alias="VkDescriptorUpdateTemplate"/>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSamplerYcbcrConversion</name>)</type>
+        <type category="handle" name="VkSamplerYcbcrConversionKHR"   alias="VkSamplerYcbcrConversion"/>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkValidationCacheEXT</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkAccelerationStructureKHR</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkAccelerationStructureNV</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPerformanceConfigurationINTEL</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkBufferCollectionFUCHSIA</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDeferredOperationKHR</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkPrivateDataSlotEXT</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_CU_MODULE_NVX"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCuModuleNVX</name>)</type>
+        <type category="handle" parent="VkDevice"         objtypeenum="VK_OBJECT_TYPE_CU_FUNCTION_NVX"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkCuFunctionNVX</name>)</type>
+
+            <comment>WSI extensions</comment>
+        <type category="handle" parent="VkPhysicalDevice" objtypeenum="VK_OBJECT_TYPE_DISPLAY_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayKHR</name>)</type>
+        <type category="handle" parent="VkDisplayKHR"     objtypeenum="VK_OBJECT_TYPE_DISPLAY_MODE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDisplayModeKHR</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_SURFACE_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSurfaceKHR</name>)</type>
+        <type category="handle" parent="VkSurfaceKHR"     objtypeenum="VK_OBJECT_TYPE_SWAPCHAIN_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkSwapchainKHR</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugReportCallbackEXT</name>)</type>
+        <type category="handle" parent="VkInstance"       objtypeenum="VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkDebugUtilsMessengerEXT</name>)</type>
+
+            <comment>Video extensions</comment>
+        <type category="handle" parent="VkDevice"          objtypeenum="VK_OBJECT_TYPE_VIDEO_SESSION_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkVideoSessionKHR</name>)</type>
+        <type category="handle" parent="VkVideoSessionKHR" objtypeenum="VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR"><type>VK_DEFINE_NON_DISPATCHABLE_HANDLE</type>(<name>VkVideoSessionParametersKHR</name>)</type>
+
+            <comment>Types generated from corresponding enums tags below</comment>
+        <type name="VkAttachmentLoadOp" category="enum"/>
+        <type name="VkAttachmentStoreOp" category="enum"/>
+        <type name="VkBlendFactor" category="enum"/>
+        <type name="VkBlendOp" category="enum"/>
+        <type name="VkBorderColor" category="enum"/>
+        <type name="VkFramebufferCreateFlagBits" category="enum"/>
+        <type name="VkQueryPoolCreateFlagBits" category="enum"/>
+        <type name="VkRenderPassCreateFlagBits" category="enum"/>
+        <type name="VkSamplerCreateFlagBits" category="enum"/>
+        <type name="VkPipelineCacheHeaderVersion" category="enum"/>
+        <type name="VkPipelineCacheCreateFlagBits" category="enum"/>
+        <type name="VkPipelineShaderStageCreateFlagBits" category="enum"/>
+        <type name="VkDescriptorSetLayoutCreateFlagBits" category="enum"/>
+        <type name="VkInstanceCreateFlagBits" category="enum"/>
+        <type name="VkDeviceQueueCreateFlagBits" category="enum"/>
+        <type name="VkBufferCreateFlagBits" category="enum"/>
+        <type name="VkBufferUsageFlagBits" category="enum"/>
+        <type name="VkColorComponentFlagBits" category="enum"/>
+        <type name="VkComponentSwizzle" category="enum"/>
+        <type name="VkCommandPoolCreateFlagBits" category="enum"/>
+        <type name="VkCommandPoolResetFlagBits" category="enum"/>
+        <type name="VkCommandBufferResetFlagBits" category="enum"/>
+        <type name="VkCommandBufferLevel" category="enum"/>
+        <type name="VkCommandBufferUsageFlagBits" category="enum"/>
+        <type name="VkCompareOp" category="enum"/>
+        <type name="VkCullModeFlagBits" category="enum"/>
+        <type name="VkDescriptorType" category="enum"/>
+        <type name="VkDeviceCreateFlagBits" category="enum"/>
+        <type name="VkDynamicState" category="enum"/>
+        <type name="VkFenceCreateFlagBits" category="enum"/>
+        <type name="VkPolygonMode" category="enum"/>
+        <type name="VkFormat" category="enum"/>
+        <type name="VkFormatFeatureFlagBits" category="enum"/>
+        <type name="VkFrontFace" category="enum"/>
+        <type name="VkImageAspectFlagBits" category="enum"/>
+        <type name="VkImageCreateFlagBits" category="enum"/>
+        <type name="VkImageLayout" category="enum"/>
+        <type name="VkImageTiling" category="enum"/>
+        <type name="VkImageType" category="enum"/>
+        <type name="VkImageUsageFlagBits" category="enum"/>
+        <type name="VkImageViewCreateFlagBits" category="enum"/>
+        <type name="VkImageViewType" category="enum"/>
+        <type name="VkSharingMode" category="enum"/>
+        <type name="VkIndexType" category="enum"/>
+        <type name="VkLogicOp" category="enum"/>
+        <type name="VkMemoryHeapFlagBits" category="enum"/>
+        <type name="VkAccessFlagBits" category="enum"/>
+        <type name="VkMemoryPropertyFlagBits" category="enum"/>
+        <type name="VkPhysicalDeviceType" category="enum"/>
+        <type name="VkPipelineBindPoint" category="enum"/>
+        <type name="VkPipelineCreateFlagBits" category="enum"/>
+        <type name="VkPrimitiveTopology" category="enum"/>
+        <type name="VkQueryControlFlagBits" category="enum"/>
+        <type name="VkQueryPipelineStatisticFlagBits" category="enum"/>
+        <type name="VkQueryResultFlagBits" category="enum"/>
+        <type name="VkQueryType" category="enum"/>
+        <type name="VkQueueFlagBits" category="enum"/>
+        <type name="VkSubpassContents" category="enum"/>
+        <type name="VkResult" category="enum"/>
+        <type name="VkShaderStageFlagBits" category="enum"/>
+        <type name="VkSparseMemoryBindFlagBits" category="enum"/>
+        <type name="VkStencilFaceFlagBits" category="enum"/>
+        <type name="VkStencilOp" category="enum"/>
+        <type name="VkStructureType" category="enum"/>
+        <type name="VkSystemAllocationScope" category="enum"/>
+        <type name="VkInternalAllocationType" category="enum"/>
+        <type name="VkSamplerAddressMode" category="enum"/>
+        <type name="VkFilter" category="enum"/>
+        <type name="VkSamplerMipmapMode" category="enum"/>
+        <type name="VkVertexInputRate" category="enum"/>
+        <type name="VkPipelineStageFlagBits" category="enum"/>
+        <type name="VkSparseImageFormatFlagBits" category="enum"/>
+        <type name="VkSampleCountFlagBits" category="enum"/>
+        <type name="VkAttachmentDescriptionFlagBits" category="enum"/>
+        <type name="VkDescriptorPoolCreateFlagBits" category="enum"/>
+        <type name="VkDependencyFlagBits" category="enum"/>
+        <type name="VkObjectType" category="enum"/>
+        <type name="VkEventCreateFlagBits" category="enum"/>
+        <type name="VkPipelineLayoutCreateFlagBits" category="enum"/>
+        <type name="VkSemaphoreCreateFlagBits" category="enum"/>
+
+        <comment>Extensions</comment>
+        <type name="VkIndirectCommandsLayoutUsageFlagBitsNV" category="enum"/>
+        <type name="VkIndirectCommandsTokenTypeNV" category="enum"/>
+        <type name="VkIndirectStateFlagBitsNV" category="enum"/>
+        <type name="VkPrivateDataSlotCreateFlagBitsEXT" category="enum"/>
+        <type name="VkDescriptorUpdateTemplateType" category="enum"/>
+        <type category="enum" name="VkDescriptorUpdateTemplateTypeKHR"             alias="VkDescriptorUpdateTemplateType"/>
+        <type name="VkViewportCoordinateSwizzleNV" category="enum"/>
+        <type name="VkDiscardRectangleModeEXT" category="enum"/>
+        <type name="VkSubpassDescriptionFlagBits" category="enum"/>
+        <type name="VkPointClippingBehavior" category="enum"/>
+        <type category="enum" name="VkPointClippingBehaviorKHR"                    alias="VkPointClippingBehavior"/>
+        <type name="VkCoverageModulationModeNV" category="enum"/>
+        <type name="VkCoverageReductionModeNV" category="enum"/>
+        <type name="VkValidationCacheHeaderVersionEXT" category="enum"/>
+        <type name="VkShaderInfoTypeAMD" category="enum"/>
+        <type name="VkQueueGlobalPriorityEXT" category="enum"/>
+        <type name="VkTimeDomainEXT" category="enum"/>
+        <type name="VkConservativeRasterizationModeEXT" category="enum"/>
+        <type name="VkResolveModeFlagBits" category="enum"/>
+        <type category="enum" name="VkResolveModeFlagBitsKHR"                      alias="VkResolveModeFlagBits"/>
+        <type name="VkDescriptorBindingFlagBits" category="enum"/>
+        <type category="enum" name="VkDescriptorBindingFlagBitsEXT"                alias="VkDescriptorBindingFlagBits"/>
+        <type name="VkConditionalRenderingFlagBitsEXT" category="enum"/>
+        <type name="VkSemaphoreType" category="enum"/>
+        <type category="enum" name="VkSemaphoreTypeKHR"                            alias="VkSemaphoreType"/>
+        <type name="VkGeometryFlagBitsKHR" category="enum"/>
+        <type category="enum" name="VkGeometryFlagBitsNV"                          alias="VkGeometryFlagBitsKHR"/>
+        <type name="VkGeometryInstanceFlagBitsKHR" category="enum"/>
+        <type category="enum" name="VkGeometryInstanceFlagBitsNV"                  alias="VkGeometryInstanceFlagBitsKHR"/>
+        <type name="VkBuildAccelerationStructureFlagBitsKHR" category="enum"/>
+        <type category="enum" name="VkBuildAccelerationStructureFlagBitsNV"        alias="VkBuildAccelerationStructureFlagBitsKHR"/>
+        <type name="VkAccelerationStructureCreateFlagBitsKHR" category="enum"/>
+        <type name="VkBuildAccelerationStructureModeKHR" category="enum"/>
+        <type name="VkCopyAccelerationStructureModeKHR" category="enum"/>
+        <type category="enum" name="VkCopyAccelerationStructureModeNV"             alias="VkCopyAccelerationStructureModeKHR"/>
+        <type name="VkAccelerationStructureTypeKHR" category="enum"/>
+        <type category="enum" name="VkAccelerationStructureTypeNV"                 alias="VkAccelerationStructureTypeKHR"/>
+        <type name="VkGeometryTypeKHR" category="enum"/>
+        <type category="enum" name="VkGeometryTypeNV"                              alias="VkGeometryTypeKHR"/>
+        <type name="VkRayTracingShaderGroupTypeKHR" category="enum"/>
+        <type category="enum" name="VkRayTracingShaderGroupTypeNV"                 alias="VkRayTracingShaderGroupTypeKHR"/>
+        <type name="VkAccelerationStructureMemoryRequirementsTypeNV" category="enum"/>
+        <type name="VkAccelerationStructureBuildTypeKHR" category="enum"/>
+        <type name="VkAccelerationStructureCompatibilityKHR" category="enum"/>
+        <type name="VkShaderGroupShaderKHR" category="enum"/>
+        <type name="VkMemoryOverallocationBehaviorAMD" category="enum"/>
+        <type name="VkScopeNV" category="enum"/>
+        <type name="VkComponentTypeNV" category="enum"/>
+        <type name="VkDeviceDiagnosticsConfigFlagBitsNV" category="enum"/>
+        <type name="VkPipelineCreationFeedbackFlagBitsEXT" category="enum"/>
+        <type name="VkPerformanceCounterScopeKHR" category="enum"/>
+        <type name="VkPerformanceCounterUnitKHR" category="enum"/>
+        <type name="VkPerformanceCounterStorageKHR" category="enum"/>
+        <type name="VkPerformanceCounterDescriptionFlagBitsKHR" category="enum"/>
+        <type name="VkAcquireProfilingLockFlagBitsKHR" category="enum"/>
+        <type name="VkSemaphoreWaitFlagBits" category="enum"/>
+        <type category="enum" name="VkSemaphoreWaitFlagBitsKHR"                    alias="VkSemaphoreWaitFlagBits"/>
+        <type name="VkPerformanceConfigurationTypeINTEL" category="enum"/>
+        <type name="VkQueryPoolSamplingModeINTEL" category="enum"/>
+        <type name="VkPerformanceOverrideTypeINTEL" category="enum"/>
+        <type name="VkPerformanceParameterTypeINTEL" category="enum"/>
+        <type name="VkPerformanceValueTypeINTEL" category="enum"/>
+        <type name="VkLineRasterizationModeEXT" category="enum"/>
+        <type name="VkShaderModuleCreateFlagBits" category="enum"/>
+        <type name="VkPipelineCompilerControlFlagBitsAMD" category="enum"/>
+        <type name="VkShaderCorePropertiesFlagBitsAMD" category="enum"/>
+        <type name="VkToolPurposeFlagBitsEXT" category="enum"/>
+        <type name="VkFragmentShadingRateNV" category="enum"/>
+        <type name="VkFragmentShadingRateTypeNV" category="enum"/>
+        <type name="VkAccessFlagBits2KHR" category="enum"/>
+        <type name="VkPipelineStageFlagBits2KHR" category="enum"/>
+        <type name="VkProvokingVertexModeEXT" category="enum"/>
+        <type name="VkImageFormatConstraintsFlagBitsFUCHSIA" category="enum"/>
+        <type name="VkImageConstraintsInfoFlagBitsFUCHSIA" category="enum"/>
+        <type name="VkFormatFeatureFlagBits2KHR" category="enum"/>
+        <type name="VkRenderingFlagBitsKHR" category="enum"/>
+
+            <comment>WSI extensions</comment>
+        <type name="VkColorSpaceKHR" category="enum"/>
+        <type name="VkCompositeAlphaFlagBitsKHR" category="enum"/>
+        <type name="VkDisplayPlaneAlphaFlagBitsKHR" category="enum"/>
+        <type name="VkPresentModeKHR" category="enum"/>
+        <type name="VkSurfaceTransformFlagBitsKHR" category="enum"/>
+        <type name="VkDebugReportFlagBitsEXT" category="enum"/>
+        <type name="VkDebugReportObjectTypeEXT" category="enum"/>
+        <type name="VkDeviceMemoryReportEventTypeEXT" category="enum"/>
+        <type name="VkRasterizationOrderAMD" category="enum"/>
+        <type name="VkExternalMemoryHandleTypeFlagBitsNV" category="enum"/>
+        <type name="VkExternalMemoryFeatureFlagBitsNV" category="enum"/>
+        <type name="VkValidationCheckEXT" category="enum"/>
+        <type name="VkValidationFeatureEnableEXT" category="enum"/>
+        <type name="VkValidationFeatureDisableEXT" category="enum"/>
+        <type name="VkExternalMemoryHandleTypeFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalMemoryHandleTypeFlagBitsKHR"         alias="VkExternalMemoryHandleTypeFlagBits"/>
+        <type name="VkExternalMemoryFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalMemoryFeatureFlagBitsKHR"            alias="VkExternalMemoryFeatureFlagBits"/>
+        <type name="VkExternalSemaphoreHandleTypeFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalSemaphoreHandleTypeFlagBitsKHR"      alias="VkExternalSemaphoreHandleTypeFlagBits"/>
+        <type name="VkExternalSemaphoreFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalSemaphoreFeatureFlagBitsKHR"         alias="VkExternalSemaphoreFeatureFlagBits"/>
+        <type name="VkSemaphoreImportFlagBits" category="enum"/>
+        <type category="enum" name="VkSemaphoreImportFlagBitsKHR"                  alias="VkSemaphoreImportFlagBits"/>
+        <type name="VkExternalFenceHandleTypeFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalFenceHandleTypeFlagBitsKHR"          alias="VkExternalFenceHandleTypeFlagBits"/>
+        <type name="VkExternalFenceFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkExternalFenceFeatureFlagBitsKHR"             alias="VkExternalFenceFeatureFlagBits"/>
+        <type name="VkFenceImportFlagBits" category="enum"/>
+        <type category="enum" name="VkFenceImportFlagBitsKHR"                      alias="VkFenceImportFlagBits"/>
+        <type name="VkSurfaceCounterFlagBitsEXT" category="enum"/>
+        <type name="VkDisplayPowerStateEXT" category="enum"/>
+        <type name="VkDeviceEventTypeEXT" category="enum"/>
+        <type name="VkDisplayEventTypeEXT" category="enum"/>
+        <type name="VkPeerMemoryFeatureFlagBits" category="enum"/>
+        <type category="enum" name="VkPeerMemoryFeatureFlagBitsKHR"                alias="VkPeerMemoryFeatureFlagBits"/>
+        <type name="VkMemoryAllocateFlagBits" category="enum"/>
+        <type category="enum" name="VkMemoryAllocateFlagBitsKHR"                   alias="VkMemoryAllocateFlagBits"/>
+        <type name="VkDeviceGroupPresentModeFlagBitsKHR" category="enum"/>
+        <type name="VkSwapchainCreateFlagBitsKHR" category="enum"/>
+        <type name="VkSubgroupFeatureFlagBits" category="enum"/>
+        <type name="VkTessellationDomainOrigin" category="enum"/>
+        <type category="enum" name="VkTessellationDomainOriginKHR"                 alias="VkTessellationDomainOrigin"/>
+        <type name="VkSamplerYcbcrModelConversion" category="enum"/>
+        <type category="enum" name="VkSamplerYcbcrModelConversionKHR"              alias="VkSamplerYcbcrModelConversion"/>
+        <type name="VkSamplerYcbcrRange" category="enum"/>
+        <type category="enum" name="VkSamplerYcbcrRangeKHR"                        alias="VkSamplerYcbcrRange"/>
+        <type name="VkChromaLocation" category="enum"/>
+        <type category="enum" name="VkChromaLocationKHR"                           alias="VkChromaLocation"/>
+        <type name="VkSamplerReductionMode" category="enum"/>
+        <type category="enum" name="VkSamplerReductionModeEXT"                     alias="VkSamplerReductionMode"/>
+        <type name="VkBlendOverlapEXT" category="enum"/>
+        <type name="VkDebugUtilsMessageSeverityFlagBitsEXT" category="enum"/>
+        <type name="VkDebugUtilsMessageTypeFlagBitsEXT" category="enum"/>
+        <type name="VkFullScreenExclusiveEXT" category="enum"/>
+        <type name="VkShaderFloatControlsIndependence" category="enum"/>
+        <type category="enum" name="VkShaderFloatControlsIndependenceKHR"          alias="VkShaderFloatControlsIndependence"/>
+        <type name="VkSwapchainImageUsageFlagBitsANDROID" category="enum"/>
+        <type name="VkFragmentShadingRateCombinerOpKHR" category="enum"/>
+        <type name="VkSubmitFlagBitsKHR" category="enum"/>
+
+            <comment>Enumerated types in the header, but not used by the API</comment>
+        <type name="VkVendorId" category="enum"/>
+        <type name="VkDriverId" category="enum"/>
+        <type category="enum" name="VkDriverIdKHR"                                 alias="VkDriverId"/>
+        <type name="VkShadingRatePaletteEntryNV" category="enum"/>
+        <type name="VkCoarseSampleOrderTypeNV" category="enum"/>
+        <type name="VkPipelineExecutableStatisticFormatKHR" category="enum"/>
+
+            <comment>Video Core extensions</comment>
+        <type name="VkVideoCodecOperationFlagBitsKHR" category="enum"/>
+        <type name="VkVideoChromaSubsamplingFlagBitsKHR" category="enum"/>
+        <type name="VkVideoComponentBitDepthFlagBitsKHR" category="enum"/>
+        <type name="VkVideoCapabilityFlagBitsKHR" category="enum"/>
+        <type name="VkVideoSessionCreateFlagBitsKHR" category="enum"/>
+        <type name="VkVideoCodingQualityPresetFlagBitsKHR" category="enum"/>
+        <type name="VkVideoCodingControlFlagBitsKHR" category="enum"/>
+        <type name="VkQueryResultStatusKHR" category="enum"/>
+
+            <comment>Video Decode extensions</comment>
+        <type name="VkVideoDecodeFlagBitsKHR" category="enum"/>
+
+            <comment>Video H.264 Decode extensions</comment>
+        <type name="VkVideoDecodeH264PictureLayoutFlagBitsEXT" category="enum"/>
+
+            <comment>Video H.265 Decode extensions</comment>
+
+            <comment>Video Encode extensions</comment>
+        <type name="VkVideoEncodeFlagBitsKHR" category="enum"/>
+        <type name="VkVideoEncodeRateControlFlagBitsKHR" category="enum"/>
+        <type name="VkVideoEncodeRateControlModeFlagBitsKHR" category="enum"/>
+
+           <comment>Video H.264 Encode extensions</comment>
+        <type name="VkVideoEncodeH264CapabilityFlagBitsEXT"     category="enum"/>
+        <type name="VkVideoEncodeH264InputModeFlagBitsEXT"      category="enum"/>
+        <type name="VkVideoEncodeH264OutputModeFlagBitsEXT"     category="enum"/>
+        <type name="VkVideoEncodeH264CreateFlagBitsEXT"         category="enum"/>
+
+           <comment>Video H.265 Encode extensions</comment>
+        <type name="VkVideoEncodeH265InputModeFlagBitsEXT"      category="enum"/>
+        <type name="VkVideoEncodeH265OutputModeFlagBitsEXT"     category="enum"/>
+        <type name="VkVideoEncodeH265CtbSizeFlagBitsEXT"        category="enum"/>
+
+        <comment>The PFN_vk*Function types are used by VkAllocationCallbacks below</comment>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalAllocationNotification</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>size_t</type>                                      size,
+    <type>VkInternalAllocationType</type>                    allocationType,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkInternalFreeNotification</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>size_t</type>                                      size,
+    <type>VkInternalAllocationType</type>                    allocationType,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkReallocationFunction</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>void</type>*                                       pOriginal,
+    <type>size_t</type>                                      size,
+    <type>size_t</type>                                      alignment,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void* (VKAPI_PTR *<name>PFN_vkAllocationFunction</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>size_t</type>                                      size,
+    <type>size_t</type>                                      alignment,
+    <type>VkSystemAllocationScope</type>                     allocationScope);</type>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkFreeFunction</name>)(
+    <type>void</type>*                                       pUserData,
+    <type>void</type>*                                       pMemory);</type>
+
+            <comment>The PFN_vkVoidFunction type are used by VkGet*ProcAddr below</comment>
+        <type category="funcpointer">typedef void (VKAPI_PTR *<name>PFN_vkVoidFunction</name>)(void);</type>
+
+            <comment>The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension</comment>
+        <type category="funcpointer">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugReportCallbackEXT</name>)(
+    <type>VkDebugReportFlagsEXT</type>                       flags,
+    <type>VkDebugReportObjectTypeEXT</type>                  objectType,
+    <type>uint64_t</type>                                    object,
+    <type>size_t</type>                                      location,
+    <type>int32_t</type>                                     messageCode,
+    const <type>char</type>*                                 pLayerPrefix,
+    const <type>char</type>*                                 pMessage,
+    <type>void</type>*                                       pUserData);</type>
+
+            <comment>The PFN_vkDebugUtilsMessengerCallbackEXT type are used by the VK_EXT_debug_utils extension</comment>
+        <type category="funcpointer" requires="VkDebugUtilsMessengerCallbackDataEXT">typedef VkBool32 (VKAPI_PTR *<name>PFN_vkDebugUtilsMessengerCallbackEXT</name>)(
+    <type>VkDebugUtilsMessageSeverityFlagBitsEXT</type>           messageSeverity,
+    <type>VkDebugUtilsMessageTypeFlagsEXT</type>                  messageTypes,
+    const <type>VkDebugUtilsMessengerCallbackDataEXT</type>*      pCallbackData,
+    <type>void</type>*                                            pUserData);</type>
+
+            <comment>The PFN_vkDeviceMemoryReportCallbackEXT type is used by the VK_EXT_device_memory_report extension</comment>
+        <type category="funcpointer" requires="VkDeviceMemoryReportCallbackDataEXT">typedef void (VKAPI_PTR *<name>PFN_vkDeviceMemoryReportCallbackEXT</name>)(
+    const <type>VkDeviceMemoryReportCallbackDataEXT</type>*  pCallbackData,
+    <type>void</type>*                                       pUserData);</type>
+
+            <comment>Struct types</comment>
+        <type category="struct" name="VkBaseOutStructure">
+            <member><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">struct <type>VkBaseOutStructure</type>* <name>pNext</name></member>
+        </type>
+        <type category="struct" name="VkBaseInStructure">
+            <member><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const struct <type>VkBaseInStructure</type>* <name>pNext</name></member>
+        </type>
+        <type category="struct" name="VkOffset2D">
+            <member><type>int32_t</type>        <name>x</name></member>
+            <member><type>int32_t</type>        <name>y</name></member>
+        </type>
+        <type category="struct" name="VkOffset3D">
+            <member><type>int32_t</type>        <name>x</name></member>
+            <member><type>int32_t</type>        <name>y</name></member>
+            <member><type>int32_t</type>        <name>z</name></member>
+        </type>
+        <type category="struct" name="VkExtent2D">
+            <member><type>uint32_t</type>        <name>width</name></member>
+            <member><type>uint32_t</type>        <name>height</name></member>
+        </type>
+        <type category="struct" name="VkExtent3D">
+            <member><type>uint32_t</type>        <name>width</name></member>
+            <member><type>uint32_t</type>        <name>height</name></member>
+            <member><type>uint32_t</type>        <name>depth</name></member>
+        </type>
+        <type category="struct" name="VkViewport">
+            <member noautovalidity="true"><type>float</type> <name>x</name></member>
+            <member noautovalidity="true"><type>float</type> <name>y</name></member>
+            <member noautovalidity="true"><type>float</type> <name>width</name></member>
+            <member noautovalidity="true"><type>float</type> <name>height</name></member>
+            <member><type>float</type>                       <name>minDepth</name></member>
+            <member><type>float</type>                       <name>maxDepth</name></member>
+        </type>
+        <type category="struct" name="VkRect2D">
+            <member><type>VkOffset2D</type>     <name>offset</name></member>
+            <member><type>VkExtent2D</type>     <name>extent</name></member>
+        </type>
+        <type category="struct" name="VkClearRect">
+            <member><type>VkRect2D</type>       <name>rect</name></member>
+            <member><type>uint32_t</type>       <name>baseArrayLayer</name></member>
+            <member><type>uint32_t</type>       <name>layerCount</name></member>
+        </type>
+        <type category="struct" name="VkComponentMapping">
+            <member><type>VkComponentSwizzle</type> <name>r</name></member>
+            <member><type>VkComponentSwizzle</type> <name>g</name></member>
+            <member><type>VkComponentSwizzle</type> <name>b</name></member>
+            <member><type>VkComponentSwizzle</type> <name>a</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProperties" returnedonly="true">
+            <member limittype="noauto"><type>uint32_t</type>       <name>apiVersion</name></member>
+            <member limittype="noauto"><type>uint32_t</type>       <name>driverVersion</name></member>
+            <member limittype="noauto"><type>uint32_t</type>       <name>vendorID</name></member>
+            <member limittype="noauto"><type>uint32_t</type>       <name>deviceID</name></member>
+            <member limittype="noauto"><type>VkPhysicalDeviceType</type> <name>deviceType</name></member>
+            <member limittype="noauto"><type>char</type>           <name>deviceName</name>[<enum>VK_MAX_PHYSICAL_DEVICE_NAME_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>        <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="struct"><type>VkPhysicalDeviceLimits</type> <name>limits</name></member>
+            <member limittype="struct"><type>VkPhysicalDeviceSparseProperties</type> <name>sparseProperties</name></member>
+        </type>
+        <type category="struct" name="VkExtensionProperties" returnedonly="true">
+            <member><type>char</type>            <name>extensionName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>extension name</comment></member>
+            <member><type>uint32_t</type>        <name>specVersion</name><comment>version of the extension specification implemented</comment></member>
+        </type>
+        <type category="struct" name="VkLayerProperties" returnedonly="true">
+            <member><type>char</type>            <name>layerName</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]<comment>layer name</comment></member>
+            <member><type>uint32_t</type>        <name>specVersion</name><comment>version of the layer specification implemented</comment></member>
+            <member><type>uint32_t</type>        <name>implementationVersion</name><comment>build or release version of the layer's library</comment></member>
+            <member><type>char</type>            <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]<comment>Free-form description of the layer</comment></member>
+        </type>
+        <type category="struct" name="VkApplicationInfo">
+            <member values="VK_STRUCTURE_TYPE_APPLICATION_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pApplicationName</name></member>
+            <member><type>uint32_t</type>        <name>applicationVersion</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*     <name>pEngineName</name></member>
+            <member><type>uint32_t</type>        <name>engineVersion</name></member>
+            <member><type>uint32_t</type>        <name>apiVersion</name></member>
+        </type>
+        <type category="struct" name="VkAllocationCallbacks">
+            <member optional="true"><type>void</type>*           <name>pUserData</name></member>
+            <member noautovalidity="true"><type>PFN_vkAllocationFunction</type>   <name>pfnAllocation</name></member>
+            <member noautovalidity="true"><type>PFN_vkReallocationFunction</type> <name>pfnReallocation</name></member>
+            <member noautovalidity="true"><type>PFN_vkFreeFunction</type>    <name>pfnFree</name></member>
+            <member optional="true" noautovalidity="true"><type>PFN_vkInternalAllocationNotification</type> <name>pfnInternalAllocation</name></member>
+            <member optional="true" noautovalidity="true"><type>PFN_vkInternalFreeNotification</type> <name>pfnInternalFree</name></member>
+        </type>
+        <type category="struct" name="VkDeviceQueueCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceQueueCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>        <name>queueFamilyIndex</name></member>
+            <member><type>uint32_t</type>        <name>queueCount</name></member>
+            <member len="queueCount">const <type>float</type>*    <name>pQueuePriorities</name></member>
+        </type>
+        <type category="struct" name="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>        <name>queueCreateInfoCount</name></member>
+            <member len="queueCreateInfoCount">const <type>VkDeviceQueueCreateInfo</type>* <name>pQueueCreateInfos</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
+            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
+            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name></member>
+            <member optional="true">const <type>VkPhysicalDeviceFeatures</type>* <name>pEnabledFeatures</name></member>
+        </type>
+        <type category="struct" name="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member optional="true"><type>VkInstanceCreateFlags</type>  <name>flags</name></member>
+            <member optional="true">const <type>VkApplicationInfo</type>* <name>pApplicationInfo</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>enabledLayerCount</name></member>
+            <member len="enabledLayerCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledLayerNames</name><comment>Ordered list of layer names to be enabled</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>enabledExtensionCount</name></member>
+            <member len="enabledExtensionCount,null-terminated">const <type>char</type>* const*      <name>ppEnabledExtensionNames</name><comment>Extension names to be enabled</comment></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyProperties" returnedonly="true">
+            <member optional="true"><type>VkQueueFlags</type>           <name>queueFlags</name><comment>Queue flags</comment></member>
+            <member><type>uint32_t</type>               <name>queueCount</name></member>
+            <member><type>uint32_t</type>               <name>timestampValidBits</name></member>
+            <member><type>VkExtent3D</type>             <name>minImageTransferGranularity</name><comment>Minimum alignment requirement for image transfers</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryProperties" returnedonly="true">
+            <member><type>uint32_t</type>               <name>memoryTypeCount</name></member>
+            <member><type>VkMemoryType</type>           <name>memoryTypes</name>[<enum>VK_MAX_MEMORY_TYPES</enum>]</member>
+            <member><type>uint32_t</type>               <name>memoryHeapCount</name></member>
+            <member><type>VkMemoryHeap</type>           <name>memoryHeaps</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
+        </type>
+        <type category="struct" name="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>           <name>allocationSize</name><comment>Size of memory allocation</comment></member>
+            <member><type>uint32_t</type>               <name>memoryTypeIndex</name><comment>Index of the of the memory type to allocate from</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryRequirements" returnedonly="true">
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>alignment</name><comment>Specified in bytes</comment></member>
+            <member><type>uint32_t</type>               <name>memoryTypeBits</name><comment>Bitmask of the allowed memory type indices into memoryTypes[] for this object</comment></member>
+        </type>
+        <type category="struct" name="VkSparseImageFormatProperties" returnedonly="true">
+            <member optional="true"><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>VkExtent3D</type>             <name>imageGranularity</name></member>
+            <member optional="true"><type>VkSparseImageFormatFlags</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryRequirements" returnedonly="true">
+            <member><type>VkSparseImageFormatProperties</type> <name>formatProperties</name></member>
+            <member><type>uint32_t</type>               <name>imageMipTailFirstLod</name></member>
+            <member><type>VkDeviceSize</type>           <name>imageMipTailSize</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
+            <member><type>VkDeviceSize</type>           <name>imageMipTailOffset</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
+            <member><type>VkDeviceSize</type>           <name>imageMipTailStride</name><comment>Specified in bytes, must be a multiple of sparse block size in bytes / alignment</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryType" returnedonly="true">
+            <member optional="true"><type>VkMemoryPropertyFlags</type>  <name>propertyFlags</name><comment>Memory properties of this memory type</comment></member>
+            <member><type>uint32_t</type>               <name>heapIndex</name><comment>Index of the memory heap allocations of this memory type are taken from</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryHeap" returnedonly="true">
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Available memory in the heap</comment></member>
+            <member optional="true"><type>VkMemoryHeapFlags</type>      <name>flags</name><comment>Flags for the heap</comment></member>
+        </type>
+        <type category="struct" name="VkMappedMemoryRange">
+            <member values="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>         <name>memory</name><comment>Mapped memory object</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the memory object where the range starts</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Size of the range within the memory object</comment></member>
+        </type>
+        <type category="struct" name="VkFormatProperties" returnedonly="true">
+            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>linearTilingFeatures</name><comment>Format features in case of linear tiling</comment></member>
+            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>optimalTilingFeatures</name><comment>Format features in case of optimal tiling</comment></member>
+            <member optional="true"><type>VkFormatFeatureFlags</type>   <name>bufferFeatures</name><comment>Format features supported by buffers</comment></member>
+        </type>
+        <type category="struct" name="VkImageFormatProperties" returnedonly="true">
+            <member><type>VkExtent3D</type>             <name>maxExtent</name><comment>max image dimensions for this resource type</comment></member>
+            <member><type>uint32_t</type>               <name>maxMipLevels</name><comment>max number of mipmap levels for this resource type</comment></member>
+            <member><type>uint32_t</type>               <name>maxArrayLayers</name><comment>max array size for this resource type</comment></member>
+            <member optional="true"><type>VkSampleCountFlags</type>     <name>sampleCounts</name><comment>supported sample counts for this resource type</comment></member>
+            <member><type>VkDeviceSize</type>           <name>maxResourceSize</name><comment>max size (in bytes) of this resource type</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorBufferInfo">
+            <member optional="true"><type>VkBuffer</type>               <name>buffer</name><comment>Buffer used for this descriptor slot.</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Base offset from buffer start in bytes to update in the descriptor set.</comment></member>
+            <member><type>VkDeviceSize</type>           <name>range</name><comment>Size in bytes of the buffer resource for this descriptor update.</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorImageInfo">
+            <member noautovalidity="true"><type>VkSampler</type>       <name>sampler</name><comment>Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.</comment></member>
+            <member noautovalidity="true"><type>VkImageView</type>     <name>imageView</name><comment>Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.</comment></member>
+            <member noautovalidity="true"><type>VkImageLayout</type>   <name>imageLayout</name><comment>Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).</comment></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
+            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
+            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
+            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
+            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)</comment></member>
+            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorImageInfo</type>* <name>pImageInfo</name><comment>Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.</comment></member>
+            <member noautovalidity="true" len="descriptorCount">const <type>VkDescriptorBufferInfo</type>* <name>pBufferInfo</name><comment>Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.</comment></member>
+            <member noautovalidity="true" len="descriptorCount">const <type>VkBufferView</type>*    <name>pTexelBufferView</name><comment>Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.</comment></member>
+        </type>
+        <type category="struct" name="VkCopyDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDescriptorSet</type>        <name>srcSet</name><comment>Source descriptor set</comment></member>
+            <member><type>uint32_t</type>               <name>srcBinding</name><comment>Binding within the source descriptor set to copy from</comment></member>
+            <member><type>uint32_t</type>               <name>srcArrayElement</name><comment>Array element within the source binding to copy from</comment></member>
+            <member><type>VkDescriptorSet</type>        <name>dstSet</name><comment>Destination descriptor set</comment></member>
+            <member><type>uint32_t</type>               <name>dstBinding</name><comment>Binding within the destination descriptor set to copy to</comment></member>
+            <member><type>uint32_t</type>               <name>dstArrayElement</name><comment>Array element within the destination binding to copy to</comment></member>
+            <member><type>uint32_t</type>               <name>descriptorCount</name><comment>Number of descriptors to write (determines the size of the array pointed by pDescriptors)</comment></member>
+        </type>
+        <type category="struct" name="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkBufferCreateFlags</type>    <name>flags</name><comment>Buffer creation flags</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member><type>VkBufferUsageFlags</type>     <name>usage</name><comment>Buffer usage flags</comment></member>
+            <member><type>VkSharingMode</type>          <name>sharingMode</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name></member>
+        </type>
+        <type category="struct" name="VkBufferViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkBufferViewCreateFlags</type><name>flags</name></member>
+            <member><type>VkBuffer</type>               <name>buffer</name></member>
+            <member><type>VkFormat</type>               <name>format</name><comment>Optionally specifies format of elements</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>range</name><comment>View size specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkImageSubresource">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>mipLevel</name></member>
+            <member><type>uint32_t</type>               <name>arrayLayer</name></member>
+        </type>
+        <type category="struct" name="VkImageSubresourceLayers">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>mipLevel</name></member>
+            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
+            <member><type>uint32_t</type>               <name>layerCount</name></member>
+        </type>
+        <type category="struct" name="VkImageSubresourceRange">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>baseMipLevel</name></member>
+            <member><type>uint32_t</type>               <name>levelCount</name></member>
+            <member><type>uint32_t</type>               <name>baseArrayLayer</name></member>
+            <member><type>uint32_t</type>               <name>layerCount</name></member>
+        </type>
+        <type category="struct" name="VkMemoryBarrier">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+        </type>
+        <type category="struct" name="VkBufferMemoryBarrier">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
+            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
+            <member><type>VkBuffer</type>               <name>buffer</name><comment>Buffer to sync</comment></member>
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Offset within the buffer to sync</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Amount of bytes to sync</comment></member>
+        </type>
+        <type category="struct" name="VkImageMemoryBarrier">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member noautovalidity="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+            <member><type>VkImageLayout</type>          <name>oldLayout</name><comment>Current layout of the image</comment></member>
+            <member><type>VkImageLayout</type>          <name>newLayout</name><comment>New layout to transition the image to</comment></member>
+            <member><type>uint32_t</type>               <name>srcQueueFamilyIndex</name><comment>Queue family to transition ownership from</comment></member>
+            <member><type>uint32_t</type>               <name>dstQueueFamilyIndex</name><comment>Queue family to transition ownership to</comment></member>
+            <member><type>VkImage</type>                <name>image</name><comment>Image to sync</comment></member>
+            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name><comment>Subresource range to sync</comment></member>
+        </type>
+        <type category="struct" name="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkImageCreateFlags</type>     <name>flags</name><comment>Image creation flags</comment></member>
+            <member><type>VkImageType</type>            <name>imageType</name></member>
+            <member><type>VkFormat</type>               <name>format</name></member>
+            <member><type>VkExtent3D</type>             <name>extent</name></member>
+            <member><type>uint32_t</type>               <name>mipLevels</name></member>
+            <member><type>uint32_t</type>               <name>arrayLayers</name></member>
+            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
+            <member><type>VkImageTiling</type>          <name>tiling</name></member>
+            <member><type>VkImageUsageFlags</type>      <name>usage</name><comment>Image usage flags</comment></member>
+            <member><type>VkSharingMode</type>          <name>sharingMode</name><comment>Cross-queue-family sharing mode</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>queueFamilyIndexCount</name><comment>Number of queue families to share across</comment></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*        <name>pQueueFamilyIndices</name><comment>Array of queue family indices to share across</comment></member>
+            <member><type>VkImageLayout</type>          <name>initialLayout</name><comment>Initial image layout for all subresources</comment></member>
+        </type>
+        <type category="struct" name="VkSubresourceLayout" returnedonly="true">
+            <member><type>VkDeviceSize</type>           <name>offset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>rowPitch</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>arrayPitch</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>depthPitch</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkImageViewCreateFlags</type> <name>flags</name></member>
+            <member><type>VkImage</type>                <name>image</name></member>
+            <member><type>VkImageViewType</type>        <name>viewType</name></member>
+            <member><type>VkFormat</type>               <name>format</name></member>
+            <member><type>VkComponentMapping</type>     <name>components</name></member>
+            <member><type>VkImageSubresourceRange</type> <name>subresourceRange</name></member>
+        </type>
+        <type category="struct" name="VkBufferCopy">
+            <member><type>VkDeviceSize</type>                       <name>srcOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>                       <name>dstOffset</name><comment>Specified in bytes</comment></member>
+            <member noautovalidity="true"><type>VkDeviceSize</type> <name>size</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkSparseMemoryBind">
+            <member><type>VkDeviceSize</type>           <name>resourceOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>           <name>size</name><comment>Specified in bytes</comment></member>
+            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
+            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
+            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryBind">
+            <member><type>VkImageSubresource</type>     <name>subresource</name></member>
+            <member><type>VkOffset3D</type>             <name>offset</name></member>
+            <member><type>VkExtent3D</type>             <name>extent</name></member>
+            <member optional="true"><type>VkDeviceMemory</type>         <name>memory</name></member>
+            <member><type>VkDeviceSize</type>           <name>memoryOffset</name><comment>Specified in bytes</comment></member>
+            <member optional="true"><type>VkSparseMemoryBindFlags</type><name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSparseBufferMemoryBindInfo">
+            <member><type>VkBuffer</type> <name>buffer</name></member>
+            <member><type>uint32_t</type>               <name>bindCount</name></member>
+            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageOpaqueMemoryBindInfo">
+            <member><type>VkImage</type> <name>image</name></member>
+            <member><type>uint32_t</type>               <name>bindCount</name></member>
+            <member len="bindCount">const <type>VkSparseMemoryBind</type>* <name>pBinds</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryBindInfo">
+            <member><type>VkImage</type> <name>image</name></member>
+            <member><type>uint32_t</type>               <name>bindCount</name></member>
+            <member len="bindCount">const <type>VkSparseImageMemoryBind</type>* <name>pBinds</name></member>
+        </type>
+        <type category="struct" name="VkBindSparseInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>waitSemaphoreCount</name></member>
+            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>bufferBindCount</name></member>
+            <member len="bufferBindCount">const <type>VkSparseBufferMemoryBindInfo</type>* <name>pBufferBinds</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>imageOpaqueBindCount</name></member>
+            <member len="imageOpaqueBindCount">const <type>VkSparseImageOpaqueMemoryBindInfo</type>* <name>pImageOpaqueBinds</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>imageBindCount</name></member>
+            <member len="imageBindCount">const <type>VkSparseImageMemoryBindInfo</type>* <name>pImageBinds</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>signalSemaphoreCount</name></member>
+            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
+        </type>
+        <type category="struct" name="VkImageCopy">
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>srcOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>dstOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type>             <name>extent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageBlit">
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>srcOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>dstOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkBufferImageCopy">
+            <member><type>VkDeviceSize</type>           <name>bufferOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>uint32_t</type>               <name>bufferRowLength</name><comment>Specified in texels</comment></member>
+            <member><type>uint32_t</type>               <name>bufferImageHeight</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>imageSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type>             <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageResolve">
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>srcOffset</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type>             <name>dstOffset</name></member>
+            <member><type>VkExtent3D</type>             <name>extent</name></member>
+        </type>
+        <type category="struct" name="VkShaderModuleCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkShaderModuleCreateFlags</type> <name>flags</name></member>
+            <member><type>size_t</type>                 <name>codeSize</name><comment>Specified in bytes</comment></member>
+            <member len="latexmath:[\textrm{codeSize} \over 4]" altlen="codeSize / 4">const <type>uint32_t</type>*            <name>pCode</name><comment>Binary code of size codeSize</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutBinding">
+            <member><type>uint32_t</type>               <name>binding</name><comment>Binding number for this entry</comment></member>
+            <member><type>VkDescriptorType</type>       <name>descriptorType</name><comment>Type of the descriptors in this binding</comment></member>
+            <member optional="true"><type>uint32_t</type> <name>descriptorCount</name><comment>Number of descriptors in this binding</comment></member>
+            <member noautovalidity="true"><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Shader stages this binding is visible to</comment></member>
+            <member noautovalidity="true" optional="true" len="descriptorCount">const <type>VkSampler</type>*       <name>pImmutableSamplers</name><comment>Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkDescriptorSetLayoutCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>bindingCount</name><comment>Number of bindings in the descriptor set layout</comment></member>
+            <member len="bindingCount">const <type>VkDescriptorSetLayoutBinding</type>* <name>pBindings</name><comment>Array of descriptor set layout bindings</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorPoolSize">
+            <member><type>VkDescriptorType</type>       <name>type</name></member>
+            <member><type>uint32_t</type>               <name>descriptorCount</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkDescriptorPoolCreateFlags</type>  <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>maxSets</name></member>
+            <member><type>uint32_t</type>               <name>poolSizeCount</name></member>
+            <member len="poolSizeCount">const <type>VkDescriptorPoolSize</type>* <name>pPoolSizes</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDescriptorPool</type>       <name>descriptorPool</name></member>
+            <member><type>uint32_t</type>               <name>descriptorSetCount</name></member>
+            <member len="descriptorSetCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name></member>
+        </type>
+        <type category="struct" name="VkSpecializationMapEntry">
+            <member><type>uint32_t</type>                     <name>constantID</name><comment>The SpecConstant ID specified in the BIL</comment></member>
+            <member><type>uint32_t</type>                     <name>offset</name><comment>Offset of the value in the data block</comment></member>
+            <member noautovalidity="true"><type>size_t</type> <name>size</name><comment>Size in bytes of the SpecConstant</comment></member>
+        </type>
+        <type category="struct" name="VkSpecializationInfo">
+            <member optional="true"><type>uint32_t</type>               <name>mapEntryCount</name><comment>Number of entries in the map</comment></member>
+            <member len="mapEntryCount">const <type>VkSpecializationMapEntry</type>* <name>pMapEntries</name><comment>Array of map entries</comment></member>
+            <member optional="true"><type>size_t</type>                 <name>dataSize</name><comment>Size in bytes of pData</comment></member>
+            <member len="dataSize">const <type>void</type>*            <name>pData</name><comment>Pointer to SpecConstant data</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineShaderStageCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkShaderStageFlagBits</type>  <name>stage</name><comment>Shader stage</comment></member>
+            <member><type>VkShaderModule</type>         <name>module</name><comment>Module containing entry point</comment></member>
+            <member len="null-terminated">const <type>char</type>*            <name>pName</name><comment>Null-terminated entry point name</comment></member>
+            <member optional="true">const <type>VkSpecializationInfo</type>* <name>pSpecializationInfo</name></member>
+        </type>
+        <type category="struct" name="VkComputePipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member><type>VkPipelineShaderStageCreateInfo</type> <name>stage</name></member>
+            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkVertexInputBindingDescription">
+            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
+            <member><type>uint32_t</type>               <name>stride</name><comment>Distance between vertices in bytes (0 = no advancement)</comment></member>
+            <member><type>VkVertexInputRate</type>      <name>inputRate</name><comment>The rate at which the vertex data is consumed</comment></member>
+        </type>
+        <type category="struct" name="VkVertexInputAttributeDescription">
+            <member><type>uint32_t</type>               <name>location</name><comment>location of the shader vertex attrib</comment></member>
+            <member><type>uint32_t</type>               <name>binding</name><comment>Vertex buffer binding id</comment></member>
+            <member><type>VkFormat</type>               <name>format</name><comment>format of source data</comment></member>
+            <member><type>uint32_t</type>               <name>offset</name><comment>Offset of first element in bytes from base of vertex</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineVertexInputStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineVertexInputStateCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>vertexBindingDescriptionCount</name><comment>number of bindings</comment></member>
+            <member len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription</type>* <name>pVertexBindingDescriptions</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>vertexAttributeDescriptionCount</name><comment>number of attributes</comment></member>
+            <member len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription</type>* <name>pVertexAttributeDescriptions</name></member>
+        </type>
+        <type category="struct" name="VkPipelineInputAssemblyStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineInputAssemblyStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkPrimitiveTopology</type>    <name>topology</name></member>
+            <member><type>VkBool32</type>               <name>primitiveRestartEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineTessellationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineTessellationStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>patchControlPoints</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineViewportStateCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>viewportCount</name></member>
+            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewport</type>*      <name>pViewports</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>scissorCount</name></member>
+            <member noautovalidity="true" optional="true" len="scissorCount">const <type>VkRect2D</type>*        <name>pScissors</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkBool32</type>               <name>depthClampEnable</name></member>
+            <member><type>VkBool32</type>               <name>rasterizerDiscardEnable</name></member>
+            <member><type>VkPolygonMode</type>          <name>polygonMode</name><comment>optional (GL45)</comment></member>
+            <member optional="true"><type>VkCullModeFlags</type>        <name>cullMode</name></member>
+            <member><type>VkFrontFace</type>            <name>frontFace</name></member>
+            <member><type>VkBool32</type>               <name>depthBiasEnable</name></member>
+            <member><type>float</type>                  <name>depthBiasConstantFactor</name></member>
+            <member><type>float</type>                  <name>depthBiasClamp</name></member>
+            <member><type>float</type>                  <name>depthBiasSlopeFactor</name></member>
+            <member><type>float</type>                  <name>lineWidth</name></member>
+        </type>
+        <type category="struct" name="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineMultisampleStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkSampleCountFlagBits</type>  <name>rasterizationSamples</name><comment>Number of samples used for rasterization</comment></member>
+            <member><type>VkBool32</type>               <name>sampleShadingEnable</name><comment>optional (GL45)</comment></member>
+            <member><type>float</type>                  <name>minSampleShading</name><comment>optional (GL45)</comment></member>
+            <member optional="true" len="latexmath:[\lceil{\mathit{rasterizationSamples} \over 32}\rceil]" altlen="(rasterizationSamples + 31) / 32">const <type>VkSampleMask</type>*    <name>pSampleMask</name><comment>Array of sampleMask words</comment></member>
+            <member><type>VkBool32</type>               <name>alphaToCoverageEnable</name></member>
+            <member><type>VkBool32</type>               <name>alphaToOneEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorBlendAttachmentState">
+            <member><type>VkBool32</type>               <name>blendEnable</name></member>
+            <member><type>VkBlendFactor</type>          <name>srcColorBlendFactor</name></member>
+            <member><type>VkBlendFactor</type>          <name>dstColorBlendFactor</name></member>
+            <member><type>VkBlendOp</type>              <name>colorBlendOp</name></member>
+            <member><type>VkBlendFactor</type>          <name>srcAlphaBlendFactor</name></member>
+            <member><type>VkBlendFactor</type>          <name>dstAlphaBlendFactor</name></member>
+            <member><type>VkBlendOp</type>              <name>alphaBlendOp</name></member>
+            <member optional="true"><type>VkColorComponentFlags</type>  <name>colorWriteMask</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorBlendStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineColorBlendStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkBool32</type>               <name>logicOpEnable</name></member>
+            <member noautovalidity="true"><type>VkLogicOp</type>              <name>logicOp</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name><comment># of pAttachments</comment></member>
+            <member len="attachmentCount">const <type>VkPipelineColorBlendAttachmentState</type>* <name>pAttachments</name></member>
+            <member><type>float</type>                  <name>blendConstants</name>[4]</member>
+        </type>
+        <type category="struct" name="VkPipelineDynamicStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineDynamicStateCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>dynamicStateCount</name></member>
+            <member len="dynamicStateCount">const <type>VkDynamicState</type>*  <name>pDynamicStates</name></member>
+        </type>
+        <type category="struct" name="VkStencilOpState">
+            <member><type>VkStencilOp</type>            <name>failOp</name></member>
+            <member><type>VkStencilOp</type>            <name>passOp</name></member>
+            <member><type>VkStencilOp</type>            <name>depthFailOp</name></member>
+            <member><type>VkCompareOp</type>            <name>compareOp</name></member>
+            <member><type>uint32_t</type>               <name>compareMask</name></member>
+            <member><type>uint32_t</type>               <name>writeMask</name></member>
+            <member><type>uint32_t</type>               <name>reference</name></member>
+        </type>
+        <type category="struct" name="VkPipelineDepthStencilStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineDepthStencilStateCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkBool32</type>               <name>depthTestEnable</name></member>
+            <member><type>VkBool32</type>               <name>depthWriteEnable</name></member>
+            <member><type>VkCompareOp</type>            <name>depthCompareOp</name></member>
+            <member><type>VkBool32</type>               <name>depthBoundsTestEnable</name><comment>optional (depth_bounds_test)</comment></member>
+            <member><type>VkBool32</type>               <name>stencilTestEnable</name></member>
+            <member><type>VkStencilOpState</type>       <name>front</name></member>
+            <member><type>VkStencilOpState</type>       <name>back</name></member>
+            <member><type>float</type>                  <name>minDepthBounds</name></member>
+            <member><type>float</type>                  <name>maxDepthBounds</name></member>
+        </type>
+        <type category="struct" name="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member><type>uint32_t</type>               <name>stageCount</name></member>
+            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineVertexInputStateCreateInfo</type>* <name>pVertexInputState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineInputAssemblyStateCreateInfo</type>* <name>pInputAssemblyState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>* <name>pTessellationState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineViewportStateCreateInfo</type>* <name>pViewportState</name></member>
+            <member>const <type>VkPipelineRasterizationStateCreateInfo</type>* <name>pRasterizationState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineMultisampleStateCreateInfo</type>* <name>pMultisampleState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineDepthStencilStateCreateInfo</type>* <name>pDepthStencilState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineColorBlendStateCreateInfo</type>* <name>pColorBlendState</name></member>
+            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
+            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member optional="true"><type>VkRenderPass</type>           <name>renderPass</name></member>
+            <member><type>uint32_t</type>               <name>subpass</name></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineCacheCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCacheCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name><comment>Size of initial data to populate cache, in bytes</comment></member>
+            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name><comment>Initial data to populate cache</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineCacheHeaderVersionOne">
+            <comment>The fields in this structure are non-normative since structure packing is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>uint32_t</type>               <name>headerSize</name></member>
+            <member><type>VkPipelineCacheHeaderVersion</type> <name>headerVersion</name></member>
+            <member><type>uint32_t</type>               <name>vendorID</name></member>
+            <member><type>uint32_t</type>               <name>deviceID</name></member>
+            <member><type>uint8_t</type>                <name>pipelineCacheUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkPushConstantRange">
+            <member><type>VkShaderStageFlags</type>     <name>stageFlags</name><comment>Which stages use the range</comment></member>
+            <member><type>uint32_t</type>               <name>offset</name><comment>Start of the range, in bytes</comment></member>
+            <member><type>uint32_t</type>               <name>size</name><comment>Size of the range, in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineLayoutCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineLayoutCreateFlags</type>    <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>setLayoutCount</name><comment>Number of descriptor sets interfaced by the pipeline</comment></member>
+            <member len="setLayoutCount">const <type>VkDescriptorSetLayout</type>* <name>pSetLayouts</name><comment>Array of setCount number of descriptor set layout objects defining the layout of the</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>pushConstantRangeCount</name><comment>Number of push-constant ranges used by the pipeline</comment></member>
+            <member len="pushConstantRangeCount">const <type>VkPushConstantRange</type>* <name>pPushConstantRanges</name><comment>Array of pushConstantRangeCount number of ranges used by various shader stages</comment></member>
+        </type>
+        <type category="struct" name="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkSamplerCreateFlags</type>   <name>flags</name></member>
+            <member><type>VkFilter</type>               <name>magFilter</name><comment>Filter mode for magnification</comment></member>
+            <member><type>VkFilter</type>               <name>minFilter</name><comment>Filter mode for minifiation</comment></member>
+            <member><type>VkSamplerMipmapMode</type>    <name>mipmapMode</name><comment>Mipmap selection mode</comment></member>
+            <member><type>VkSamplerAddressMode</type>   <name>addressModeU</name></member>
+            <member><type>VkSamplerAddressMode</type>   <name>addressModeV</name></member>
+            <member><type>VkSamplerAddressMode</type>   <name>addressModeW</name></member>
+            <member><type>float</type>                  <name>mipLodBias</name></member>
+            <member><type>VkBool32</type>               <name>anisotropyEnable</name></member>
+            <member><type>float</type>                  <name>maxAnisotropy</name></member>
+            <member><type>VkBool32</type>               <name>compareEnable</name></member>
+            <member noautovalidity="true"><type>VkCompareOp</type>            <name>compareOp</name></member>
+            <member><type>float</type>                  <name>minLod</name></member>
+            <member><type>float</type>                  <name>maxLod</name></member>
+            <member noautovalidity="true"><type>VkBorderColor</type>          <name>borderColor</name></member>
+            <member><type>VkBool32</type>               <name>unnormalizedCoordinates</name></member>
+        </type>
+        <type category="struct" name="VkCommandPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkCommandPoolCreateFlags</type>   <name>flags</name><comment>Command pool creation flags</comment></member>
+            <member><type>uint32_t</type>               <name>queueFamilyIndex</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkCommandPool</type>          <name>commandPool</name></member>
+            <member><type>VkCommandBufferLevel</type>   <name>level</name></member>
+            <member><type>uint32_t</type>               <name>commandBufferCount</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true" noautovalidity="true"><type>VkRenderPass</type>    <name>renderPass</name><comment>Render pass for secondary command buffers</comment></member>
+            <member><type>uint32_t</type>               <name>subpass</name></member>
+            <member optional="true" noautovalidity="true"><type>VkFramebuffer</type>   <name>framebuffer</name><comment>Framebuffer for secondary command buffers</comment></member>
+            <member><type>VkBool32</type>               <name>occlusionQueryEnable</name><comment>Whether this secondary command buffer may be executed during an occlusion query</comment></member>
+            <member optional="true" noautovalidity="true"><type>VkQueryControlFlags</type>    <name>queryFlags</name><comment>Query flags used by this secondary command buffer, if executed during an occlusion query</comment></member>
+            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Pipeline statistics that may be counted for this secondary command buffer</comment></member>
+        </type>
+        <type category="struct" name="VkCommandBufferBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkCommandBufferUsageFlags</type>  <name>flags</name><comment>Command buffer usage flags</comment></member>
+            <member optional="true" noautovalidity="true">const <type>VkCommandBufferInheritanceInfo</type>*       <name>pInheritanceInfo</name><comment>Pointer to inheritance info for secondary command buffers</comment></member>
+        </type>
+        <type category="struct" name="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
+            <member><type>VkFramebuffer</type>          <name>framebuffer</name></member>
+            <member><type>VkRect2D</type>               <name>renderArea</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>clearValueCount</name></member>
+            <member len="clearValueCount" noautovalidity="true">const <type>VkClearValue</type>*    <name>pClearValues</name></member>
+        </type>
+        <type category="union" name="VkClearColorValue" comment="// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.">
+            <member><type>float</type>                  <name>float32</name>[4]</member>
+            <member><type>int32_t</type>                <name>int32</name>[4]</member>
+            <member><type>uint32_t</type>               <name>uint32</name>[4]</member>
+        </type>
+        <type category="struct" name="VkClearDepthStencilValue">
+            <member><type>float</type>                  <name>depth</name></member>
+            <member><type>uint32_t</type>               <name>stencil</name></member>
+        </type>
+        <type category="union" name="VkClearValue" comment="// Union allowing specification of color or depth and stencil values. Actual value selected is based on attachment being cleared.">
+            <member noautovalidity="true"><type>VkClearColorValue</type>      <name>color</name></member>
+            <member><type>VkClearDepthStencilValue</type> <name>depthStencil</name></member>
+        </type>
+        <type category="struct" name="VkClearAttachment">
+            <member><type>VkImageAspectFlags</type>     <name>aspectMask</name></member>
+            <member><type>uint32_t</type>               <name>colorAttachment</name></member>
+            <member noautovalidity="true"><type>VkClearValue</type>           <name>clearValue</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentDescription">
+            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
+            <member><type>VkFormat</type>               <name>format</name></member>
+            <member><type>VkSampleCountFlagBits</type>  <name>samples</name></member>
+            <member><type>VkAttachmentLoadOp</type>     <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>    <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
+            <member><type>VkAttachmentLoadOp</type>     <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>    <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
+            <member><type>VkImageLayout</type>          <name>initialLayout</name></member>
+            <member><type>VkImageLayout</type>          <name>finalLayout</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentReference">
+            <member><type>uint32_t</type>               <name>attachment</name></member>
+            <member><type>VkImageLayout</type>          <name>layout</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDescription">
+            <member optional="true"><type>VkSubpassDescriptionFlags</type> <name>flags</name></member>
+            <member><type>VkPipelineBindPoint</type>    <name>pipelineBindPoint</name><comment>Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now</comment></member>
+            <member optional="true"><type>uint32_t</type>               <name>inputAttachmentCount</name></member>
+            <member len="inputAttachmentCount">const <type>VkAttachmentReference</type>* <name>pInputAttachments</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pColorAttachments</name></member>
+            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference</type>* <name>pResolveAttachments</name></member>
+            <member optional="true">const <type>VkAttachmentReference</type>* <name>pDepthStencilAttachment</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>preserveAttachmentCount</name></member>
+            <member len="preserveAttachmentCount">const <type>uint32_t</type>* <name>pPreserveAttachments</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDependency">
+            <member><type>uint32_t</type>               <name>srcSubpass</name></member>
+            <member><type>uint32_t</type>               <name>dstSubpass</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type>   <name>srcStageMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type>   <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>srcAccessMask</name><comment>Memory accesses from the source of the dependency to synchronize</comment></member>
+            <member optional="true"><type>VkAccessFlags</type>          <name>dstAccessMask</name><comment>Memory accesses from the destination of the dependency to synchronize</comment></member>
+            <member optional="true"><type>VkDependencyFlags</type>      <name>dependencyFlags</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkRenderPassCreateFlags</type> <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>   <name>attachmentCount</name></member>
+            <member len="attachmentCount">const <type>VkAttachmentDescription</type>* <name>pAttachments</name></member>
+            <member><type>uint32_t</type>               <name>subpassCount</name></member>
+            <member len="subpassCount">const <type>VkSubpassDescription</type>* <name>pSubpasses</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>dependencyCount</name></member>
+            <member len="dependencyCount">const <type>VkSubpassDependency</type>* <name>pDependencies</name></member>
+        </type>
+        <type category="struct" name="VkEventCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkEventCreateFlags</type>     <name>flags</name><comment>Event creation flags</comment></member>
+        </type>
+        <type category="struct" name="VkFenceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkFenceCreateFlags</type>     <name>flags</name><comment>Fence creation flags</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFeatures">
+            <member><type>VkBool32</type>               <name>robustBufferAccess</name><comment>out of bounds buffer accesses are well defined</comment></member>
+            <member><type>VkBool32</type>               <name>fullDrawIndexUint32</name><comment>full 32-bit range of indices for indexed draw calls</comment></member>
+            <member><type>VkBool32</type>               <name>imageCubeArray</name><comment>image views which are arrays of cube maps</comment></member>
+            <member><type>VkBool32</type>               <name>independentBlend</name><comment>blending operations are controlled per-attachment</comment></member>
+            <member><type>VkBool32</type>               <name>geometryShader</name><comment>geometry stage</comment></member>
+            <member><type>VkBool32</type>               <name>tessellationShader</name><comment>tessellation control and evaluation stage</comment></member>
+            <member><type>VkBool32</type>               <name>sampleRateShading</name><comment>per-sample shading and interpolation</comment></member>
+            <member><type>VkBool32</type>               <name>dualSrcBlend</name><comment>blend operations which take two sources</comment></member>
+            <member><type>VkBool32</type>               <name>logicOp</name><comment>logic operations</comment></member>
+            <member><type>VkBool32</type>               <name>multiDrawIndirect</name><comment>multi draw indirect</comment></member>
+            <member><type>VkBool32</type>               <name>drawIndirectFirstInstance</name><comment>indirect draws can use non-zero firstInstance</comment></member>
+            <member><type>VkBool32</type>               <name>depthClamp</name><comment>depth clamping</comment></member>
+            <member><type>VkBool32</type>               <name>depthBiasClamp</name><comment>depth bias clamping</comment></member>
+            <member><type>VkBool32</type>               <name>fillModeNonSolid</name><comment>point and wireframe fill modes</comment></member>
+            <member><type>VkBool32</type>               <name>depthBounds</name><comment>depth bounds test</comment></member>
+            <member><type>VkBool32</type>               <name>wideLines</name><comment>lines with width greater than 1</comment></member>
+            <member><type>VkBool32</type>               <name>largePoints</name><comment>points with size greater than 1</comment></member>
+            <member><type>VkBool32</type>               <name>alphaToOne</name><comment>the fragment alpha component can be forced to maximum representable alpha value</comment></member>
+            <member><type>VkBool32</type>               <name>multiViewport</name><comment>viewport arrays</comment></member>
+            <member><type>VkBool32</type>               <name>samplerAnisotropy</name><comment>anisotropic sampler filtering</comment></member>
+            <member><type>VkBool32</type>               <name>textureCompressionETC2</name><comment>ETC texture compression formats</comment></member>
+            <member><type>VkBool32</type>               <name>textureCompressionASTC_LDR</name><comment>ASTC LDR texture compression formats</comment></member>
+            <member><type>VkBool32</type>               <name>textureCompressionBC</name><comment>BC1-7 texture compressed formats</comment></member>
+            <member><type>VkBool32</type>               <name>occlusionQueryPrecise</name><comment>precise occlusion queries returning actual sample counts</comment></member>
+            <member><type>VkBool32</type>               <name>pipelineStatisticsQuery</name><comment>pipeline statistics query</comment></member>
+            <member><type>VkBool32</type>               <name>vertexPipelineStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages</comment></member>
+            <member><type>VkBool32</type>               <name>fragmentStoresAndAtomics</name><comment>stores and atomic ops on storage buffers and images are supported in the fragment stage</comment></member>
+            <member><type>VkBool32</type>               <name>shaderTessellationAndGeometryPointSize</name><comment>tessellation and geometry stages can export point size</comment></member>
+            <member><type>VkBool32</type>               <name>shaderImageGatherExtended</name><comment>image gather with run-time values and independent offsets</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageExtendedFormats</name><comment>the extended set of formats can be used for storage images</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageMultisample</name><comment>multisample images can be used for storage images</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageReadWithoutFormat</name><comment>read from storage image does not require format qualifier</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageWriteWithoutFormat</name><comment>write to storage image does not require format qualifier</comment></member>
+            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayDynamicIndexing</name><comment>arrays of uniform buffers can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderSampledImageArrayDynamicIndexing</name><comment>arrays of sampled images can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayDynamicIndexing</name><comment>arrays of storage buffers can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageArrayDynamicIndexing</name><comment>arrays of storage images can be accessed with dynamically uniform indices</comment></member>
+            <member><type>VkBool32</type>               <name>shaderClipDistance</name><comment>clip distance in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderCullDistance</name><comment>cull distance in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderFloat64</name><comment>64-bit floats (doubles) in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderInt64</name><comment>64-bit integers in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderInt16</name><comment>16-bit integers in shaders</comment></member>
+            <member><type>VkBool32</type>               <name>shaderResourceResidency</name><comment>shader can use texture operations that return resource residency information (requires sparseNonResident support)</comment></member>
+            <member><type>VkBool32</type>               <name>shaderResourceMinLod</name><comment>shader can use texture operations that specify minimum resource LOD</comment></member>
+            <member><type>VkBool32</type>               <name>sparseBinding</name><comment>Sparse resources support: Resource memory can be managed at opaque page level rather than object level</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyBuffer</name><comment>Sparse resources support: GPU can access partially resident buffers </comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyImage2D</name><comment>Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images </comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyImage3D</name><comment>Sparse resources support: GPU can access partially resident 3D images </comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency2Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency4Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency8Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidency16Samples</name><comment>Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples</comment></member>
+            <member><type>VkBool32</type>               <name>sparseResidencyAliased</name><comment>Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)</comment></member>
+            <member><type>VkBool32</type>               <name>variableMultisampleRate</name><comment>multisample rate must be the same for all pipelines in a subpass</comment></member>
+            <member><type>VkBool32</type>               <name>inheritedQueries</name><comment>Queries may be inherited from primary to secondary command buffers</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSparseProperties" returnedonly="true">
+            <member limittype="bitmask"><type>VkBool32</type>               <name>residencyStandard2DBlockShape</name><comment>Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>residencyStandard2DMultisampleBlockShape</name><comment>Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>residencyStandard3DBlockShape</name><comment>Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>residencyAlignedMipSize</name><comment>Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>residencyNonResidentStrict</name><comment>Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceLimits" returnedonly="true">
+                <comment>resource maximum sizes</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension1D</name><comment>max 1D image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension2D</name><comment>max 2D image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimension3D</name><comment>max 3D image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageDimensionCube</name><comment>max cubemap image dimension</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxImageArrayLayers</name><comment>max layers for image arrays</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTexelBufferElements</name><comment>max texel buffer size (fstexels)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxUniformBufferRange</name><comment>max uniform buffer range (bytes)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxStorageBufferRange</name><comment>max storage buffer range (bytes)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPushConstantsSize</name><comment>max size of the push constants pool (bytes)</comment></member>
+                <comment>memory limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxMemoryAllocationCount</name><comment>max number of device memory allocations supported</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxSamplerAllocationCount</name><comment>max number of samplers that can be allocated on a device</comment></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>           <name>bufferImageGranularity</name><comment>Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage</comment></member>
+            <member limittype="max"><type>VkDeviceSize</type>           <name>sparseAddressSpaceSize</name><comment>Total address space available for sparse allocations (bytes)</comment></member>
+                <comment>descriptor set limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxBoundDescriptorSets</name><comment>max number of descriptors sets that can be bound to a pipeline</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorSamplers</name><comment>max number of samplers allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUniformBuffers</name><comment>max number of uniform buffers allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorStorageBuffers</name><comment>max number of storage buffers allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorSampledImages</name><comment>max number of sampled images allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorStorageImages</name><comment>max number of storage images allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorInputAttachments</name><comment>max number of input attachments allowed per-stage in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageResources</name><comment>max number of resources allowed by a single stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetSamplers</name><comment>max number of samplers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffers</name><comment>max number of uniform buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUniformBuffersDynamic</name><comment>max number of dynamic uniform buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffers</name><comment>max number of storage buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageBuffersDynamic</name><comment>max number of dynamic storage buffers allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetSampledImages</name><comment>max number of sampled images allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetStorageImages</name><comment>max number of storage images allowed in all stages in a descriptor set</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetInputAttachments</name><comment>max number of input attachments allowed in all stages in a descriptor set</comment></member>
+                <comment>vertex stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputAttributes</name><comment>max number of vertex input attribute slots</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputBindings</name><comment>max number of vertex input binding slots</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputAttributeOffset</name><comment>max vertex input attribute offset added to vertex buffer offset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexInputBindingStride</name><comment>max vertex input binding stride</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexOutputComponents</name><comment>max number of output components written by vertex shader</comment></member>
+                <comment>tessellation control stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationGenerationLevel</name><comment>max level supported by tessellation primitive generator</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationPatchSize</name><comment>max patch size (vertices)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerVertexInputComponents</name><comment>max number of input components per-vertex in TCS</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerVertexOutputComponents</name><comment>max number of output components per-vertex in TCS</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlPerPatchOutputComponents</name><comment>max number of output components per-patch in TCS</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationControlTotalOutputComponents</name><comment>max total number of per-vertex and per-patch output components in TCS</comment></member>
+                <comment>tessellation evaluation stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationEvaluationInputComponents</name><comment>max number of input components per vertex in TES</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTessellationEvaluationOutputComponents</name><comment>max number of output components per vertex in TES</comment></member>
+                <comment>geometry stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryShaderInvocations</name><comment>max invocation count supported in geometry shader</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryInputComponents</name><comment>max number of input components read in geometry stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryOutputComponents</name><comment>max number of output components written in geometry stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryOutputVertices</name><comment>max number of vertices that can be emitted in geometry stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxGeometryTotalOutputComponents</name><comment>max total number of components (all vertices) written in geometry stage</comment></member>
+                <comment>fragment stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentInputComponents</name><comment>max number of input components read in fragment stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentOutputAttachments</name><comment>max number of output attachments written in fragment stage</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentDualSrcAttachments</name><comment>max number of output attachments written when using dual source blending</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFragmentCombinedOutputResources</name><comment>max total number of storage buffers, storage images and output buffers</comment></member>
+                <comment>compute stage limits</comment>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeSharedMemorySize</name><comment>max total storage size of work group local storage (bytes)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupCount</name>[3]<comment>max num of compute work groups that may be dispatched by a single command (x,y,z)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupInvocations</name><comment>max total compute invocations in a single local work group</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxComputeWorkGroupSize</name>[3]<comment>max local size of a compute work group (x,y,z)</comment></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>subPixelPrecisionBits</name><comment>number bits of subpixel precision in screen x and y</comment></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>subTexelPrecisionBits</name><comment>number bits of precision for selecting texel weights</comment></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>mipmapPrecisionBits</name><comment>number bits of precision for selecting mipmap weights</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDrawIndexedIndexValue</name><comment>max index value for indexed draw calls (for 32-bit indices)</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDrawIndirectCount</name><comment>max draw count for indirect draw calls</comment></member>
+            <member limittype="max"><type>float</type>                  <name>maxSamplerLodBias</name><comment>max absolute sampler LOD bias</comment></member>
+            <member limittype="max"><type>float</type>                  <name>maxSamplerAnisotropy</name><comment>max degree of sampler anisotropy</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxViewports</name><comment>max number of active viewports</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxViewportDimensions</name>[2]<comment>max viewport dimensions (x,y)</comment></member>
+            <member limittype="range"><type>float</type>                  <name>viewportBoundsRange</name>[2]<comment>viewport bounds range (min,max)</comment></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>viewportSubPixelBits</name><comment>number bits of subpixel precision for viewport</comment></member>
+            <member limittype="noauto"><type>size_t</type>                 <name>minMemoryMapAlignment</name><comment>min required alignment of pointers returned by MapMemory (bytes)</comment></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>           <name>minTexelBufferOffsetAlignment</name><comment>min required alignment for texel buffer offsets (bytes) </comment></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>           <name>minUniformBufferOffsetAlignment</name><comment>min required alignment for uniform buffer sizes and offsets (bytes)</comment></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>           <name>minStorageBufferOffsetAlignment</name><comment>min required alignment for storage buffer offsets (bytes)</comment></member>
+            <member limittype="min"><type>int32_t</type>                <name>minTexelOffset</name><comment>min texel offset for OpTextureSampleOffset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTexelOffset</name><comment>max texel offset for OpTextureSampleOffset</comment></member>
+            <member limittype="min"><type>int32_t</type>                <name>minTexelGatherOffset</name><comment>min texel offset for OpTextureGatherOffset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTexelGatherOffset</name><comment>max texel offset for OpTextureGatherOffset</comment></member>
+            <member limittype="min"><type>float</type>                  <name>minInterpolationOffset</name><comment>furthest negative offset for interpolateAtOffset</comment></member>
+            <member limittype="max"><type>float</type>                  <name>maxInterpolationOffset</name><comment>furthest positive offset for interpolateAtOffset</comment></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>subPixelInterpolationOffsetBits</name><comment>number of subpixel bits for interpolateAtOffset</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferWidth</name><comment>max width for a framebuffer</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferHeight</name><comment>max height for a framebuffer</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxFramebufferLayers</name><comment>max layer count for a layered framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferColorSampleCounts</name><comment>supported color sample counts for a framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferDepthSampleCounts</name><comment>supported depth sample counts for a framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferStencilSampleCounts</name><comment>supported stencil sample counts for a framebuffer</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>framebufferNoAttachmentsSampleCounts</name><comment>supported sample counts for a subpass which uses no attachments</comment></member>
+            <member limittype="bitmask"><type>uint32_t</type>               <name>maxColorAttachments</name><comment>max number of color attachments per subpass</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageColorSampleCounts</name><comment>supported color sample counts for a non-integer sampled image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageIntegerSampleCounts</name><comment>supported sample counts for an integer image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageDepthSampleCounts</name><comment>supported depth sample counts for a sampled image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>sampledImageStencilSampleCounts</name><comment>supported stencil sample counts for a sampled image</comment></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type>     <name>storageImageSampleCounts</name><comment>supported sample counts for a storage image</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxSampleMaskWords</name><comment>max number of sample mask words</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>timestampComputeAndGraphics</name><comment>timestamps on graphics and compute queues</comment></member>
+            <member limittype="noauto"><type>float</type>                  <name>timestampPeriod</name><comment>number of nanoseconds it takes for timestamp query value to increment by 1</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxClipDistances</name><comment>max number of clip distances</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxCullDistances</name><comment>max number of cull distances</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxCombinedClipAndCullDistances</name><comment>max combined number of user clipping</comment></member>
+            <member limittype="max"><type>uint32_t</type>               <name>discreteQueuePriorities</name><comment>distinct queue priorities available </comment></member>
+            <member limittype="range"><type>float</type>                  <name>pointSizeRange</name>[2]<comment>range (min,max) of supported point sizes</comment></member>
+            <member limittype="range"><type>float</type>                  <name>lineWidthRange</name>[2]<comment>range (min,max) of supported line widths</comment></member>
+            <member limittype="max"><type>float</type>                  <name>pointSizeGranularity</name><comment>granularity of supported point sizes</comment></member>
+            <member limittype="max"><type>float</type>                  <name>lineWidthGranularity</name><comment>granularity of supported line widths</comment></member>
+            <member limittype="noauto"><type>VkBool32</type>               <name>strictLines</name><comment>line rasterization follows preferred rules</comment></member>
+            <member limittype="noauto"><type>VkBool32</type>               <name>standardSampleLocations</name><comment>supports standard sample locations for all supported sample counts</comment></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>           <name>optimalBufferCopyOffsetAlignment</name><comment>optimal offset of buffer copies</comment></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>           <name>optimalBufferCopyRowPitchAlignment</name><comment>optimal pitch of buffer copies</comment></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>           <name>nonCoherentAtomSize</name><comment>minimum size and alignment for non-coherent host-mapped device memory access</comment></member>
+        </type>
+        <type category="struct" name="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkSemaphoreCreateFlags</type> <name>flags</name><comment>Semaphore creation flags</comment></member>
+        </type>
+        <type category="struct" name="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkQueryPoolCreateFlags</type> <name>flags</name></member>
+            <member><type>VkQueryType</type>            <name>queryType</name></member>
+            <member><type>uint32_t</type>               <name>queryCount</name></member>
+            <member optional="true" noautovalidity="true"><type>VkQueryPipelineStatisticFlags</type> <name>pipelineStatistics</name><comment>Optional</comment></member>
+        </type>
+        <type category="struct" name="VkFramebufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkFramebufferCreateFlags</type>    <name>flags</name></member>
+            <member><type>VkRenderPass</type>                           <name>renderPass</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name></member>
+            <member noautovalidity="true" len="attachmentCount">const <type>VkImageView</type>*     <name>pAttachments</name></member>
+            <member><type>uint32_t</type>               <name>width</name></member>
+            <member><type>uint32_t</type>               <name>height</name></member>
+            <member><type>uint32_t</type>               <name>layers</name></member>
+        </type>
+        <type category="struct" name="VkDrawIndirectCommand">
+            <member><type>uint32_t</type>                       <name>vertexCount</name></member>
+            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
+            <member><type>uint32_t</type>                       <name>firstVertex</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
+        </type>
+        <type category="struct" name="VkDrawIndexedIndirectCommand">
+            <member><type>uint32_t</type>                       <name>indexCount</name></member>
+            <member><type>uint32_t</type>                       <name>instanceCount</name></member>
+            <member><type>uint32_t</type>                       <name>firstIndex</name></member>
+            <member><type>int32_t</type>                        <name>vertexOffset</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>firstInstance</name></member>
+        </type>
+        <type category="struct" name="VkDispatchIndirectCommand">
+            <member noautovalidity="true"><type>uint32_t</type> <name>x</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>y</name></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>z</name></member>
+        </type>
+        <type category="struct" name="VkMultiDrawInfoEXT">
+            <member><type>uint32_t</type> <name>firstVertex</name></member>
+            <member><type>uint32_t</type> <name>vertexCount</name></member>
+        </type>
+        <type category="struct" name="VkMultiDrawIndexedInfoEXT">
+            <member><type>uint32_t</type> <name>firstIndex</name></member>
+            <member><type>uint32_t</type> <name>indexCount</name></member>
+            <member><type>int32_t</type> <name>vertexOffset</name></member>
+        </type>
+        <type category="struct" name="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>waitSemaphoreCount</name></member>
+            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>*     <name>pWaitSemaphores</name></member>
+            <member len="waitSemaphoreCount">const <type>VkPipelineStageFlags</type>*           <name>pWaitDstStageMask</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>commandBufferCount</name></member>
+            <member len="commandBufferCount">const <type>VkCommandBuffer</type>*     <name>pCommandBuffers</name></member>
+            <member optional="true"><type>uint32_t</type>       <name>signalSemaphoreCount</name></member>
+            <member len="signalSemaphoreCount">const <type>VkSemaphore</type>*     <name>pSignalSemaphores</name></member>
+        </type>
+            <comment>WSI extensions</comment>
+        <type category="struct" name="VkDisplayPropertiesKHR" returnedonly="true">
+            <member><type>VkDisplayKHR</type>                     <name>display</name><comment>Handle of the display object</comment></member>
+            <member len="null-terminated">const <type>char</type>*                      <name>displayName</name><comment>Name of the display</comment></member>
+            <member><type>VkExtent2D</type>                       <name>physicalDimensions</name><comment>In millimeters?</comment></member>
+            <member><type>VkExtent2D</type>                       <name>physicalResolution</name><comment>Max resolution for CRT?</comment></member>
+            <member optional="true"><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>one or more bits from VkSurfaceTransformFlagsKHR</comment></member>
+            <member><type>VkBool32</type>                         <name>planeReorderPossible</name><comment>VK_TRUE if the overlay plane's z-order can be changed on this display.</comment></member>
+            <member><type>VkBool32</type>                         <name>persistentContent</name><comment>VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayPlanePropertiesKHR" returnedonly="true">
+            <member><type>VkDisplayKHR</type>                     <name>currentDisplay</name><comment>Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.</comment></member>
+            <member><type>uint32_t</type>                         <name>currentStackIndex</name><comment>Current z-order of the plane.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayModeParametersKHR">
+            <member><type>VkExtent2D</type>                       <name>visibleRegion</name><comment>Visible scanout region.</comment></member>
+            <member noautovalidity="true"><type>uint32_t</type>   <name>refreshRate</name><comment>Number of times per second the display is updated.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayModePropertiesKHR" returnedonly="true">
+            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>Handle of this display mode.</comment></member>
+            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayModeCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDisplayModeCreateFlagsKHR</type>      <name>flags</name></member>
+            <member><type>VkDisplayModeParametersKHR</type>       <name>parameters</name><comment>The parameters this mode uses.</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneCapabilitiesKHR" returnedonly="true">
+            <member optional="true"><type>VkDisplayPlaneAlphaFlagsKHR</type>      <name>supportedAlpha</name><comment>Types of alpha blending supported, if any.</comment></member>
+            <member><type>VkOffset2D</type>                       <name>minSrcPosition</name><comment>Does the plane have any position and extent restrictions?</comment></member>
+            <member><type>VkOffset2D</type>                       <name>maxSrcPosition</name></member>
+            <member><type>VkExtent2D</type>                       <name>minSrcExtent</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxSrcExtent</name></member>
+            <member><type>VkOffset2D</type>                       <name>minDstPosition</name></member>
+            <member><type>VkOffset2D</type>                       <name>maxDstPosition</name></member>
+            <member><type>VkExtent2D</type>                       <name>minDstExtent</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxDstExtent</name></member>
+        </type>
+        <type category="struct" name="VkDisplaySurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDisplaySurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member><type>VkDisplayModeKHR</type>                 <name>displayMode</name><comment>The mode to use when displaying this surface</comment></member>
+            <member><type>uint32_t</type>                         <name>planeIndex</name><comment>The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.</comment></member>
+            <member><type>uint32_t</type>                         <name>planeStackIndex</name><comment>The z-order of the plane.</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>transform</name><comment>Transform to apply to the images as part of the scanout operation</comment></member>
+            <member><type>float</type>                            <name>globalAlpha</name><comment>Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR</comment></member>
+            <member><type>VkDisplayPlaneAlphaFlagBitsKHR</type>   <name>alphaMode</name><comment>What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.</comment></member>
+            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>size of the images to use with this surface</comment></member>
+        </type>
+        <type category="struct" name="VkDisplayPresentInfoKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkRect2D</type>                         <name>srcRect</name><comment>Rectangle within the presentable image to read pixel data from when presenting to the display.</comment></member>
+            <member><type>VkRect2D</type>                         <name>dstRect</name><comment>Rectangle within the current display mode's visible region to display srcRectangle in.</comment></member>
+            <member><type>VkBool32</type>                         <name>persistent</name><comment>For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.</comment></member>
+        </type>
+        <type category="struct" name="VkSurfaceCapabilitiesKHR" returnedonly="true">
+            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
+            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
+            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
+            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
+            <member><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
+            <member><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
+            <member><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
+        </type>
+        <type category="struct" name="VkAndroidSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkAndroidSurfaceCreateFlagsKHR</type> <name>flags</name></member>
+            <member noautovalidity="true">struct <type>ANativeWindow</type>*    <name>window</name></member>
+        </type>
+        <type category="struct" name="VkViSurfaceCreateInfoNN">
+            <member values="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkViSurfaceCreateFlagsNN</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>void</type>*                            <name>window</name></member>
+        </type>
+        <type category="struct" name="VkWaylandSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkWaylandSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member noautovalidity="true">struct <type>wl_display</type>*               <name>display</name></member>
+            <member noautovalidity="true">struct <type>wl_surface</type>*               <name>surface</name></member>
+        </type>
+        <type category="struct" name="VkWin32SurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkWin32SurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member><type>HINSTANCE</type>                        <name>hinstance</name></member>
+            <member><type>HWND</type>                             <name>hwnd</name></member>
+        </type>
+        <type category="struct" name="VkXlibSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkXlibSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>Display</type>*                         <name>dpy</name></member>
+            <member><type>Window</type>                           <name>window</name></member>
+        </type>
+        <type category="struct" name="VkXcbSurfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkXcbSurfaceCreateFlagsKHR</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>xcb_connection_t</type>*                <name>connection</name></member>
+            <member><type>xcb_window_t</type>                     <name>window</name></member>
+        </type>
+        <type category="struct" name="VkDirectFBSurfaceCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDirectFBSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
+            <member noautovalidity="true"><type>IDirectFB</type>*                       <name>dfb</name></member>
+            <member noautovalidity="true"><type>IDirectFBSurface</type>*                <name>surface</name></member>
+        </type>
+        <type category="struct" name="VkImagePipeSurfaceCreateInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkImagePipeSurfaceCreateFlagsFUCHSIA</type>   <name>flags</name></member>
+            <member><type>zx_handle_t</type>                      <name>imagePipeHandle</name></member>
+        </type>
+        <type category="struct" name="VkStreamDescriptorSurfaceCreateInfoGGP">
+            <member values="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkStreamDescriptorSurfaceCreateFlagsGGP</type> <name>flags</name></member>
+            <member><type>GgpStreamDescriptor</type>              <name>streamDescriptor</name></member>
+        </type>
+        <type category="struct" name="VkScreenSurfaceCreateInfoQNX">
+            <member values="VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkScreenSurfaceCreateFlagsQNX</type>    <name>flags</name></member>
+            <member noautovalidity="true">struct <type>_screen_context</type>*    <name>context</name></member>
+            <member noautovalidity="true">struct <type>_screen_window</type>*     <name>window</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceFormatKHR" returnedonly="true">
+            <member><type>VkFormat</type>                         <name>format</name><comment>Supported pair of rendering format</comment></member>
+            <member><type>VkColorSpaceKHR</type>                  <name>colorSpace</name><comment>and color space for the surface</comment></member>
+        </type>
+        <type category="struct" name="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkSwapchainCreateFlagsKHR</type>        <name>flags</name></member>
+            <member><type>VkSurfaceKHR</type>                     <name>surface</name><comment>The swapchain's target surface</comment></member>
+            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Minimum number of presentation images the application needs</comment></member>
+            <member><type>VkFormat</type>                         <name>imageFormat</name><comment>Format of the presentation images</comment></member>
+            <member><type>VkColorSpaceKHR</type>                  <name>imageColorSpace</name><comment>Colorspace of the presentation images</comment></member>
+            <member><type>VkExtent2D</type>                       <name>imageExtent</name><comment>Dimensions of the presentation images</comment></member>
+            <member><type>uint32_t</type>                         <name>imageArrayLayers</name><comment>Determines the number of views for multiview/stereo presentation</comment></member>
+            <member><type>VkImageUsageFlags</type>                <name>imageUsage</name><comment>Bits indicating how the presentation images will be used</comment></member>
+            <member><type>VkSharingMode</type>                    <name>imageSharingMode</name><comment>Sharing mode used for the presentation images</comment></member>
+            <member optional="true"><type>uint32_t</type>         <name>queueFamilyIndexCount</name><comment>Number of queue families having access to the images in case of concurrent sharing mode</comment></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>*                  <name>pQueueFamilyIndices</name><comment>Array of queue family indices having access to the images in case of concurrent sharing mode</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>preTransform</name><comment>The transform, relative to the device's natural orientation, applied to the image content prior to presentation</comment></member>
+            <member><type>VkCompositeAlphaFlagBitsKHR</type>      <name>compositeAlpha</name><comment>The alpha blending mode used when compositing this surface with other surfaces in the window system</comment></member>
+            <member><type>VkPresentModeKHR</type>                 <name>presentMode</name><comment>Which presentation mode to use for presents on this swap chain</comment></member>
+            <member><type>VkBool32</type>                         <name>clipped</name><comment>Specifies whether presentable images may be affected by window clip regions</comment></member>
+            <member optional="true"><type>VkSwapchainKHR</type>   <name>oldSwapchain</name><comment>Existing swap chain to replace, if any</comment></member>
+        </type>
+        <type category="struct" name="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name><comment>Number of semaphores to wait for before presenting</comment></member>
+            <member len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name><comment>Semaphores to wait for before presenting</comment></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Number of swapchains to present in this call</comment></member>
+            <member len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name><comment>Swapchains to present an image from</comment></member>
+            <member len="swapchainCount">const <type>uint32_t</type>* <name>pImageIndices</name><comment>Indices of which presentable images to present</comment></member>
+            <member optional="true" len="swapchainCount"><type>VkResult</type>* <name>pResults</name><comment>Optional (i.e. if non-NULL) VkResult for each swapchain</comment></member>
+        </type>
+        <type category="struct" name="VkDebugReportCallbackCreateInfoEXT" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkDebugReportFlagsEXT</type>            <name>flags</name><comment>Indicates which events call this callback</comment></member>
+            <member><type>PFN_vkDebugReportCallbackEXT</type>     <name>pfnCallback</name><comment>Function pointer of a callback function</comment></member>
+            <member optional="true"><type>void</type>*            <name>pUserData</name><comment>User data provided to callback function</comment></member>
+        </type>
+        <type category="struct" name="VkValidationFlagsEXT" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"><type>VkStructureType</type>                  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT</comment></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>disabledValidationCheckCount</name><comment>Number of validation checks to disable</comment></member>
+            <member len="disabledValidationCheckCount">const <type>VkValidationCheckEXT</type>* <name>pDisabledValidationChecks</name><comment>Validation checks to disable</comment></member>
+        </type>
+        <type category="struct" name="VkValidationFeaturesEXT" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"><type>VkStructureType</type>  <name>sType</name><comment>Must be VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT</comment></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>enabledValidationFeatureCount</name><comment>Number of validation features to enable</comment></member>
+            <member len="enabledValidationFeatureCount">const <type>VkValidationFeatureEnableEXT</type>* <name>pEnabledValidationFeatures</name><comment>Validation features to enable</comment></member>
+            <member optional="true"><type>uint32_t</type>                         <name>disabledValidationFeatureCount</name><comment>Number of validation features to disable</comment></member>
+            <member len="disabledValidationFeatureCount">const <type>VkValidationFeatureDisableEXT</type>* <name>pDisabledValidationFeatures</name><comment>Validation features to disable</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationStateRasterizationOrderAMD" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkRasterizationOrderAMD</type>          <name>rasterizationOrder</name><comment>Rasterization order to use for the pipeline</comment></member>
+        </type>
+        <type category="struct" name="VkDebugMarkerObjectNameInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
+            <member objecttype="objectType"><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
+            <member len="null-terminated">const <type>char</type>* <name>pObjectName</name><comment>Name to apply to the object</comment></member>
+        </type>
+        <type category="struct" name="VkDebugMarkerObjectTagInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDebugReportObjectTypeEXT</type>       <name>objectType</name><comment>The type of the object</comment></member>
+            <member  objecttype="objectType"><type>uint64_t</type>                         <name>object</name><comment>The handle of the object, cast to uint64_t</comment></member>
+            <member><type>uint64_t</type>                         <name>tagName</name><comment>The name of the tag to set on the object</comment></member>
+            <member><type>size_t</type>                           <name>tagSize</name><comment>The length in bytes of the tag data</comment></member>
+            <member len="tagSize">const <type>void</type>*        <name>pTag</name><comment>Tag data to attach to the object</comment></member>
+        </type>
+        <type category="struct" name="VkDebugMarkerMarkerInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member len="null-terminated">const <type>char</type>* <name>pMarkerName</name><comment>Name of the debug marker</comment></member>
+            <member><type>float</type>            <name>color</name>[4]<comment>Optional color for debug marker</comment></member>
+        </type>
+        <type category="struct" name="VkDedicatedAllocationImageCreateInfoNV" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this image uses a dedicated allocation</comment></member>
+        </type>
+        <type category="struct" name="VkDedicatedAllocationBufferCreateInfoNV" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>dedicatedAllocation</name><comment>Whether this buffer uses a dedicated allocation</comment></member>
+        </type>
+        <type category="struct" name="VkDedicatedAllocationMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
+            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
+        </type>
+        <type category="struct" name="VkExternalImageFormatPropertiesNV" returnedonly="true">
+            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
+            <member optional="true"><type>VkExternalMemoryFeatureFlagsNV</type>   <name>externalMemoryFeatures</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>exportFromImportedHandleTypes</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>compatibleHandleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryImageCreateInfoNV" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryAllocateInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>                           <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryWin32HandleInfoNV" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
+            <member optional="true"><type>DWORD</type>                            <name>dwAccess</name></member>
+        </type>
+        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoNV" structextends="VkSubmitInfo,VkSubmitInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>acquireCount</name></member>
+            <member len="acquireCount">const <type>VkDeviceMemory</type>*            <name>pAcquireSyncs</name></member>
+            <member len="acquireCount">const <type>uint64_t</type>*                  <name>pAcquireKeys</name></member>
+            <member len="acquireCount">const <type>uint32_t</type>*                  <name>pAcquireTimeoutMilliseconds</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>releaseCount</name></member>
+            <member len="releaseCount">const <type>VkDeviceMemory</type>*            <name>pReleaseSyncs</name></member>
+            <member len="releaseCount">const <type>uint64_t</type>*                  <name>pReleaseKeys</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>deviceGeneratedCommands</name></member>
+        </type>
+        <type category="struct" name="VkDevicePrivateDataCreateInfoEXT" allowduplicate="true" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                               <name>privateDataSlotRequestCount</name></member>
+        </type>
+        <type category="struct" name="VkPrivateDataSlotCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkPrivateDataSlotCreateFlagsEXT</type>        <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePrivateDataFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                  <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>privateData</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxGraphicsShaderGroupCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectSequenceCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsTokenCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsStreamCount</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsTokenOffset</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxIndirectCommandsStreamStride</name></member>
+            <member limittype="noauto"><type>uint32_t</type>         <name>minSequencesCountBufferOffsetAlignment</name></member>
+            <member limittype="noauto"><type>uint32_t</type>         <name>minSequencesIndexBufferOffsetAlignment</name></member>
+            <member limittype="noauto"><type>uint32_t</type>         <name>minIndirectCommandsBufferOffsetAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiDrawPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>         <name>maxMultiDrawCount</name></member>
+        </type>
+        <type category="struct" name="VkGraphicsShaderGroupCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                   <name>stageCount</name></member>
+            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>*    <name>pStages</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineVertexInputStateCreateInfo</type>*                <name>pVertexInputState</name></member>
+            <member noautovalidity="true" optional="true">const <type>VkPipelineTessellationStateCreateInfo</type>*               <name>pTessellationState</name></member>
+        </type>
+        <type category="struct" name="VkGraphicsPipelineShaderGroupsCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                   <name>groupCount</name></member>
+            <member len="groupCount">const <type>VkGraphicsShaderGroupCreateInfoNV</type>*  <name>pGroups</name></member>
+            <member optional="true"><type>uint32_t</type>                                   <name>pipelineCount</name></member>
+            <member len="pipelineCount">const <type>VkPipeline</type>*                      <name>pPipelines</name></member>
+        </type>
+        <type category="struct" name="VkBindShaderGroupIndirectCommandNV">
+            <member><type>uint32_t</type>         <name>groupIndex</name></member>
+        </type>
+        <type category="struct" name="VkBindIndexBufferIndirectCommandNV">
+            <member><type>VkDeviceAddress</type>  <name>bufferAddress</name></member>
+            <member><type>uint32_t</type>         <name>size</name></member>
+            <member><type>VkIndexType</type>      <name>indexType</name></member>
+        </type>
+        <type category="struct" name="VkBindVertexBufferIndirectCommandNV">
+            <member><type>VkDeviceAddress</type>  <name>bufferAddress</name></member>
+            <member><type>uint32_t</type>         <name>size</name></member>
+            <member><type>uint32_t</type>         <name>stride</name></member>
+        </type>
+        <type category="struct" name="VkSetStateFlagsIndirectCommandNV">
+            <member><type>uint32_t</type>          <name>data</name></member>
+        </type>
+        <type category="struct" name="VkIndirectCommandsStreamNV">
+            <member><type>VkBuffer</type>      <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>  <name>offset</name></member>
+        </type>
+        <type category="struct" name="VkIndirectCommandsLayoutTokenNV">
+            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>VkIndirectCommandsTokenTypeNV</type>  <name>tokenType</name></member>
+            <member><type>uint32_t</type>                       <name>stream</name></member>
+            <member><type>uint32_t</type>                       <name>offset</name></member>
+            <member><type>uint32_t</type>                                <name>vertexBindingUnit</name></member>
+            <member><type>VkBool32</type>                                <name>vertexDynamicStride</name></member>
+            <member optional="true"><type>VkPipelineLayout</type>        <name>pushconstantPipelineLayout</name></member>
+            <member optional="true"><type>VkShaderStageFlags</type>      <name>pushconstantShaderStageFlags</name></member>
+            <member><type>uint32_t</type>                                <name>pushconstantOffset</name></member>
+            <member><type>uint32_t</type>                                <name>pushconstantSize</name></member>
+            <member optional="true"><type>VkIndirectStateFlagsNV</type>  <name>indirectStateFlags</name></member>
+            <member optional="true"><type>uint32_t</type>                <name>indexTypeCount</name></member>
+            <member len="indexTypeCount">const <type>VkIndexType</type>* <name>pIndexTypes</name></member>
+            <member len="indexTypeCount">const <type>uint32_t</type>*    <name>pIndexTypeValues</name></member>
+        </type>
+        <type category="struct" name="VkIndirectCommandsLayoutCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member optional="true"><type>VkIndirectCommandsLayoutUsageFlagsNV</type>    <name>flags</name></member>
+            <member><type>VkPipelineBindPoint</type>                     <name>pipelineBindPoint</name></member>
+            <member><type>uint32_t</type>                                <name>tokenCount</name></member>
+            <member len="tokenCount">const <type>VkIndirectCommandsLayoutTokenNV</type>*  <name>pTokens</name></member>
+            <member><type>uint32_t</type>                                <name>streamCount</name></member>
+            <member len="streamCount">const <type>uint32_t</type>*       <name>pStreamStrides</name></member>
+        </type>
+        <type category="struct" name="VkGeneratedCommandsInfoNV">
+            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkPipelineBindPoint</type>                <name>pipelineBindPoint</name></member>
+            <member><type>VkPipeline</type>                         <name>pipeline</name></member>
+            <member><type>VkIndirectCommandsLayoutNV</type>         <name>indirectCommandsLayout</name></member>
+            <member><type>uint32_t</type>                           <name>streamCount</name></member>
+            <member len="streamCount">const <type>VkIndirectCommandsStreamNV</type>*  <name>pStreams</name></member>
+            <member><type>uint32_t</type>                           <name>sequencesCount</name></member>
+            <member><type>VkBuffer</type>                           <name>preprocessBuffer</name></member>
+            <member><type>VkDeviceSize</type>                       <name>preprocessOffset</name></member>
+            <member><type>VkDeviceSize</type>                       <name>preprocessSize</name></member>
+            <member optional="true"><type>VkBuffer</type>           <name>sequencesCountBuffer</name></member>
+            <member><type>VkDeviceSize</type>                       <name>sequencesCountOffset</name></member>
+            <member optional="true"><type>VkBuffer</type>           <name>sequencesIndexBuffer</name></member>
+            <member><type>VkDeviceSize</type>                       <name>sequencesIndexOffset</name></member>
+        </type>
+        <type category="struct" name="VkGeneratedCommandsMemoryRequirementsInfoNV">
+            <member values="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                 <name>pNext</name></member>
+            <member><type>VkPipelineBindPoint</type>         <name>pipelineBindPoint</name></member>
+            <member><type>VkPipeline</type>                  <name>pipeline</name></member>
+            <member><type>VkIndirectCommandsLayoutNV</type>  <name>indirectCommandsLayout</name></member>
+            <member><type>uint32_t</type>                    <name>maxSequencesCount</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFeatures2" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkPhysicalDeviceFeatures</type>         <name>features</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFeatures2KHR"                            alias="VkPhysicalDeviceFeatures2"/>
+        <type category="struct" name="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="struct"><type>VkPhysicalDeviceProperties</type>       <name>properties</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProperties2KHR"                          alias="VkPhysicalDeviceProperties2"/>
+        <type category="struct" name="VkFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFormatProperties</type>               <name>formatProperties</name></member>
+        </type>
+        <type category="struct" name="VkFormatProperties2KHR"                                  alias="VkFormatProperties2"/>
+        <type category="struct" name="VkImageFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkImageFormatProperties</type>          <name>imageFormatProperties</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatProperties2KHR"                             alias="VkImageFormatProperties2"/>
+        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>format</name></member>
+            <member><type>VkImageType</type>                      <name>type</name></member>
+            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
+            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
+            <member optional="true"><type>VkImageCreateFlags</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageFormatInfo2KHR"                     alias="VkPhysicalDeviceImageFormatInfo2"/>
+        <type category="struct" name="VkQueueFamilyProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkQueueFamilyProperties</type>          <name>queueFamilyProperties</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyProperties2KHR"                             alias="VkQueueFamilyProperties2"/>
+        <type category="struct" name="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkPhysicalDeviceMemoryProperties</type> <name>memoryProperties</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryProperties2KHR"                    alias="VkPhysicalDeviceMemoryProperties2"/>
+        <type category="struct" name="VkSparseImageFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkSparseImageFormatProperties</type>    <name>properties</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageFormatProperties2KHR"                       alias="VkSparseImageFormatProperties2"/>
+        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>format</name></member>
+            <member><type>VkImageType</type>                      <name>type</name></member>
+            <member><type>VkSampleCountFlagBits</type>            <name>samples</name></member>
+            <member><type>VkImageUsageFlags</type>                <name>usage</name></member>
+            <member><type>VkImageTiling</type>                    <name>tiling</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSparseImageFormatInfo2KHR"               alias="VkPhysicalDeviceSparseImageFormatInfo2"/>
+        <type category="struct" name="VkPhysicalDevicePushDescriptorPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPushDescriptors</name></member>
+        </type>
+        <type category="struct" name="VkConformanceVersion">
+            <member><type>uint8_t</type>                          <name>major</name></member>
+            <member><type>uint8_t</type>                          <name>minor</name></member>
+            <member><type>uint8_t</type>                          <name>subminor</name></member>
+            <member><type>uint8_t</type>                          <name>patch</name></member>
+        </type>
+        <type category="struct" name="VkConformanceVersionKHR"                                 alias="VkConformanceVersion"/>
+        <type category="struct" name="VkPhysicalDeviceDriverProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="noauto"><type>VkDriverId</type>                       <name>driverID</name></member>
+            <member limittype="noauto"><type>char</type>                             <name>driverName</name>[<enum>VK_MAX_DRIVER_NAME_SIZE</enum>]</member>
+            <member limittype="noauto"><type>char</type>                             <name>driverInfo</name>[<enum>VK_MAX_DRIVER_INFO_SIZE</enum>]</member>
+            <member limittype="noauto"><type>VkConformanceVersion</type>             <name>conformanceVersion</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDriverPropertiesKHR"                     alias="VkPhysicalDeviceDriverProperties"/>
+        <type category="struct" name="VkPresentRegionsKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount" optional="true">const <type>VkPresentRegionKHR</type>*   <name>pRegions</name><comment>The regions that have changed</comment></member>
+        </type>
+        <type category="struct" name="VkPresentRegionKHR">
+            <member optional="true"><type>uint32_t</type>         <name>rectangleCount</name><comment>Number of rectangles in pRectangles</comment></member>
+            <member optional="true" len="rectangleCount">const <type>VkRectLayerKHR</type>*   <name>pRectangles</name><comment>Array of rectangles that have changed in a swapchain's image(s)</comment></member>
+        </type>
+        <type category="struct" name="VkRectLayerKHR">
+            <member><type>VkOffset2D</type>                       <name>offset</name><comment>upper-left corner of a rectangle that has not changed, in pixels of a presentation images</comment></member>
+            <member noautovalidity="true"><type>VkExtent2D</type> <name>extent</name><comment>Dimensions of a rectangle that has not changed, in pixels of a presentation images</comment></member>
+            <member><type>uint32_t</type>                         <name>layer</name><comment>Layer of a swapchain's image(s), for stereoscopic-3D images</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVariablePointersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>variablePointersStorageBuffer</name></member>
+            <member><type>VkBool32</type>                         <name>variablePointers</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVariablePointersFeaturesKHR"             alias="VkPhysicalDeviceVariablePointersFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceVariablePointerFeaturesKHR"              alias="VkPhysicalDeviceVariablePointersFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceVariablePointerFeatures"                 alias="VkPhysicalDeviceVariablePointersFeatures"/>
+        <type category="struct" name="VkExternalMemoryProperties" returnedonly="true">
+            <member><type>VkExternalMemoryFeatureFlags</type>  <name>externalMemoryFeatures</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryPropertiesKHR"                           alias="VkExternalMemoryProperties"/>
+        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfo"  structextends="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalImageFormatInfoKHR"              alias="VkPhysicalDeviceExternalImageFormatInfo"/>
+        <type category="struct" name="VkExternalImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalMemoryProperties</type> <name>externalMemoryProperties</name></member>
+        </type>
+        <type category="struct" name="VkExternalImageFormatPropertiesKHR"                      alias="VkExternalImageFormatProperties"/>
+        <type category="struct" name="VkPhysicalDeviceExternalBufferInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkBufferCreateFlags</type> <name>flags</name></member>
+            <member><type>VkBufferUsageFlags</type>               <name>usage</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalBufferInfoKHR"                   alias="VkPhysicalDeviceExternalBufferInfo"/>
+        <type category="struct" name="VkExternalBufferProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalMemoryProperties</type>    <name>externalMemoryProperties</name></member>
+        </type>
+        <type category="struct" name="VkExternalBufferPropertiesKHR"                           alias="VkExternalBufferProperties"/>
+        <type category="struct" name="VkPhysicalDeviceIDProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="noauto"><type>uint8_t</type>                          <name>deviceUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>                          <name>driverUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>                          <name>deviceLUID</name>[<enum>VK_LUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>deviceNodeMask</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>deviceLUIDValid</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceIDPropertiesKHR"                         alias="VkPhysicalDeviceIDProperties"/>
+        <type category="struct" name="VkExternalMemoryImageCreateInfo" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryImageCreateInfoKHR"                      alias="VkExternalMemoryImageCreateInfo"/>
+        <type category="struct" name="VkExternalMemoryBufferCreateInfo" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExternalMemoryBufferCreateInfoKHR"                     alias="VkExternalMemoryBufferCreateInfo"/>
+        <type category="struct" name="VkExportMemoryAllocateInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryAllocateInfoKHR"                           alias="VkExportMemoryAllocateInfo"/>
+        <type category="struct" name="VkImportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
+            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkExportMemoryWin32HandleInfoKHR" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
+            <member><type>DWORD</type>                            <name>dwAccess</name></member>
+            <member><type>LPCWSTR</type>                          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryZirconHandleInfoFUCHSIA" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="true"><type>zx_handle_t</type>           <name>handle</name></member>
+        </type>
+        <type category="struct" name="VkMemoryZirconHandlePropertiesFUCHSIA" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetZirconHandleInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkMemoryWin32HandlePropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryFdInfoKHR" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member><type>int</type>                              <name>fd</name></member>
+        </type>
+        <type category="struct" name="VkMemoryFdPropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkWin32KeyedMutexAcquireReleaseInfoKHR" structextends="VkSubmitInfo,VkSubmitInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>acquireCount</name></member>
+            <member len="acquireCount">const <type>VkDeviceMemory</type>* <name>pAcquireSyncs</name></member>
+            <member len="acquireCount">const <type>uint64_t</type>* <name>pAcquireKeys</name></member>
+            <member len="acquireCount">const <type>uint32_t</type>* <name>pAcquireTimeouts</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>releaseCount</name></member>
+            <member len="releaseCount">const <type>VkDeviceMemory</type>* <name>pReleaseSyncs</name></member>
+            <member len="releaseCount">const <type>uint64_t</type>* <name>pReleaseKeys</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalSemaphoreInfoKHR"                alias="VkPhysicalDeviceExternalSemaphoreInfo"/>
+        <type category="struct" name="VkExternalSemaphoreProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
+            <member optional="true"><type>VkExternalSemaphoreFeatureFlags</type> <name>externalSemaphoreFeatures</name></member>
+        </type>
+        <type category="struct" name="VkExternalSemaphorePropertiesKHR"                        alias="VkExternalSemaphoreProperties"/>
+        <type category="struct" name="VkExportSemaphoreCreateInfo" structextends="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalSemaphoreHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportSemaphoreCreateInfoKHR"                          alias="VkExportSemaphoreCreateInfo"/>
+        <type category="struct" name="VkImportSemaphoreWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
+            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
+            <member noautovalidity="true"><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>           <name>handle</name></member>
+            <member optional="true"><type>LPCWSTR</type>          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkExportSemaphoreWin32HandleInfoKHR" structextends="VkSemaphoreCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>*       <name>pAttributes</name></member>
+            <member><type>DWORD</type>                            <name>dwAccess</name></member>
+            <member><type>LPCWSTR</type>                          <name>name</name></member>
+        </type>
+        <type category="struct" name="VkD3D12FenceSubmitInfoKHR" structextends="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreValuesCount</name></member>
+            <member optional="true" len="waitSemaphoreValuesCount">const <type>uint64_t</type>* <name>pWaitSemaphoreValues</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreValuesCount</name></member>
+            <member optional="true" len="signalSemaphoreValuesCount">const <type>uint64_t</type>* <name>pSignalSemaphoreValues</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreGetWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportSemaphoreFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
+            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member><type>int</type>                              <name>fd</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreGetFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportSemaphoreZirconHandleInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSemaphore</type>    <name>semaphore</name></member>
+            <member optional="true"><type>VkSemaphoreImportFlags</type> <name>flags</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member><type>zx_handle_t</type>                              <name>zirconHandle</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreGetZirconHandleInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                      <name>semaphore</name></member>
+            <member><type>VkExternalSemaphoreHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalFenceInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalFenceInfoKHR"                    alias="VkPhysicalDeviceExternalFenceInfo"/>
+        <type category="struct" name="VkExternalFenceProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExternalFenceHandleTypeFlags</type> <name>exportFromImportedHandleTypes</name></member>
+            <member><type>VkExternalFenceHandleTypeFlags</type> <name>compatibleHandleTypes</name></member>
+            <member optional="true"><type>VkExternalFenceFeatureFlags</type> <name>externalFenceFeatures</name></member>
+        </type>
+        <type category="struct" name="VkExternalFencePropertiesKHR"                            alias="VkExternalFenceProperties"/>
+        <type category="struct" name="VkExportFenceCreateInfo" structextends="VkFenceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkExternalFenceHandleTypeFlags</type> <name>handleTypes</name></member>
+        </type>
+        <type category="struct" name="VkExportFenceCreateInfoKHR"                              alias="VkExportFenceCreateInfo"/>
+        <type category="struct" name="VkImportFenceWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                        <name>pNext</name></member>
+            <member externsync="true"><type>VkFence</type>                          <name>fence</name></member>
+            <member optional="true"><type>VkFenceImportFlags</type>              <name>flags</name></member>
+            <member noautovalidity="true"><type>VkExternalFenceHandleTypeFlagBits</type>  <name>handleType</name></member>
+            <member optional="true"><type>HANDLE</type>                             <name>handle</name></member>
+            <member optional="true"><type>LPCWSTR</type>                            <name>name</name></member>
+        </type>
+        <type category="struct" name="VkExportFenceWin32HandleInfoKHR" structextends="VkFenceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member optional="true">const <type>SECURITY_ATTRIBUTES</type>* <name>pAttributes</name></member>
+            <member><type>DWORD</type>                                      <name>dwAccess</name></member>
+            <member><type>LPCWSTR</type>                                    <name>name</name></member>
+        </type>
+        <type category="struct" name="VkFenceGetWin32HandleInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFence</type>                                <name>fence</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportFenceFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member externsync="true"><type>VkFence</type>              <name>fence</name></member>
+            <member optional="true"><type>VkFenceImportFlags</type>  <name>flags</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
+            <member><type>int</type>                                    <name>fd</name></member>
+        </type>
+        <type category="struct" name="VkFenceGetFdInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFence</type>                                <name>fence</name></member>
+            <member><type>VkExternalFenceHandleTypeFlagBits</type>   <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>multiview</name><comment>Multiple views in a renderpass</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewGeometryShader</name><comment>Multiple views in a renderpass w/ geometry shader</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewTessellationShader</name><comment>Multiple views in a renderpass w/ tessellation shader</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewFeaturesKHR"                    alias="VkPhysicalDeviceMultiviewFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceMultiviewProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewViewCount</name><comment>max number of views in a subpass</comment></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewInstanceIndex</name><comment>max instance index for a draw in a multiview subpass</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewPropertiesKHR"                  alias="VkPhysicalDeviceMultiviewProperties"/>
+        <type category="struct" name="VkRenderPassMultiviewCreateInfo" structextends="VkRenderPassCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"><type>VkStructureType</type>        <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>subpassCount</name></member>
+            <member len="subpassCount">const <type>uint32_t</type>*     <name>pViewMasks</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>dependencyCount</name></member>
+            <member len="dependencyCount">const <type>int32_t</type>*   <name>pViewOffsets</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>correlationMaskCount</name></member>
+            <member len="correlationMaskCount">const <type>uint32_t</type>* <name>pCorrelationMasks</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassMultiviewCreateInfoKHR"                      alias="VkRenderPassMultiviewCreateInfo"/>
+        <type category="struct" name="VkSurfaceCapabilities2EXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>minImageCount</name><comment>Supported minimum number of images for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageCount</name><comment>Supported maximum number of images for the surface, 0 for unlimited</comment></member>
+            <member><type>VkExtent2D</type>                       <name>currentExtent</name><comment>Current image width and height for the surface, (0, 0) if undefined</comment></member>
+            <member><type>VkExtent2D</type>                       <name>minImageExtent</name><comment>Supported minimum image width and height for the surface</comment></member>
+            <member><type>VkExtent2D</type>                       <name>maxImageExtent</name><comment>Supported maximum image width and height for the surface</comment></member>
+            <member><type>uint32_t</type>                         <name>maxImageArrayLayers</name><comment>Supported maximum number of image layers for the surface</comment></member>
+            <member><type>VkSurfaceTransformFlagsKHR</type>       <name>supportedTransforms</name><comment>1 or more bits representing the transforms supported</comment></member>
+            <member><type>VkSurfaceTransformFlagBitsKHR</type>    <name>currentTransform</name><comment>The surface's current transform relative to the device's natural orientation</comment></member>
+            <member><type>VkCompositeAlphaFlagsKHR</type>         <name>supportedCompositeAlpha</name><comment>1 or more bits representing the alpha compositing modes supported</comment></member>
+            <member><type>VkImageUsageFlags</type>                <name>supportedUsageFlags</name><comment>Supported image usage flags for the surface</comment></member>
+            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type> <name>supportedSurfaceCounters</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPowerInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDisplayPowerStateEXT</type>           <name>powerState</name></member>
+        </type>
+        <type category="struct" name="VkDeviceEventInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceEventTypeEXT</type>             <name>deviceEvent</name></member>
+        </type>
+        <type category="struct" name="VkDisplayEventInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDisplayEventTypeEXT</type>            <name>displayEvent</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainCounterCreateInfoEXT" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkSurfaceCounterFlagsEXT</type>         <name>surfaceCounters</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGroupProperties" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
+            <member><type>VkPhysicalDevice</type>                 <name>physicalDevices</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
+            <member><type>VkBool32</type>                         <name>subsetAllocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGroupPropertiesKHR"                      alias="VkPhysicalDeviceGroupProperties"/>
+        <type category="struct" name="VkMemoryAllocateFlagsInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkMemoryAllocateFlags</type> <name>flags</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkMemoryAllocateFlagsInfoKHR"                            alias="VkMemoryAllocateFlagsInfo"/>
+        <type category="struct" name="VkBindBufferMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBuffer</type>                         <name>buffer</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
+        </type>
+        <type category="struct" name="VkBindBufferMemoryInfoKHR"                               alias="VkBindBufferMemoryInfo"/>
+        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfo" structextends="VkBindBufferMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
+            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
+        </type>
+        <type category="struct" name="VkBindBufferMemoryDeviceGroupInfoKHR"                    alias="VkBindBufferMemoryDeviceGroupInfo"/>
+        <type category="struct" name="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkImage</type>                          <name>image</name></member>
+            <member noautovalidity="true"><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
+        </type>
+        <type category="struct" name="VkBindImageMemoryInfoKHR"                                alias="VkBindImageMemoryInfo"/>
+        <type category="struct" name="VkBindImageMemoryDeviceGroupInfo" structextends="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
+            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>splitInstanceBindRegionCount</name></member>
+            <member len="splitInstanceBindRegionCount">const <type>VkRect2D</type>*  <name>pSplitInstanceBindRegions</name></member>
+        </type>
+        <type category="struct" name="VkBindImageMemoryDeviceGroupInfoKHR"                     alias="VkBindImageMemoryDeviceGroupInfo"/>
+        <type category="struct" name="VkDeviceGroupRenderPassBeginInfo" structextends="VkRenderPassBeginInfo,VkRenderingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceRenderAreaCount</name></member>
+            <member len="deviceRenderAreaCount">const <type>VkRect2D</type>*  <name>pDeviceRenderAreas</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupRenderPassBeginInfoKHR"                     alias="VkDeviceGroupRenderPassBeginInfo"/>
+        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfo" structextends="VkCommandBufferBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupCommandBufferBeginInfoKHR"                  alias="VkDeviceGroupCommandBufferBeginInfo"/>
+        <type category="struct" name="VkDeviceGroupSubmitInfo" structextends="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreCount</name></member>
+            <member len="waitSemaphoreCount">const <type>uint32_t</type>*    <name>pWaitSemaphoreDeviceIndices</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>commandBufferCount</name></member>
+            <member len="commandBufferCount">const <type>uint32_t</type>*    <name>pCommandBufferDeviceMasks</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreCount</name></member>
+            <member len="signalSemaphoreCount">const <type>uint32_t</type>*  <name>pSignalSemaphoreDeviceIndices</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupSubmitInfoKHR"                              alias="VkDeviceGroupSubmitInfo"/>
+        <type category="struct" name="VkDeviceGroupBindSparseInfo" structextends="VkBindSparseInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>resourceDeviceIndex</name></member>
+            <member><type>uint32_t</type>                         <name>memoryDeviceIndex</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupBindSparseInfoKHR"                          alias="VkDeviceGroupBindSparseInfo"/>
+        <type category="struct" name="VkDeviceGroupPresentCapabilitiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>presentMask</name>[<enum>VK_MAX_DEVICE_GROUP_SIZE</enum>]</member>
+            <member><type>VkDeviceGroupPresentModeFlagsKHR</type> <name>modes</name></member>
+        </type>
+        <type category="struct" name="VkImageSwapchainCreateInfoKHR" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkSwapchainKHR</type>   <name>swapchain</name></member>
+        </type>
+        <type category="struct" name="VkBindImageMemorySwapchainInfoKHR" structextends="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
+            <member><type>uint32_t</type>                         <name>imageIndex</name></member>
+        </type>
+        <type category="struct" name="VkAcquireNextImageInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></member>
+            <member><type>uint64_t</type>                         <name>timeout</name></member>
+            <member optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></member>
+            <member optional="true" externsync="true"><type>VkFence</type> <name>fence</name></member>
+            <member><type>uint32_t</type>                         <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupPresentInfoKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>swapchainCount</name></member>
+            <member len="swapchainCount">const <type>uint32_t</type>* <name>pDeviceMasks</name></member>
+            <member><type>VkDeviceGroupPresentModeFlagBitsKHR</type> <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupDeviceCreateInfo" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                         <name>physicalDeviceCount</name></member>
+            <member len="physicalDeviceCount">const <type>VkPhysicalDevice</type>*  <name>pPhysicalDevices</name></member>
+        </type>
+        <type category="struct" name="VkDeviceGroupDeviceCreateInfoKHR"                        alias="VkDeviceGroupDeviceCreateInfo"/>
+        <type category="struct" name="VkDeviceGroupSwapchainCreateInfoKHR" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceGroupPresentModeFlagsKHR</type>                         <name>modes</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorUpdateTemplateEntry">
+            <member><type>uint32_t</type>                         <name>dstBinding</name><comment>Binding within the destination descriptor set to write</comment></member>
+            <member><type>uint32_t</type>                         <name>dstArrayElement</name><comment>Array element within the destination binding to write</comment></member>
+            <member><type>uint32_t</type>                         <name>descriptorCount</name><comment>Number of descriptors to write</comment></member>
+            <member><type>VkDescriptorType</type>                 <name>descriptorType</name><comment>Descriptor type to write</comment></member>
+            <member><type>size_t</type>                           <name>offset</name><comment>Offset into pData where the descriptors to update are stored</comment></member>
+            <member><type>size_t</type>                           <name>stride</name><comment>Stride between two descriptors in pData when writing more than one descriptor</comment></member>
+        </type>
+        <type category="struct" name="VkDescriptorUpdateTemplateEntryKHR"                      alias="VkDescriptorUpdateTemplateEntry"/>
+        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                               <name>pNext</name></member>
+            <member optional="true"><type>VkDescriptorUpdateTemplateCreateFlags</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>                 <name>descriptorUpdateEntryCount</name><comment>Number of descriptor update entries to use for the update template</comment></member>
+            <member len="descriptorUpdateEntryCount">const <type>VkDescriptorUpdateTemplateEntry</type>* <name>pDescriptorUpdateEntries</name><comment>Descriptor update entries for the template</comment></member>
+            <member><type>VkDescriptorUpdateTemplateType</type> <name>templateType</name></member>
+            <member noautovalidity="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></member>
+            <member noautovalidity="true"><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></member>
+            <member noautovalidity="true"><type>VkPipelineLayout</type><name>pipelineLayout</name><comment>If used for push descriptors, this is the only allowed layout</comment></member>
+            <member noautovalidity="true"><type>uint32_t</type> <name>set</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorUpdateTemplateCreateInfoKHR"                 alias="VkDescriptorUpdateTemplateCreateInfo"/>
+        <type category="struct" name="VkXYColorEXT" comment="Chromaticity coordinate">
+            <member><type>float</type>   <name>x</name></member>
+            <member><type>float</type>   <name>y</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePresentIdFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>presentId</name><comment>Present ID in VkPresentInfoKHR</comment></member>
+        </type>
+        <type category="struct" name="VkPresentIdKHR" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_ID_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount" optional="true">const <type>uint64_t</type>* <name>pPresentIds</name><comment>Present ID values for each swapchain</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePresentWaitFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>presentWait</name><comment>vkWaitForPresentKHR is supported</comment></member>
+        </type>
+        <type category="struct" name="VkHdrMetadataEXT">
+                <comment>Display primary in chromaticity coordinates</comment>
+            <member values="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+                <comment> From SMPTE 2086</comment>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryRed</name><comment>Display primary's Red</comment></member>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryGreen</name><comment>Display primary's Green</comment></member>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>displayPrimaryBlue</name><comment>Display primary's Blue</comment></member>
+            <member noautovalidity="true"><type>VkXYColorEXT</type>   <name>whitePoint</name><comment>Display primary's Blue</comment></member>
+            <member noautovalidity="true"><type>float</type>          <name>maxLuminance</name><comment>Display maximum luminance</comment></member>
+            <member noautovalidity="true"><type>float</type>          <name>minLuminance</name><comment>Display minimum luminance</comment></member>
+                <comment> From CTA 861.3</comment>
+            <member noautovalidity="true"><type>float</type>          <name>maxContentLightLevel</name><comment>Content maximum luminance</comment></member>
+            <member noautovalidity="true"><type>float</type>          <name>maxFrameAverageLightLevel</name></member>
+        </type>
+        <type category="struct" name="VkDisplayNativeHdrSurfaceCapabilitiesAMD" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>localDimmingSupport</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainDisplayNativeHdrCreateInfoAMD" structextends="VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>localDimmingEnable</name></member>
+        </type>
+        <type category="struct" name="VkRefreshCycleDurationGOOGLE" returnedonly="true">
+            <member><type>uint64_t</type>                         <name>refreshDuration</name><comment>Number of nanoseconds from the start of one refresh cycle to the next</comment></member>
+        </type>
+        <type category="struct" name="VkPastPresentationTimingGOOGLE" returnedonly="true">
+            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier, previously given to vkQueuePresentKHR</comment></member>
+            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should have been presented, previously given to vkQueuePresentKHR</comment></member>
+            <member><type>uint64_t</type>                         <name>actualPresentTime</name><comment>Time the image was actually displayed</comment></member>
+            <member><type>uint64_t</type>                         <name>earliestPresentTime</name><comment>Earliest time the image could have been displayed</comment></member>
+            <member><type>uint64_t</type>                         <name>presentMargin</name><comment>How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime</comment></member>
+        </type>
+        <type category="struct" name="VkPresentTimesInfoGOOGLE" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>swapchainCount</name><comment>Copy of VkPresentInfoKHR::swapchainCount</comment></member>
+            <member len="swapchainCount" optional="true">const <type>VkPresentTimeGOOGLE</type>*   <name>pTimes</name><comment>The earliest times to present images</comment></member>
+        </type>
+        <type category="struct" name="VkPresentTimeGOOGLE">
+            <member><type>uint32_t</type>                         <name>presentID</name><comment>Application-provided identifier</comment></member>
+            <member><type>uint64_t</type>                         <name>desiredPresentTime</name><comment>Earliest time an image should be presented</comment></member>
+        </type>
+        <type category="struct" name="VkIOSSurfaceCreateInfoMVK">
+            <member values="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkIOSSurfaceCreateFlagsMVK</type>     <name>flags</name></member>
+            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
+        </type>
+        <type category="struct" name="VkMacOSSurfaceCreateInfoMVK">
+            <member values="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkMacOSSurfaceCreateFlagsMVK</type>   <name>flags</name></member>
+            <member noautovalidity="true">const <type>void</type>*                                    <name>pView</name></member>
+        </type>
+        <type category="struct" name="VkMetalSurfaceCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member optional="true"><type>VkMetalSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
+            <member noautovalidity="true">const <type>CAMetalLayer</type>*      <name>pLayer</name></member>
+        </type>
+        <type category="struct" name="VkViewportWScalingNV">
+            <member><type>float</type>          <name>xcoeff</name></member>
+            <member><type>float</type>          <name>ycoeff</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportWScalingStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>viewportWScalingEnable</name></member>
+            <member><type>uint32_t</type>               <name>viewportCount</name></member>
+            <member noautovalidity="true" optional="true" len="viewportCount">const <type>VkViewportWScalingNV</type>*      <name>pViewportWScalings</name></member>
+        </type>
+        <type category="struct" name="VkViewportSwizzleNV">
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>x</name></member>
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>y</name></member>
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>z</name></member>
+            <member><type>VkViewportCoordinateSwizzleNV</type>          <name>w</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportSwizzleStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineViewportSwizzleStateCreateFlagsNV</type>    <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>viewportCount</name></member>
+            <member len="viewportCount">const <type>VkViewportSwizzleNV</type>*      <name>pViewportSwizzles</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDiscardRectanglePropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDiscardRectangles</name><comment>max number of active discard rectangles</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineDiscardRectangleStateCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineDiscardRectangleStateCreateFlagsEXT</type>     <name>flags</name></member>
+            <member><type>VkDiscardRectangleModeEXT</type>                                         <name>discardRectangleMode</name></member>
+            <member optional="true"><type>uint32_t</type>                                          <name>discardRectangleCount</name></member>
+            <member noautovalidity="true" len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>perViewPositionAllComponents</name></member>
+        </type>
+        <type category="struct" name="VkInputAttachmentAspectReference">
+            <member><type>uint32_t</type>                        <name>subpass</name></member>
+            <member><type>uint32_t</type>                        <name>inputAttachmentIndex</name></member>
+            <member><type>VkImageAspectFlags</type>              <name>aspectMask</name></member>
+        </type>
+        <type category="struct" name="VkInputAttachmentAspectReferenceKHR"                     alias="VkInputAttachmentAspectReference"/>
+        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfo" structextends="VkRenderPassCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>uint32_t</type>                        <name>aspectReferenceCount</name></member>
+            <member len="aspectReferenceCount">const <type>VkInputAttachmentAspectReference</type>* <name>pAspectReferences</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassInputAttachmentAspectCreateInfoKHR"          alias="VkRenderPassInputAttachmentAspectCreateInfo"/>
+        <type category="struct" name="VkPhysicalDeviceSurfaceInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkSurfaceKHR</type> <name>surface</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceCapabilities2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*   <name>pNext</name></member>
+            <member><type>VkSurfaceCapabilitiesKHR</type> <name>surfaceCapabilities</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceFormat2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkSurfaceFormatKHR</type> <name>surfaceFormat</name></member>
+        </type>
+        <type category="struct" name="VkDisplayProperties2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayPropertiesKHR</type> <name>displayProperties</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneProperties2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayPlanePropertiesKHR</type> <name>displayPlaneProperties</name></member>
+        </type>
+        <type category="struct" name="VkDisplayModeProperties2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayModePropertiesKHR</type> <name>displayModeProperties</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></member>
+            <member><type>uint32_t</type> <name>planeIndex</name></member>
+        </type>
+        <type category="struct" name="VkDisplayPlaneCapabilities2KHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkDisplayPlaneCapabilitiesKHR</type> <name>capabilities</name></member>
+        </type>
+        <type category="struct" name="VkSharedPresentSurfaceCapabilitiesKHR" returnedonly="true" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkImageUsageFlags</type> <name>sharedPresentSupportedUsageFlags</name><comment>Supported image usage flags if swapchain created using a shared present mode</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice16BitStorageFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock and Block</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant16</name><comment>16-bit integer/floating-point variables supported in PushConstant</comment></member>
+            <member><type>VkBool32</type>                         <name>storageInputOutput16</name><comment>16-bit integer/floating-point variables supported in shader inputs and outputs</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice16BitStorageFeaturesKHR"                 alias="VkPhysicalDevice16BitStorageFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceSubgroupProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
+            <member limittype="noauto" noautovalidity="true"><type>uint32_t</type>                      <name>subgroupSize</name><comment>The size of a subgroup for this queue.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkShaderStageFlags</type>            <name>supportedStages</name><comment>Bitfield of what shader stages support subgroup operations</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkSubgroupFeatureFlags</type>        <name>supportedOperations</name><comment>Bitfield of what subgroup operations are supported.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkBool32</type> <name>quadOperationsInAllStages</name><comment>Flag to specify whether quad operations are available in all stages.</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkBool32</type> <name>shaderSubgroupExtendedTypes</name><comment>Flag to specify whether subgroup operations with extended types are supported</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"  alias="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"/>
+        <type category="struct" name="VkBufferMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkBuffer</type>                                                             <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkBufferMemoryRequirementsInfo2KHR"                      alias="VkBufferMemoryRequirementsInfo2"/>
+        <type category="struct" name="VkDeviceBufferMemoryRequirementsKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                           <name>pNext</name></member>
+            <member>const <type>VkBufferCreateInfo</type>*                                                             <name>pCreateInfo</name></member>
+        </type>
+        <type category="struct" name="VkImageMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkImage</type>                                                              <name>image</name></member>
+        </type>
+        <type category="struct" name="VkImageMemoryRequirementsInfo2KHR"                       alias="VkImageMemoryRequirementsInfo2"/>
+        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkImage</type>                                                              <name>image</name></member>
+        </type>
+        <type category="struct" name="VkImageSparseMemoryRequirementsInfo2KHR"                 alias="VkImageSparseMemoryRequirementsInfo2"/>
+        <type category="struct" name="VkDeviceImageMemoryRequirementsKHR">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member>const <type>VkImageCreateInfo</type>*                                                             <name>pCreateInfo</name></member>
+            <member><type>VkImageAspectFlagBits</type>                                                                <name>planeAspect</name></member>
+        </type>
+        <type category="struct" name="VkMemoryRequirements2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkMemoryRequirements</type>                                                 <name>memoryRequirements</name></member>
+        </type>
+        <type category="struct" name="VkMemoryRequirements2KHR"                                alias="VkMemoryRequirements2"/>
+        <type category="struct" name="VkSparseImageMemoryRequirements2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                       <name>pNext</name></member>
+            <member><type>VkSparseImageMemoryRequirements</type>                                      <name>memoryRequirements</name></member>
+        </type>
+        <type category="struct" name="VkSparseImageMemoryRequirements2KHR"                     alias="VkSparseImageMemoryRequirements2"/>
+        <type category="struct" name="VkPhysicalDevicePointClippingProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="noauto"><type>VkPointClippingBehavior</type>      <name>pointClippingBehavior</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePointClippingPropertiesKHR"              alias="VkPhysicalDevicePointClippingProperties"/>
+        <type category="struct" name="VkMemoryDedicatedRequirements" returnedonly="true" structextends="VkMemoryRequirements2">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>prefersDedicatedAllocation</name></member>
+            <member><type>VkBool32</type>                         <name>requiresDedicatedAllocation</name></member>
+        </type>
+        <type category="struct" name="VkMemoryDedicatedRequirementsKHR"                        alias="VkMemoryDedicatedRequirements"/>
+        <type category="struct" name="VkMemoryDedicatedAllocateInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>VkImage</type>          <name>image</name><comment>Image that this allocation will be bound to</comment></member>
+            <member optional="true"><type>VkBuffer</type>         <name>buffer</name><comment>Buffer that this allocation will be bound to</comment></member>
+        </type>
+        <type category="struct" name="VkMemoryDedicatedAllocateInfoKHR"                        alias="VkMemoryDedicatedAllocateInfo"/>
+        <type category="struct" name="VkImageViewUsageCreateInfo" structextends="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImageUsageFlags</type> <name>usage</name></member>
+        </type>
+        <type category="struct" name="VkImageViewUsageCreateInfoKHR"                           alias="VkImageViewUsageCreateInfo"/>
+        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfo" structextends="VkPipelineTessellationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkTessellationDomainOrigin</type>    <name>domainOrigin</name></member>
+        </type>
+        <type category="struct" name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"    alias="VkPipelineTessellationDomainOriginStateCreateInfo"/>
+        <type category="struct" name="VkSamplerYcbcrConversionInfo" structextends="VkSamplerCreateInfo,VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSamplerYcbcrConversion</type>      <name>conversion</name></member>
+        </type>
+        <type category="struct" name="VkSamplerYcbcrConversionInfoKHR"                         alias="VkSamplerYcbcrConversionInfo"/>
+        <type category="struct" name="VkSamplerYcbcrConversionCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>format</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type> <name>ycbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>           <name>ycbcrRange</name></member>
+            <member><type>VkComponentMapping</type>               <name>components</name></member>
+            <member><type>VkChromaLocation</type>              <name>xChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>              <name>yChromaOffset</name></member>
+            <member><type>VkFilter</type>                         <name>chromaFilter</name></member>
+            <member><type>VkBool32</type>                         <name>forceExplicitReconstruction</name></member>
+        </type>
+        <type category="struct" name="VkSamplerYcbcrConversionCreateInfoKHR"                   alias="VkSamplerYcbcrConversionCreateInfo"/>
+        <type category="struct" name="VkBindImagePlaneMemoryInfo" structextends="VkBindImageMemoryInfo">
+            <member values="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
+        </type>
+        <type category="struct" name="VkBindImagePlaneMemoryInfoKHR"                           alias="VkBindImagePlaneMemoryInfo"/>
+        <type category="struct" name="VkImagePlaneMemoryRequirementsInfo" structextends="VkImageMemoryRequirementsInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkImageAspectFlagBits</type>            <name>planeAspect</name></member>
+        </type>
+        <type category="struct" name="VkImagePlaneMemoryRequirementsInfoKHR"                   alias="VkImagePlaneMemoryRequirementsInfo"/>
+        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>samplerYcbcrConversion</name><comment>Sampler color conversion supported</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"       alias="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
+        <type category="struct" name="VkSamplerYcbcrConversionImageFormatProperties" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>combinedImageSamplerDescriptorCount</name></member>
+        </type>
+        <type category="struct" name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"        alias="VkSamplerYcbcrConversionImageFormatProperties"/>
+        <type category="struct" name="VkTextureLODGatherFormatPropertiesAMD" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>supportsTextureGatherLODBiasAMD</name></member>
+        </type>
+        <type category="struct" name="VkConditionalRenderingBeginInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBuffer</type>                         <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>                     <name>offset</name></member>
+            <member optional="true"><type>VkConditionalRenderingFlagsEXT</type>    <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkProtectedSubmitInfo" structextends="VkSubmitInfo">
+            <member values="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                        <name>protectedSubmit</name><comment>Submit protected command buffers</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProtectedMemoryFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>protectedMemory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProtectedMemoryProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                            <name>protectedNoFault</name></member>
+        </type>
+        <type category="struct" name="VkDeviceQueueInfo2">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceQueueCreateFlags</type>            <name>flags</name></member>
+            <member><type>uint32_t</type>                            <name>queueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                            <name>queueIndex</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCoverageToColorStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCoverageToColorStateCreateFlagsNV</type>                    <name>flags</name></member>
+            <member><type>VkBool32</type>                         <name>coverageToColorEnable</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>coverageToColorLocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSamplerFilterMinmaxProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>filterMinmaxSingleComponentFormats</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>filterMinmaxImageComponentMapping</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT" alias="VkPhysicalDeviceSamplerFilterMinmaxProperties"/>
+        <type category="struct" name="VkSampleLocationEXT">
+            <member><type>float</type>                            <name>x</name></member>
+            <member><type>float</type>                            <name>y</name></member>
+        </type>
+        <type category="struct" name="VkSampleLocationsInfoEXT" structextends="VkImageMemoryBarrier,VkImageMemoryBarrier2KHR">
+            <member values="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkSampleCountFlagBits</type>  <name>sampleLocationsPerPixel</name></member>
+            <member><type>VkExtent2D</type>                             <name>sampleLocationGridSize</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>sampleLocationsCount</name></member>
+            <member len="sampleLocationsCount">const <type>VkSampleLocationEXT</type>* <name>pSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentSampleLocationsEXT">
+            <member><type>uint32_t</type>                         <name>attachmentIndex</name></member>
+            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
+        </type>
+        <type category="struct" name="VkSubpassSampleLocationsEXT">
+            <member><type>uint32_t</type>                         <name>subpassIndex</name></member>
+            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassSampleLocationsBeginInfoEXT" structextends="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>attachmentInitialSampleLocationsCount</name></member>
+            <member len="attachmentInitialSampleLocationsCount">const <type>VkAttachmentSampleLocationsEXT</type>* <name>pAttachmentInitialSampleLocations</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>postSubpassSampleLocationsCount</name></member>
+            <member len="postSubpassSampleLocationsCount">const <type>VkSubpassSampleLocationsEXT</type>* <name>pPostSubpassSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkPipelineSampleLocationsStateCreateInfoEXT" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>sampleLocationsEnable</name></member>
+            <member><type>VkSampleLocationsInfoEXT</type>         <name>sampleLocationsInfo</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSampleLocationsPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkSampleCountFlags</type>               <name>sampleLocationSampleCounts</name></member>
+            <member limittype="max"><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
+            <member limittype="range"><type>float</type>                            <name>sampleLocationCoordinateRange</name>[2]</member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>sampleLocationSubPixelBits</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>variableSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkMultisamplePropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxSampleLocationGridSize</name></member>
+        </type>
+        <type category="struct" name="VkSamplerReductionModeCreateInfo" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkSamplerReductionMode</type>           <name>reductionMode</name></member>
+        </type>
+        <type category="struct" name="VkSamplerReductionModeCreateInfoEXT" alias="VkSamplerReductionModeCreateInfo"/>
+        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>advancedBlendCoherentOperations</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMultiDrawFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>multiDraw</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>advancedBlendMaxColorAttachments</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendIndependentBlend</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedSrcColor</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendNonPremultipliedDstColor</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendCorrelatedOverlap</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>advancedBlendAllOperations</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorBlendAdvancedStateCreateInfoEXT" structextends="VkPipelineColorBlendStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>srcPremultiplied</name></member>
+            <member><type>VkBool32</type>               <name>dstPremultiplied</name></member>
+            <member><type>VkBlendOverlapEXT</type>      <name>blendOverlap</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>inlineUniformBlock</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingInlineUniformBlockUpdateAfterBind</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxInlineUniformBlockSize</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetInlineUniformBlocks</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInlineUniformBlocks</name></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSetInlineUniformBlockEXT" structextends="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>               <name>dataSize</name></member>
+            <member len="dataSize">const <type>void</type>* <name>pData</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT" structextends="VkDescriptorPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>               <name>maxInlineUniformBlockBindings</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCoverageModulationStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCoverageModulationStateCreateFlagsNV</type>                   <name>flags</name></member>
+            <member><type>VkCoverageModulationModeNV</type>                                                       <name>coverageModulationMode</name></member>
+            <member><type>VkBool32</type>                                                                         <name>coverageModulationTableEnable</name></member>
+            <member optional="true"><type>uint32_t</type>                                                         <name>coverageModulationTableCount</name></member>
+            <member noautovalidity="true" optional="true" len="coverageModulationTableCount">const <type>float</type>* <name>pCoverageModulationTable</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatListCreateInfo" structextends="VkImageCreateInfo,VkSwapchainCreateInfoKHR,VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>viewFormatCount</name></member>
+            <member len="viewFormatCount">const <type>VkFormat</type>*  <name>pViewFormats</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatListCreateInfoKHR"                          alias="VkImageFormatListCreateInfo"/>
+        <type category="struct" name="VkValidationCacheCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkValidationCacheCreateFlagsEXT</type>    <name>flags</name></member>
+            <member optional="true"><type>size_t</type>                 <name>initialDataSize</name></member>
+            <member len="initialDataSize">const <type>void</type>*            <name>pInitialData</name></member>
+        </type>
+        <type category="struct" name="VkShaderModuleValidationCacheCreateInfoEXT" structextends="VkShaderModuleCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkValidationCacheEXT</type>    <name>validationCache</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance3Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerSetDescriptors</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxMemoryAllocationSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance3PropertiesKHR"               alias="VkPhysicalDeviceMaintenance3Properties"/>
+        <type category="struct" name="VkPhysicalDeviceMaintenance4FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                                         <name>maintenance4</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMaintenance4PropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxBufferSize</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutSupport" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>         <name>supported</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutSupportKHR"                         alias="VkDescriptorSetLayoutSupport"/>
+        <type category="struct" name="VkPhysicalDeviceShaderDrawParametersFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>shaderDrawParameters</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderDrawParameterFeatures"             alias="VkPhysicalDeviceShaderDrawParametersFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceShaderFloat16Int8Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>shaderFloat16</name><comment>16-bit floats (halfs) in shaders</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderInt8</name><comment>8-bit integers in shaders</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"            alias="VkPhysicalDeviceShaderFloat16Int8Features"/>
+        <type category="struct" name="VkPhysicalDeviceFloat16Int8FeaturesKHR"                  alias="VkPhysicalDeviceShaderFloat16Int8Features"/>
+        <type category="struct" name="VkPhysicalDeviceFloatControlsProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="noauto"><type>VkShaderFloatControlsIndependence</type> <name>denormBehaviorIndependence</name></member>
+            <member limittype="noauto"><type>VkShaderFloatControlsIndependence</type> <name>roundingModeIndependence</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat16</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat32</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat64</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat16</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat32</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat64</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat16</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat32</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat64</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat16</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat32</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat64</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat16</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat32</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat64</name><comment>An implementation can support RTZ</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFloatControlsPropertiesKHR"              alias="VkPhysicalDeviceFloatControlsProperties"/>
+        <type category="struct" name="VkPhysicalDeviceHostQueryResetFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>hostQueryReset</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceHostQueryResetFeaturesEXT"               alias="VkPhysicalDeviceHostQueryResetFeatures"/>
+        <type category="struct" name="VkNativeBufferUsage2ANDROID">
+            <member><type>uint64_t</type> <name>consumer</name></member>
+            <member><type>uint64_t</type> <name>producer</name></member>
+        </type>
+        <type category="struct" name="VkNativeBufferANDROID">
+            <member values="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member>const <type>void</type>* <name>handle</name></member>
+            <member><type>int</type> <name>stride</name></member>
+            <member><type>int</type> <name>format</name></member>
+            <member><type>int</type> <name>usage</name></member>
+            <member><type>VkNativeBufferUsage2ANDROID</type> <name>usage2</name></member>
+        </type>
+        <type category="struct" name="VkSwapchainImageCreateInfoANDROID">
+            <member values="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkSwapchainImageUsageFlagsANDROID</type> <name>usage</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePresentationPropertiesANDROID">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>sharedImage</name></member>
+        </type>
+        <type category="struct" name="VkShaderResourceUsageAMD" returnedonly="true">
+            <member><type>uint32_t</type> <name>numUsedVgprs</name></member>
+            <member><type>uint32_t</type> <name>numUsedSgprs</name></member>
+            <member><type>uint32_t</type> <name>ldsSizePerLocalWorkGroup</name></member>
+            <member><type>size_t</type> <name>ldsUsageSizeInBytes</name></member>
+            <member><type>size_t</type> <name>scratchMemUsageInBytes</name></member>
+        </type>
+        <type category="struct" name="VkShaderStatisticsInfoAMD" returnedonly="true">
+            <member><type>VkShaderStageFlags</type> <name>shaderStageMask</name></member>
+            <member><type>VkShaderResourceUsageAMD</type> <name>resourceUsage</name></member>
+            <member><type>uint32_t</type> <name>numPhysicalVgprs</name></member>
+            <member><type>uint32_t</type> <name>numPhysicalSgprs</name></member>
+            <member><type>uint32_t</type> <name>numAvailableVgprs</name></member>
+            <member><type>uint32_t</type> <name>numAvailableSgprs</name></member>
+            <member><type>uint32_t</type> <name>computeWorkGroupSize</name>[3]</member>
+        </type>
+        <type category="struct" name="VkDeviceQueueGlobalPriorityCreateInfoEXT" structextends="VkDeviceQueueCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>VkQueueGlobalPriorityEXT</type>       <name>globalPriority</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                    <name>globalPriorityQuery</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyGlobalPriorityPropertiesEXT" structextends="VkQueueFamilyProperties2">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>uint32_t</type>                 <name>priorityCount</name></member>
+            <member><type>VkQueueGlobalPriorityEXT</type> <name>priorities</name>[<enum>VK_MAX_GLOBAL_PRIORITY_SIZE_EXT</enum>]</member>
+        </type>
+        <type category="struct" name="VkDebugUtilsObjectNameInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkObjectType</type>                                           <name>objectType</name></member>
+            <member objecttype="objectType"><type>uint64_t</type>                                               <name>objectHandle</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*      <name>pObjectName</name></member>
+        </type>
+        <type category="struct" name="VkDebugUtilsObjectTagInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkObjectType</type>                           <name>objectType</name></member>
+            <member objecttype="objectType"><type>uint64_t</type>                               <name>objectHandle</name></member>
+            <member><type>uint64_t</type>                               <name>tagName</name></member>
+            <member><type>size_t</type>                                 <name>tagSize</name></member>
+            <member len="tagSize">const <type>void</type>*              <name>pTag</name></member>
+        </type>
+        <type category="struct" name="VkDebugUtilsLabelEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member len="null-terminated">const <type>char</type>*      <name>pLabelName</name></member>
+            <member><type>float</type>                  <name>color</name>[4]</member>
+        </type>
+        <type category="struct" name="VkDebugUtilsMessengerCreateInfoEXT" allowduplicate="true" structextends="VkInstanceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                          <name>pNext</name></member>
+            <member optional="true"><type>VkDebugUtilsMessengerCreateFlagsEXT</type>  <name>flags</name></member>
+            <member><type>VkDebugUtilsMessageSeverityFlagsEXT</type>                  <name>messageSeverity</name></member>
+            <member><type>VkDebugUtilsMessageTypeFlagsEXT</type>                      <name>messageType</name></member>
+            <member><type>PFN_vkDebugUtilsMessengerCallbackEXT</type>                 <name>pfnUserCallback</name></member>
+            <member optional="true"><type>void</type>*                                <name>pUserData</name></member>
+        </type>
+        <type category="struct" name="VkDebugUtilsMessengerCallbackDataEXT">
+            <member values="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member optional="true"><type>VkDebugUtilsMessengerCallbackDataFlagsEXT</type>                          <name>flags</name></member>
+            <member optional="true" len="null-terminated">const <type>char</type>*                                  <name>pMessageIdName</name></member>
+            <member><type>int32_t</type>                                                            <name>messageIdNumber</name></member>
+            <member len="null-terminated">const <type>char</type>*                                                  <name>pMessage</name></member>
+            <member optional="true"><type>uint32_t</type>                                                           <name>queueLabelCount</name></member>
+            <member len="queueLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                  <name>pQueueLabels</name></member>
+            <member optional="true"><type>uint32_t</type>                                                           <name>cmdBufLabelCount</name></member>
+            <member len="cmdBufLabelCount">const <type>VkDebugUtilsLabelEXT</type>*                 <name>pCmdBufLabels</name></member>
+            <member optional="true"><type>uint32_t</type>                                                           <name>objectCount</name></member>
+            <member len="objectCount">const <type>VkDebugUtilsObjectNameInfoEXT</type>*             <name>pObjects</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDeviceMemoryReportFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                    <name>deviceMemoryReport</name></member>
+        </type>
+        <type category="struct" name="VkDeviceDeviceMemoryReportCreateInfoEXT" allowduplicate="true" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>VkDeviceMemoryReportFlagsEXT</type>        <name>flags</name></member>
+            <member><type>PFN_vkDeviceMemoryReportCallbackEXT</type> <name>pfnUserCallback</name></member>
+            <member><type>void</type>*                               <name>pUserData</name></member>
+        </type>
+        <type category="struct" name="VkDeviceMemoryReportCallbackDataEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkDeviceMemoryReportFlagsEXT</type>     <name>flags</name></member>
+            <member><type>VkDeviceMemoryReportEventTypeEXT</type> <name>type</name></member>
+            <member><type>uint64_t</type>                         <name>memoryObjectId</name></member>
+            <member><type>VkDeviceSize</type>                     <name>size</name></member>
+            <member><type>VkObjectType</type>                     <name>objectType</name></member>
+            <member><type>uint64_t</type>                         <name>objectHandle</name></member>
+            <member><type>uint32_t</type>                         <name>heapIndex</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryHostPointerInfoEXT" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+            <member optional="false"><type>void</type>* <name>pHostPointer</name></member>
+        </type>
+        <type category="struct" name="VkMemoryHostPointerPropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type> <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="noauto"><type>VkDeviceSize</type> <name>minImportedHostPointerAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="noauto"><type>float</type>                  <name>primitiveOverestimationSize</name><comment>The size in pixels the primitive is enlarged at each edge during conservative rasterization</comment></member>
+            <member limittype="max"><type>float</type>                  <name>maxExtraPrimitiveOverestimationSize</name><comment>The maximum additional overestimation the client can specify in the pipeline state</comment></member>
+            <member limittype="noauto"><type>float</type>                  <name>extraPrimitiveOverestimationSizeGranularity</name><comment>The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>primitiveUnderestimation</name><comment>true if the implementation supports conservative rasterization underestimation mode</comment></member>
+            <member limittype="noauto"><type>VkBool32</type>               <name>conservativePointAndLineRasterization</name><comment>true if conservative rasterization also applies to points and lines</comment></member>
+            <member limittype="noauto"><type>VkBool32</type>               <name>degenerateTrianglesRasterized</name><comment>true if degenerate triangles (those with zero area after snap) are rasterized</comment></member>
+            <member limittype="noauto"><type>VkBool32</type>               <name>degenerateLinesRasterized</name><comment>true if degenerate lines (those with zero length after snap) are rasterized</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fullyCoveredFragmentShaderInputVariable</name><comment>true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>conservativeRasterizationPostDepthCoverage</name><comment>true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask</comment></member>
+        </type>
+        <type category="struct" name="VkCalibratedTimestampInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkTimeDomainEXT</type>        <name>timeDomain</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderCorePropertiesAMD" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>shaderEngineCount</name><comment>number of shader engines</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>shaderArraysPerEngineCount</name><comment>number of shader arrays</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>computeUnitsPerShaderArray</name><comment>number of physical CUs per shader array</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>simdPerComputeUnit</name><comment>number of SIMDs per compute unit</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>wavefrontsPerSimd</name><comment>number of wavefront slots in each SIMD</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>wavefrontSize</name><comment>maximum number of threads per wavefront</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>sgprsPerSimd</name><comment>number of physical SGPRs per SIMD</comment></member>
+            <member limittype="min"><type>uint32_t</type> <name>minSgprAllocation</name><comment>minimum number of SGPRs that can be allocated by a wave</comment></member>
+            <member limittype="max"><type>uint32_t</type> <name>maxSgprAllocation</name><comment>number of available SGPRs</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>sgprAllocationGranularity</name><comment>SGPRs are allocated in groups of this size</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>vgprsPerSimd</name><comment>number of physical VGPRs per SIMD</comment></member>
+            <member limittype="min"><type>uint32_t</type> <name>minVgprAllocation</name><comment>minimum number of VGPRs that can be allocated by a wave</comment></member>
+            <member limittype="max"><type>uint32_t</type> <name>maxVgprAllocation</name><comment>number of available VGPRs</comment></member>
+            <member limittype="noauto"><type>uint32_t</type> <name>vgprAllocationGranularity</name><comment>VGPRs are allocated in groups of this size</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderCoreProperties2AMD" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member limittype="bitmask"><type>VkShaderCorePropertiesFlagsAMD</type> <name>shaderCoreFeatures</name><comment>features supported by the shader core</comment></member>
+            <member limittype="max"><type>uint32_t</type> <name>activeComputeUnitCount</name><comment>number of active compute units across all shader engines/arrays</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationConservativeStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationConservativeStateCreateFlagsEXT</type>           <name>flags</name><comment>Reserved</comment></member>
+            <member><type>VkConservativeRasterizationModeEXT</type>                                               <name>conservativeRasterizationMode</name><comment>Conservative rasterization mode</comment></member>
+            <member><type>float</type>                                                                            <name>extraPrimitiveOverestimationSize</name><comment>Extra overestimation to add to the primitive</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderUniformTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>shaderStorageTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingUniformBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingSampledImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingStorageImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingStorageBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingUniformTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingStorageTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingUpdateUnusedWhilePending</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingPartiallyBound</name></member>
+            <member><type>VkBool32</type>               <name>descriptorBindingVariableDescriptorCount</name></member>
+            <member><type>VkBool32</type>               <name>runtimeDescriptorArray</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"           alias="VkPhysicalDeviceDescriptorIndexingFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingProperties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxUpdateAfterBindDescriptorsInAllPools</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderUniformBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderSampledImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderStorageBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderStorageImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>shaderInputAttachmentArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>robustBufferAccessUpdateAfterBind</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>quadDivergentImplicitLod</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageDescriptorUpdateAfterBindInputAttachments</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxPerStageUpdateAfterBindResources</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxDescriptorSetUpdateAfterBindInputAttachments</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT"         alias="VkPhysicalDeviceDescriptorIndexingProperties"/>
+        <type category="struct" name="VkDescriptorSetLayoutBindingFlagsCreateInfo" structextends="VkDescriptorSetLayoutCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                           <name>bindingCount</name></member>
+            <member len="bindingCount" optional="false,true">const <type>VkDescriptorBindingFlags</type>* <name>pBindingFlags</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"          alias="VkDescriptorSetLayoutBindingFlagsCreateInfo"/>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountAllocateInfo" structextends="VkDescriptorSetAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>descriptorSetCount</name></member>
+            <member len="descriptorSetCount">const <type>uint32_t</type>* <name>pDescriptorCounts</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"   alias="VkDescriptorSetVariableDescriptorCountAllocateInfo"/>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountLayoutSupport" structextends="VkDescriptorSetLayoutSupport" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>         <name>maxVariableDescriptorCount</name></member>
+        </type>
+        <type category="struct" name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"  alias="VkDescriptorSetVariableDescriptorCountLayoutSupport"/>
+        <type category="struct" name="VkAttachmentDescription2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkAttachmentDescriptionFlags</type> <name>flags</name></member>
+            <member><type>VkFormat</type>                                     <name>format</name></member>
+            <member><type>VkSampleCountFlagBits</type>                        <name>samples</name></member>
+            <member><type>VkAttachmentLoadOp</type>                           <name>loadOp</name><comment>Load operation for color or depth data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>                          <name>storeOp</name><comment>Store operation for color or depth data</comment></member>
+            <member><type>VkAttachmentLoadOp</type>                           <name>stencilLoadOp</name><comment>Load operation for stencil data</comment></member>
+            <member><type>VkAttachmentStoreOp</type>                          <name>stencilStoreOp</name><comment>Store operation for stencil data</comment></member>
+            <member><type>VkImageLayout</type>                                <name>initialLayout</name></member>
+            <member><type>VkImageLayout</type>                                <name>finalLayout</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentDescription2KHR"                             alias="VkAttachmentDescription2"/>
+        <type category="struct" name="VkAttachmentReference2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>attachment</name></member>
+            <member><type>VkImageLayout</type>                     <name>layout</name></member>
+            <member noautovalidity="true"><type>VkImageAspectFlags</type> <name>aspectMask</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentReference2KHR"                               alias="VkAttachmentReference2"/>
+        <type category="struct" name="VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
+            <member optional="true"><type>VkSubpassDescriptionFlags</type>                   <name>flags</name></member>
+            <member><type>VkPipelineBindPoint</type>                                         <name>pipelineBindPoint</name></member>
+            <member><type>uint32_t</type>                                                    <name>viewMask</name></member>
+            <member optional="true"><type>uint32_t</type>                                    <name>inputAttachmentCount</name></member>
+            <member len="inputAttachmentCount">const <type>VkAttachmentReference2</type>*    <name>pInputAttachments</name></member>
+            <member optional="true"><type>uint32_t</type>                                    <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkAttachmentReference2</type>*    <name>pColorAttachments</name></member>
+            <member optional="true" len="colorAttachmentCount">const <type>VkAttachmentReference2</type>* <name>pResolveAttachments</name></member>
+            <member optional="true">const <type>VkAttachmentReference2</type>*               <name>pDepthStencilAttachment</name></member>
+            <member optional="true"><type>uint32_t</type>                                    <name>preserveAttachmentCount</name></member>
+            <member len="preserveAttachmentCount">const <type>uint32_t</type>*               <name>pPreserveAttachments</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDescription2KHR"                                alias="VkSubpassDescription2"/>
+        <type category="struct" name="VkSubpassDependency2">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>srcSubpass</name></member>
+            <member><type>uint32_t</type>                          <name>dstSubpass</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags</type>     <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkAccessFlags</type>     <name>dstAccessMask</name></member>
+            <member optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></member>
+            <member><type>int32_t</type>                           <name>viewOffset</name></member>
+        </type>
+        <type category="struct" name="VkSubpassDependency2KHR"                                 alias="VkSubpassDependency2"/>
+        <type category="struct" name="VkRenderPassCreateInfo2">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                              <name>pNext</name></member>
+            <member optional="true"><type>VkRenderPassCreateFlags</type>                  <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>attachmentCount</name></member>
+            <member len="attachmentCount">const <type>VkAttachmentDescription2</type>*    <name>pAttachments</name></member>
+            <member><type>uint32_t</type>                                                 <name>subpassCount</name></member>
+            <member len="subpassCount">const <type>VkSubpassDescription2</type>*          <name>pSubpasses</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>dependencyCount</name></member>
+            <member len="dependencyCount">const <type>VkSubpassDependency2</type>*        <name>pDependencies</name></member>
+            <member optional="true"><type>uint32_t</type>                                 <name>correlatedViewMaskCount</name></member>
+            <member len="correlatedViewMaskCount">const <type>uint32_t</type>*            <name>pCorrelatedViewMasks</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassCreateInfo2KHR"                              alias="VkRenderPassCreateInfo2"/>
+        <type category="struct" name="VkSubpassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSubpassContents</type>      <name>contents</name></member>
+        </type>
+        <type category="struct" name="VkSubpassBeginInfoKHR"                                   alias="VkSubpassBeginInfo"/>
+        <type category="struct" name="VkSubpassEndInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+        </type>
+        <type category="struct" name="VkSubpassEndInfoKHR"                                     alias="VkSubpassEndInfo"/>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>timelineSemaphore</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"            alias="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphoreProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint64_t</type>               <name>maxTimelineSemaphoreValueDifference</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTimelineSemaphorePropertiesKHR"          alias="VkPhysicalDeviceTimelineSemaphoreProperties"/>
+        <type category="struct" name="VkSemaphoreTypeCreateInfo" structextends="VkSemaphoreCreateInfo,VkPhysicalDeviceExternalSemaphoreInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSemaphoreType</type>        <name>semaphoreType</name></member>
+            <member><type>uint64_t</type>               <name>initialValue</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreTypeCreateInfoKHR"                            alias="VkSemaphoreTypeCreateInfo"/>
+        <type category="struct" name="VkTimelineSemaphoreSubmitInfo" structextends="VkSubmitInfo,VkBindSparseInfo">
+            <member values="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>waitSemaphoreValueCount</name></member>
+            <member optional="true" len="waitSemaphoreValueCount">const <type>uint64_t</type>* <name>pWaitSemaphoreValues</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>signalSemaphoreValueCount</name></member>
+            <member optional="true" len="signalSemaphoreValueCount">const <type>uint64_t</type>* <name>pSignalSemaphoreValues</name></member>
+        </type>
+        <type category="struct" name="VkTimelineSemaphoreSubmitInfoKHR"                        alias="VkTimelineSemaphoreSubmitInfo"/>
+        <type category="struct" name="VkSemaphoreWaitInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkSemaphoreWaitFlags</type> <name>flags</name></member>
+            <member><type>uint32_t</type>               <name>semaphoreCount</name></member>
+            <member len="semaphoreCount">const <type>VkSemaphore</type>* <name>pSemaphores</name></member>
+            <member len="semaphoreCount">const <type>uint64_t</type>*    <name>pValues</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreWaitInfoKHR"                                  alias="VkSemaphoreWaitInfo"/>
+        <type category="struct" name="VkSemaphoreSignalInfo">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkSemaphore</type>            <name>semaphore</name></member>
+            <member><type>uint64_t</type>               <name>value</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreSignalInfoKHR"                                alias="VkSemaphoreSignalInfo"/>
+        <type category="struct" name="VkVertexInputBindingDivisorDescriptionEXT">
+            <member><type>uint32_t</type>          <name>binding</name></member>
+            <member><type>uint32_t</type>          <name>divisor</name></member>
+        </type>
+        <type category="struct" name="VkPipelineVertexInputDivisorStateCreateInfoEXT" structextends="VkPipelineVertexInputStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>vertexBindingDivisorCount</name></member>
+            <member len="vertexBindingDivisorCount">const <type>VkVertexInputBindingDivisorDescriptionEXT</type>*      <name>pVertexBindingDivisors</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxVertexAttribDivisor</name><comment>max value of vertex attribute divisor</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePCIBusInfoPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciDomain</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciBus</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciDevice</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>pciFunction</name></member>
+        </type>
+        <type category="struct" name="VkImportAndroidHardwareBufferInfoANDROID" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member>struct <type>AHardwareBuffer</type>*            <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferUsageANDROID" structextends="VkImageFormatProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>uint64_t</type>                           <name>androidHardwareBufferUsage</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>allocationSize</name></member>
+            <member><type>uint32_t</type>                           <name>memoryTypeBits</name></member>
+        </type>
+        <type category="struct" name="VkMemoryGetAndroidHardwareBufferInfoANDROID">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferFormatPropertiesANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkFormat</type>                           <name>format</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+            <member><type>VkFormatFeatureFlags</type>               <name>formatFeatures</name></member>
+            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceConditionalRenderingInfoEXT" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>conditionalRenderingEnable</name><comment>Whether this secondary command buffer may be executed during an active conditional rendering</comment></member>
+        </type>
+        <type category="struct" name="VkExternalFormatANDROID" structextends="VkImageCreateInfo,VkSamplerYcbcrConversionCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice8BitStorageFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer and Uniform</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant8</name><comment>8-bit integer variables supported in PushConstant</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice8BitStorageFeaturesKHR"                  alias="VkPhysicalDevice8BitStorageFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceConditionalRenderingFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>conditionalRendering</name></member>
+            <member><type>VkBool32</type>                           <name>inheritedConditionalRendering</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkanMemoryModelFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModel</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelDeviceScope</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelAvailabilityVisibilityChains</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"            alias="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicInt64Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferInt64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedInt64Atomics</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"            alias="VkPhysicalDeviceShaderAtomicInt64Features"/>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat32AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat64AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat32AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat64AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageFloat32AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageFloat32Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageFloat32AtomicAdd</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat16Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat16AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat16AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat32AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderBufferFloat64AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat16Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat16AtomicAdd</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat16AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat32AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSharedFloat64AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageFloat32AtomicMinMax</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageFloat32AtomicMinMax</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateDivisor</name></member>
+            <member><type>VkBool32</type>                           <name>vertexAttributeInstanceRateZeroDivisor</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyCheckpointPropertiesNV" structextends="VkQueueFamilyProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*           <name>pNext</name></member>
+            <member><type>VkPipelineStageFlags</type> <name>checkpointExecutionStageMask</name></member>
+        </type>
+        <type category="struct" name="VkCheckpointDataNV" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkPipelineStageFlagBits</type>   <name>stage</name></member>
+            <member noautovalidity="true"><type>void</type>* <name>pCheckpointMarker</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDepthStencilResolveProperties" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>                   <name>supportedDepthResolveModes</name><comment>supported depth resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>                   <name>supportedStencilResolveModes</name><comment>supported stencil resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                             <name>independentResolveNone</name><comment>depth and stencil resolve modes can be set independently if one of them is none</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                             <name>independentResolve</name><comment>depth and stencil resolve modes can be set independently</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR"        alias="VkPhysicalDeviceDepthStencilResolveProperties"/>
+        <type category="struct" name="VkSubpassDescriptionDepthStencilResolve" structextends="VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkResolveModeFlagBits</type>              <name>depthResolveMode</name><comment>depth resolve mode</comment></member>
+            <member noautovalidity="true"><type>VkResolveModeFlagBits</type>              <name>stencilResolveMode</name><comment>stencil resolve mode</comment></member>
+            <member optional="true">const <type>VkAttachmentReference2</type>*            <name>pDepthStencilResolveAttachment</name><comment>depth/stencil resolve attachment</comment></member>
+        </type>
+        <type category="struct" name="VkSubpassDescriptionDepthStencilResolveKHR"              alias="VkSubpassDescriptionDepthStencilResolve"/>
+        <type category="struct" name="VkImageViewASTCDecodeModeEXT" structextends="VkImageViewCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkFormat</type>                         <name>decodeMode</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceASTCDecodeFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>decodeModeSharedExponent</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTransformFeedbackFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>transformFeedback</name></member>
+            <member><type>VkBool32</type>               <name>geometryStreams</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTransformFeedbackPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackStreams</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBuffers</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>           <name>maxTransformFeedbackBufferSize</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackStreamDataSize</name></member>
+            <member limittype="max"><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataSize</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>maxTransformFeedbackBufferDataStride</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackQueries</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackStreamsLinesTriangles</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackRasterizationStreamSelect</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>transformFeedbackDraw</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationStateStreamCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationStateStreamCreateFlagsEXT</type>                 <name>flags</name></member>
+            <member><type>uint32_t</type>                                                                         <name>rasterizationStream</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>representativeFragmentTest</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>representativeFragmentTestEnable</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExclusiveScissorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>exclusiveScissor</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportExclusiveScissorStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                       <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                          <name>exclusiveScissorCount</name></member>
+            <member noautovalidity="true" len="exclusiveScissorCount">const <type>VkRect2D</type>* <name>pExclusiveScissors</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCornerSampledImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>cornerSampledImage</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>computeDerivativeGroupQuads</name></member>
+            <member><type>VkBool32</type>                         <name>computeDerivativeGroupLinear</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentShaderBarycentric</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderImageFootprintFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>imageFootprint</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>dedicatedAllocationImageAliasing</name></member>
+        </type>
+        <type category="struct" name="VkShadingRatePaletteNV">
+            <member><type>uint32_t</type>                                                               <name>shadingRatePaletteEntryCount</name></member>
+            <member len="shadingRatePaletteEntryCount">const <type>VkShadingRatePaletteEntryNV</type>*  <name>pShadingRatePaletteEntries</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportShadingRateImageStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                             <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                <name>shadingRateImageEnable</name></member>
+            <member optional="true"><type>uint32_t</type>                                                <name>viewportCount</name></member>
+            <member noautovalidity="true" len="viewportCount">const <type>VkShadingRatePaletteNV</type>* <name>pShadingRatePalettes</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShadingRateImageFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shadingRateImage</name></member>
+            <member><type>VkBool32</type>                            <name>shadingRateCoarseSampleOrder</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShadingRateImagePropertiesNV" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="noauto"><type>VkExtent2D</type>                          <name>shadingRateTexelSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>shadingRatePaletteSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>shadingRateMaxCoarseSamples</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInvocationMaskFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>invocationMask</name></member>
+        </type>
+        <type category="struct" name="VkCoarseSampleLocationNV">
+            <member><type>uint32_t</type>                            <name>pixelX</name></member>
+            <member><type>uint32_t</type>                            <name>pixelY</name></member>
+            <member><type>uint32_t</type>                            <name>sample</name></member>
+        </type>
+        <type category="struct" name="VkCoarseSampleOrderCustomNV">
+            <member><type>VkShadingRatePaletteEntryNV</type>         <name>shadingRate</name></member>
+            <member><type>uint32_t</type>                            <name>sampleCount</name></member>
+            <member><type>uint32_t</type>                            <name>sampleLocationCount</name></member>
+            <member len="sampleLocationCount">const <type>VkCoarseSampleLocationNV</type>* <name>pSampleLocations</name></member>
+        </type>
+        <type category="struct" name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV" structextends="VkPipelineViewportStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                            <name>pNext</name></member>
+            <member><type>VkCoarseSampleOrderTypeNV</type>                                              <name>sampleOrderType</name></member>
+            <member optional="true"><type>uint32_t</type>                                               <name>customSampleOrderCount</name></member>
+            <member len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>*        <name>pCustomSampleOrders</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMeshShaderFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>taskShader</name></member>
+            <member><type>VkBool32</type>                            <name>meshShader</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMeshShaderPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxDrawMeshTasksCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupInvocations</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskWorkGroupSize</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskTotalMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxTaskOutputCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupInvocations</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshWorkGroupSize</name>[3]</member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshTotalMemorySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputVertices</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshOutputPrimitives</name></member>
+            <member limittype="max"><type>uint32_t</type>                            <name>maxMeshMultiviewViewCount</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                            <name>meshOutputPerVertexGranularity</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                            <name>meshOutputPerPrimitiveGranularity</name></member>
+        </type>
+        <type category="struct" name="VkDrawMeshTasksIndirectCommandNV">
+            <member><type>uint32_t</type>               <name>taskCount</name></member>
+            <member><type>uint32_t</type>               <name>firstTask</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingShaderGroupCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkRayTracingShaderGroupTypeKHR</type> <name>type</name></member>
+            <member><type>uint32_t</type>               <name>generalShader</name></member>
+            <member><type>uint32_t</type>               <name>closestHitShader</name></member>
+            <member><type>uint32_t</type>               <name>anyHitShader</name></member>
+            <member><type>uint32_t</type>               <name>intersectionShader</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingShaderGroupCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkRayTracingShaderGroupTypeKHR</type> <name>type</name></member>
+            <member><type>uint32_t</type>               <name>generalShader</name></member>
+            <member><type>uint32_t</type>               <name>closestHitShader</name></member>
+            <member><type>uint32_t</type>               <name>anyHitShader</name></member>
+            <member><type>uint32_t</type>               <name>intersectionShader</name></member>
+            <member optional="true">const <type>void</type>* <name>pShaderGroupCaptureReplayHandle</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingPipelineCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member><type>uint32_t</type>               <name>stageCount</name></member>
+            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
+            <member><type>uint32_t</type>               <name>groupCount</name></member>
+            <member len="groupCount">const <type>VkRayTracingShaderGroupCreateInfoNV</type>* <name>pGroups</name></member>
+            <member><type>uint32_t</type>               <name>maxRecursionDepth</name></member>
+            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkRayTracingPipelineCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCreateFlags</type>  <name>flags</name><comment>Pipeline creation flags</comment></member>
+            <member optional="true"><type>uint32_t</type> <name>stageCount</name></member>
+            <member len="stageCount">const <type>VkPipelineShaderStageCreateInfo</type>* <name>pStages</name><comment>One entry for each active shader stage</comment></member>
+            <member optional="true"><type>uint32_t</type> <name>groupCount</name></member>
+            <member len="groupCount">const <type>VkRayTracingShaderGroupCreateInfoKHR</type>* <name>pGroups</name></member>
+            <member><type>uint32_t</type>               <name>maxPipelineRayRecursionDepth</name></member>
+            <member optional="true">const <type>VkPipelineLibraryCreateInfoKHR</type>* <name>pLibraryInfo</name></member>
+            <member optional="true">const <type>VkRayTracingPipelineInterfaceCreateInfoKHR</type>* <name>pLibraryInterface</name></member>
+            <member optional="true">const <type>VkPipelineDynamicStateCreateInfo</type>* <name>pDynamicState</name></member>
+            <member><type>VkPipelineLayout</type>       <name>layout</name><comment>Interface layout of the pipeline</comment></member>
+            <member noautovalidity="true" optional="true"><type>VkPipeline</type>      <name>basePipelineHandle</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of</comment></member>
+            <member><type>int32_t</type>                <name>basePipelineIndex</name><comment>If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of</comment></member>
+        </type>
+        <type category="struct" name="VkGeometryTrianglesNV">
+            <member values="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>vertexData</name></member>
+            <member><type>VkDeviceSize</type>               <name>vertexOffset</name></member>
+            <member><type>uint32_t</type>                   <name>vertexCount</name></member>
+            <member><type>VkDeviceSize</type>               <name>vertexStride</name></member>
+            <member><type>VkFormat</type>                   <name>vertexFormat</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>indexData</name></member>
+            <member><type>VkDeviceSize</type>               <name>indexOffset</name></member>
+            <member><type>uint32_t</type>                   <name>indexCount</name></member>
+            <member><type>VkIndexType</type>                <name>indexType</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>transformData</name><comment>Optional reference to array of floats representing a 3x4 row major affine transformation matrix.</comment></member>
+            <member><type>VkDeviceSize</type>               <name>transformOffset</name></member>
+        </type>
+        <type category="struct" name="VkGeometryAABBNV">
+            <member values="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true"><type>VkBuffer</type>   <name>aabbData</name></member>
+            <member><type>uint32_t</type>                   <name>numAABBs</name></member>
+            <member><type>uint32_t</type>                   <name>stride</name><comment>Stride in bytes between AABBs</comment></member>
+            <member><type>VkDeviceSize</type>               <name>offset</name><comment>Offset in bytes of the first AABB in aabbData</comment></member>
+        </type>
+        <type category="struct" name="VkGeometryDataNV">
+            <member><type>VkGeometryTrianglesNV</type>                  <name>triangles</name></member>
+            <member><type>VkGeometryAABBNV</type>                       <name>aabbs</name></member>
+        </type>
+        <type category="struct" name="VkGeometryNV">
+            <member values="VK_STRUCTURE_TYPE_GEOMETRY_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
+            <member><type>VkGeometryTypeKHR</type>                  <name>geometryType</name></member>
+            <member><type>VkGeometryDataNV</type>                              <name>geometry</name></member>
+            <member optional="true"><type>VkGeometryFlagsKHR</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureInfoNV">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureTypeNV</type>         <name>type</name></member>
+            <member optional="true"><type>VkBuildAccelerationStructureFlagsNV</type><name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>instanceCount</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>geometryCount</name></member>
+            <member len="geometryCount">const <type>VkGeometryNV</type>* <name>pGeometries</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureCreateInfoNV">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                           <name>compactedSize</name></member>
+            <member><type>VkAccelerationStructureInfoNV</type>          <name>info</name></member>
+        </type>
+        <type category="struct" name="VkBindAccelerationStructureMemoryInfoNV">
+            <member values="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member><type>VkAccelerationStructureNV</type>       <name>accelerationStructure</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                     <name>memoryOffset</name></member>
+            <member optional="true"><type>uint32_t</type>         <name>deviceIndexCount</name></member>
+            <member len="deviceIndexCount">const <type>uint32_t</type>*  <name>pDeviceIndices</name></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSetAccelerationStructureKHR" structextends="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>accelerationStructureCount</name></member>
+            <member optional="false,true" len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></member>
+        </type>
+        <type category="struct" name="VkWriteDescriptorSetAccelerationStructureNV" structextends="VkWriteDescriptorSet">
+            <member values="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>accelerationStructureCount</name></member>
+            <member optional="false,true" len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMemoryRequirementsInfoNV">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>VkAccelerationStructureMemoryRequirementsTypeNV</type>                     <name>type</name></member>
+            <member><type>VkAccelerationStructureNV</type>                                           <name>accelerationStructure</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAccelerationStructureFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructure</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructureCaptureReplay</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructureIndirectBuild</name></member>
+            <member><type>VkBool32</type>                         <name>accelerationStructureHostCommands</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingAccelerationStructureUpdateAfterBind</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipeline</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipelineShaderGroupHandleCaptureReplay</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipelineShaderGroupHandleCaptureReplayMixed</name></member>
+            <member><type>VkBool32</type>                         <name>rayTracingPipelineTraceRaysIndirect</name></member>
+            <member><type>VkBool32</type>                         <name>rayTraversalPrimitiveCulling</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayQueryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>rayQuery</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceAccelerationStructurePropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxGeometryCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxInstanceCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxPrimitiveCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorAccelerationStructures</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindAccelerationStructures</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetAccelerationStructures</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindAccelerationStructures</name></member>
+            <member limittype="min"><type>uint32_t</type>                         <name>minAccelerationStructureScratchOffsetAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingPipelinePropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>shaderGroupHandleSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRayRecursionDepth</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxShaderGroupStride</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>shaderGroupBaseAlignment</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>shaderGroupHandleCaptureReplaySize</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRayDispatchInvocationCount</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>shaderGroupHandleAlignment</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRayHitAttributeSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>shaderGroupHandleSize</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxRecursionDepth</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxShaderGroupStride</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>shaderGroupBaseAlignment</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxGeometryCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxInstanceCount</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxTriangleCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetAccelerationStructures</name></member>
+        </type>
+        <type category="struct" name="VkStridedDeviceAddressRegionKHR">
+            <member optional="true"><type>VkDeviceAddress</type>  <name>deviceAddress</name></member>
+            <member><type>VkDeviceSize</type>                     <name>stride</name></member>
+            <member><type>VkDeviceSize</type>                     <name>size</name></member>
+        </type>
+        <type category="struct" name="VkTraceRaysIndirectCommandKHR">
+            <member><type>uint32_t</type>               <name>width</name></member>
+            <member><type>uint32_t</type>               <name>height</name></member>
+            <member><type>uint32_t</type>               <name>depth</name></member>
+        </type>
+        <type category="struct" name="VkDrmFormatModifierPropertiesListEXT" returnedonly="true" structextends="VkFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
+            <member optional="true,false" len="drmFormatModifierCount"><type>VkDrmFormatModifierPropertiesEXT</type>* <name>pDrmFormatModifierProperties</name></member>
+        </type>
+        <type category="struct" name="VkDrmFormatModifierPropertiesEXT" returnedonly="true">
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
+            <member><type>VkFormatFeatureFlags</type> <name>drmFormatModifierTilingFeatures</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member><type>VkSharingMode</type> <name>sharingMode</name></member>
+            <member optional="true"><type>uint32_t</type> <name>queueFamilyIndexCount</name></member>
+            <member noautovalidity="true" len="queueFamilyIndexCount">const <type>uint32_t</type>* <name>pQueueFamilyIndices</name></member>
+        </type>
+        <type category="struct" name="VkImageDrmFormatModifierListCreateInfoEXT" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
+            <member len="drmFormatModifierCount">const <type>uint64_t</type>* <name>pDrmFormatModifiers</name></member>
+        </type>
+        <type category="struct" name="VkImageDrmFormatModifierExplicitCreateInfoEXT" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member optional="false"><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
+            <member len="drmFormatModifierPlaneCount">const <type>VkSubresourceLayout</type>* <name>pPlaneLayouts</name></member>
+        </type>
+        <type category="struct" name="VkImageDrmFormatModifierPropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+        </type>
+        <type category="struct" name="VkImageStencilUsageCreateInfo" structextends="VkImageCreateInfo,VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImageUsageFlags</type> <name>stencilUsage</name></member>
+        </type>
+        <type category="struct" name="VkImageStencilUsageCreateInfoEXT"                        alias="VkImageStencilUsageCreateInfo"/>
+        <type category="struct" name="VkDeviceMemoryOverallocationCreateInfoAMD"  structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkMemoryOverallocationBehaviorAMD</type> <name>overallocationBehavior</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMap</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMapDynamic</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMapNonSubsampledImages</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMap2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>fragmentDensityMapDeferred</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member limittype="min"><type>VkExtent2D</type>                       <name>minFragmentDensityTexelSize</name></member>
+            <member limittype="max"><type>VkExtent2D</type>                       <name>maxFragmentDensityTexelSize</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>fragmentDensityInvocations</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentDensityMap2PropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                       <name>subsampledLoads</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                       <name>subsampledCoarseReconstructionEarlyAccess</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxSubsampledArrayLayers</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>maxDescriptorSetSubsampledSamplers</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassFragmentDensityMapCreateInfoEXT" structextends="VkRenderPassCreateInfo,VkRenderPassCreateInfo2">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkAttachmentReference</type>            <name>fragmentDensityMapAttachment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceScalarBlockLayoutFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>scalarBlockLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"            alias="VkPhysicalDeviceScalarBlockLayoutFeatures"/>
+        <type category="struct" name="VkSurfaceProtectedCapabilitiesKHR" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>supportsProtected</name><comment>Represents if surface can be protected</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceUniformBufferStandardLayoutFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>uniformBufferStandardLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"  alias="VkPhysicalDeviceUniformBufferStandardLayoutFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceDepthClipEnableFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>depthClipEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationDepthClipStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                 <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineRasterizationDepthClipStateCreateFlagsEXT</type>         <name>flags</name><comment>Reserved</comment></member>
+            <member><type>VkBool32</type>                                                                    <name>depthClipEnable</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryBudgetPropertiesEXT" structextends="VkPhysicalDeviceMemoryProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>heapBudget</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
+            <member><type>VkDeviceSize</type>                       <name>heapUsage</name>[<enum>VK_MAX_MEMORY_HEAPS</enum>]</member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMemoryPriorityFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>memoryPriority</name></member>
+        </type>
+        <type category="struct" name="VkMemoryPriorityAllocateInfoEXT" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>float</type>                              <name>priority</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>pageableDeviceLocalMemory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddress</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressCaptureReplay</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressMultiDevice</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"          alias="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
+        <type category="struct" name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddress</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressCaptureReplay</name></member>
+            <member><type>VkBool32</type>                           <name>bufferDeviceAddressMultiDevice</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBufferAddressFeaturesEXT"                alias="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
+        <type category="struct" name="VkBufferDeviceAddressInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkBuffer</type>                                               <name>buffer</name></member>
+        </type>
+        <type category="struct" name="VkBufferDeviceAddressInfoKHR"                            alias="VkBufferDeviceAddressInfo"/>
+        <type category="struct" name="VkBufferDeviceAddressInfoEXT"                            alias="VkBufferDeviceAddressInfo"/>
+        <type category="struct" name="VkBufferOpaqueCaptureAddressCreateInfo" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>uint64_t</type>                         <name>opaqueCaptureAddress</name></member>
+        </type>
+        <type category="struct" name="VkBufferOpaqueCaptureAddressCreateInfoKHR"               alias="VkBufferOpaqueCaptureAddressCreateInfo"/>
+        <type category="struct" name="VkBufferDeviceAddressCreateInfoEXT" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceAddress</type>                  <name>deviceAddress</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageViewImageFormatInfoEXT" structextends="VkPhysicalDeviceImageFormatInfo2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkImageViewType</type>                  <name>imageViewType</name></member>
+        </type>
+        <type category="struct" name="VkFilterCubicImageViewImageFormatPropertiesEXT" returnedonly="true" structextends="VkImageFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>filterCubic</name><comment>The combinations of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT</comment></member>
+            <member><type>VkBool32</type>                         <name>filterCubicMinmax</name><comment>The combination of format, image type (and image view type if provided) can be filtered with VK_FILTER_CUBIC_EXT and ReductionMode of Min or Max</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImagelessFramebufferFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                    <name>pNext</name></member>
+            <member><type>VkBool32</type>                                 <name>imagelessFramebuffer</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImagelessFramebufferFeaturesKHR"         alias="VkPhysicalDeviceImagelessFramebufferFeatures"/>
+        <type category="struct" name="VkFramebufferAttachmentsCreateInfo" structextends="VkFramebufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                 <name>attachmentImageInfoCount</name></member>
+            <member len="attachmentImageInfoCount">const <type>VkFramebufferAttachmentImageInfo</type>* <name>pAttachmentImageInfos</name></member>
+        </type>
+        <type category="struct" name="VkFramebufferAttachmentsCreateInfoKHR"                   alias="VkFramebufferAttachmentsCreateInfo"/>
+        <type category="struct" name="VkFramebufferAttachmentImageInfo">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>VkImageCreateFlags</type>       <name>flags</name><comment>Image creation flags</comment></member>
+            <member><type>VkImageUsageFlags</type>                        <name>usage</name><comment>Image usage flags</comment></member>
+            <member><type>uint32_t</type>                                 <name>width</name></member>
+            <member><type>uint32_t</type>                                 <name>height</name></member>
+            <member><type>uint32_t</type>                                 <name>layerCount</name></member>
+            <member optional="true"><type>uint32_t</type>                 <name>viewFormatCount</name></member>
+            <member len="viewFormatCount">const <type>VkFormat</type>*    <name>pViewFormats</name></member>
+        </type>
+        <type category="struct" name="VkFramebufferAttachmentImageInfoKHR"                     alias="VkFramebufferAttachmentImageInfo"/>
+        <type category="struct" name="VkRenderPassAttachmentBeginInfo" structextends="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                 <name>attachmentCount</name></member>
+            <member len="attachmentCount">const <type>VkImageView</type>* <name>pAttachments</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassAttachmentBeginInfoKHR"                      alias="VkRenderPassAttachmentBeginInfo"/>
+        <type category="struct" name="VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkBool32</type>               <name>textureCompressionASTC_HDR</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>cooperativeMatrix</name></member>
+            <member><type>VkBool32</type>                            <name>cooperativeMatrixRobustBufferAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCooperativeMatrixPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkShaderStageFlags</type>                  <name>cooperativeMatrixSupportedStages</name></member>
+        </type>
+        <type category="struct" name="VkCooperativeMatrixPropertiesNV">
+            <member values="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>MSize</name></member>
+            <member><type>uint32_t</type>                            <name>NSize</name></member>
+            <member><type>uint32_t</type>                            <name>KSize</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>AType</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>BType</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>CType</name></member>
+            <member><type>VkComponentTypeNV</type>                   <name>DType</name></member>
+            <member><type>VkScopeNV</type>                           <name>scope</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>ycbcrImageArrays</name></member>
+        </type>
+        <type category="struct" name="VkImageViewHandleInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkImageView</type>                         <name>imageView</name></member>
+            <member><type>VkDescriptorType</type>                    <name>descriptorType</name></member>
+            <member optional="true"><type>VkSampler</type>           <name>sampler</name></member>
+        </type>
+        <type category="struct" name="VkImageViewAddressPropertiesNVX" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkDeviceAddress</type>    <name>deviceAddress</name></member>
+            <member><type>VkDeviceSize</type>       <name>size</name></member>
+        </type>
+        <type category="struct" name="VkPresentFrameTokenGGP" structextends="VkPresentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>GgpFrameToken</type>                    <name>frameToken</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCreationFeedbackEXT" returnedonly="true">
+            <member><type>VkPipelineCreationFeedbackFlagsEXT</type>  <name>flags</name></member>
+            <member><type>uint64_t</type>                            <name>duration</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCreationFeedbackCreateInfoEXT" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo,VkRayTracingPipelineCreateInfoNV,VkRayTracingPipelineCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkPipelineCreationFeedbackEXT</type>*      <name>pPipelineCreationFeedback</name><comment>Output pipeline creation feedback.</comment></member>
+            <member><type>uint32_t</type>                            <name>pipelineStageCreationFeedbackCount</name></member>
+            <member len="pipelineStageCreationFeedbackCount"><type>VkPipelineCreationFeedbackEXT</type>* <name>pPipelineStageCreationFeedbacks</name><comment>One entry for each shader stage specified in the parent Vk*PipelineCreateInfo struct</comment></member>
+        </type>
+        <type category="struct" name="VkSurfaceFullScreenExclusiveInfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkFullScreenExclusiveEXT</type>         <name>fullScreenExclusive</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceFullScreenExclusiveWin32InfoEXT" structextends="VkPhysicalDeviceSurfaceInfo2KHR,VkSwapchainCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>HMONITOR</type>         <name>hmonitor</name></member>
+        </type>
+        <type category="struct" name="VkSurfaceCapabilitiesFullScreenExclusiveEXT" structextends="VkSurfaceCapabilities2KHR">
+            <member values="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>         <name>fullScreenExclusiveSupported</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePerformanceQueryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>performanceCounterQueryPools</name><comment>performance counters supported in query pools</comment></member>
+            <member><type>VkBool32</type>                         <name>performanceCounterMultipleQueryPools</name><comment>performance counters from multiple query pools can be accessed in the same primary command buffer</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePerformanceQueryPropertiesKHR" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkBool32</type> <name>allowCommandBufferQueryCopies</name><comment>Flag to specify whether performance queries are allowed to be used in vkCmdCopyQueryPoolResults</comment></member>
+        </type>
+        <type category="struct" name="VkPerformanceCounterKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkPerformanceCounterUnitKHR</type>        <name>unit</name></member>
+            <member><type>VkPerformanceCounterScopeKHR</type>       <name>scope</name></member>
+            <member><type>VkPerformanceCounterStorageKHR</type>     <name>storage</name></member>
+            <member><type>uint8_t</type> <name>uuid</name>[<enum>VK_UUID_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkPerformanceCounterDescriptionKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                   <name>pNext</name></member>
+            <member optional="true"><type>VkPerformanceCounterDescriptionFlagsKHR</type> <name>flags</name></member>
+            <member><type>char</type>                                    <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>                                    <name>category</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>                                    <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkQueryPoolPerformanceCreateInfoKHR" structextends="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member><type>uint32_t</type>                                <name>queueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                                <name>counterIndexCount</name></member>
+            <member len="counterIndexCount">const <type>uint32_t</type>* <name>pCounterIndices</name></member>
+        </type>
+        <type category="union" name="VkPerformanceCounterResultKHR" comment="// Union of all the possible return types a counter result could return">
+            <member><type>int32_t</type>  <name>int32</name></member>
+            <member><type>int64_t</type>  <name>int64</name></member>
+            <member><type>uint32_t</type> <name>uint32</name></member>
+            <member><type>uint64_t</type> <name>uint64</name></member>
+            <member><type>float</type>    <name>float32</name></member>
+            <member><type>double</type>   <name>float64</name></member>
+        </type>
+        <type category="struct" name="VkAcquireProfilingLockInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkAcquireProfilingLockFlagsKHR</type> <name>flags</name><comment>Acquire profiling lock flags</comment></member>
+            <member><type>uint64_t</type> <name>timeout</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceQuerySubmitInfoKHR" structextends="VkSubmitInfo,VkSubmitInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*         <name>pNext</name></member>
+            <member><type>uint32_t</type>            <name>counterPassIndex</name><comment>Index for which counter pass to submit</comment></member>
+        </type>
+        <type category="struct" name="VkHeadlessSurfaceCreateInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkHeadlessSurfaceCreateFlagsEXT</type>   <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCoverageReductionModeFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>coverageReductionMode</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCoverageReductionStateCreateInfoNV" structextends="VkPipelineMultisampleStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCoverageReductionStateCreateFlagsNV</type>      <name>flags</name></member>
+            <member><type>VkCoverageReductionModeNV</type>                                          <name>coverageReductionMode</name></member>
+        </type>
+        <type category="struct" name="VkFramebufferMixedSamplesCombinationNV" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkCoverageReductionModeNV</type>  <name>coverageReductionMode</name></member>
+            <member><type>VkSampleCountFlagBits</type>      <name>rasterizationSamples</name></member>
+            <member><type>VkSampleCountFlags</type>         <name>depthStencilSamples</name></member>
+            <member><type>VkSampleCountFlags</type>         <name>colorSamples</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>shaderIntegerFunctions2</name></member>
+        </type>
+        <type category="union" name="VkPerformanceValueDataINTEL">
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"><type>uint32_t</type>                           <name>value32</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"><type>uint64_t</type>                           <name>value64</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"><type>float</type>                               <name>valueFloat</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"><type>VkBool32</type>                             <name>valueBool</name></member>
+            <member selection="VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL" len="null-terminated">const <type>char</type>*  <name>valueString</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceValueINTEL">
+            <member><type>VkPerformanceValueTypeINTEL</type>        <name>type</name></member>
+            <member selector="type" noautovalidity="true"><type>VkPerformanceValueDataINTEL</type>        <name>data</name></member>
+        </type>
+        <type category="struct" name="VkInitializePerformanceApiInfoINTEL" >
+            <member values="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member optional="true"><type>void</type>*               <name>pUserData</name></member>
+        </type>
+        <type category="struct" name="VkQueryPoolPerformanceQueryCreateInfoINTEL" structextends="VkQueryPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkQueryPoolSamplingModeINTEL</type>        <name>performanceCountersSampling</name></member>
+        </type>
+        <type category="struct" name="VkQueryPoolCreateInfoINTEL"                              alias="VkQueryPoolPerformanceQueryCreateInfoINTEL"/>
+        <type category="struct" name="VkPerformanceMarkerInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>uint64_t</type>                            <name>marker</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceStreamMarkerInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                            <name>marker</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceOverrideInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkPerformanceOverrideTypeINTEL</type>      <name>type</name></member>
+            <member><type>VkBool32</type>                            <name>enable</name></member>
+            <member><type>uint64_t</type>                            <name>parameter</name></member>
+        </type>
+        <type category="struct" name="VkPerformanceConfigurationAcquireInfoINTEL">
+            <member values="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                         <name>pNext</name></member>
+            <member><type>VkPerformanceConfigurationTypeINTEL</type> <name>type</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderClockFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderSubgroupClock</name></member>
+            <member><type>VkBool32</type>                            <name>shaderDeviceClock</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceIndexTypeUint8FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>indexTypeUint8</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>shaderSMCount</name></member>
+            <member limittype="max"><type>uint32_t</type>                       <name>shaderWarpsPerSM</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>shaderSMBuiltins</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member><type>VkBool32</type>               <name>fragmentShaderSampleInterlock</name></member>
+            <member><type>VkBool32</type>               <name>fragmentShaderPixelInterlock</name></member>
+            <member><type>VkBool32</type>               <name>fragmentShaderShadingRateInterlock</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>separateDepthStencilLayouts</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"  alias="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"/>
+        <type category="struct" name="VkAttachmentReferenceStencilLayout" structextends="VkAttachmentReference2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkImageLayout</type>                  <name>stencilLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>primitiveTopologyListRestart</name></member>
+            <member><type>VkBool32</type>                     <name>primitiveTopologyPatchListRestart</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentReferenceStencilLayoutKHR"                   alias="VkAttachmentReferenceStencilLayout"/>
+        <type category="struct" name="VkAttachmentDescriptionStencilLayout" structextends="VkAttachmentDescription2">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkImageLayout</type>                  <name>stencilInitialLayout</name></member>
+            <member><type>VkImageLayout</type>                  <name>stencilFinalLayout</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentDescriptionStencilLayoutKHR"                 alias="VkAttachmentDescriptionStencilLayout"/>
+        <type category="struct" name="VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>           <name>pipelineExecutableInfo</name></member>
+        </type>
+        <type category="struct" name="VkPipelineInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkPipeline</type>         <name>pipeline</name></member>
+        </type>
+        <type category="struct" name="VkPipelineExecutablePropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkShaderStageFlags</type> <name>stages</name></member>
+            <member><type>char</type>               <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>               <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>uint32_t</type>           <name>subgroupSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineExecutableInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkPipeline</type>         <name>pipeline</name></member>
+            <member><type>uint32_t</type>           <name>executableIndex</name></member>
+        </type>
+        <type category="union" name="VkPipelineExecutableStatisticValueKHR" returnedonly="true">
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"><type>VkBool32</type>           <name>b32</name></member>
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"><type>int64_t</type>            <name>i64</name></member>
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"><type>uint64_t</type>           <name>u64</name></member>
+            <member selection="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"><type>double</type>             <name>f64</name></member>
+        </type>
+        <type category="struct" name="VkPipelineExecutableStatisticKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>char</type>               <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>               <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>VkPipelineExecutableStatisticFormatKHR</type> <name>format</name></member>
+            <member selector="format" noautovalidity="true"><type>VkPipelineExecutableStatisticValueKHR</type>  <name>value</name></member>
+        </type>
+        <type category="struct" name="VkPipelineExecutableInternalRepresentationKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>char</type>               <name>name</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>               <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>VkBool32</type>           <name>isText</name></member>
+            <member><type>size_t</type>             <name>dataSize</name></member>
+            <member optional="true" len="dataSize"><type>void</type>* <name>pData</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>shaderDemoteToHelperInvocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>texelBufferAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>                       <name>storageTexelBufferOffsetAlignmentBytes</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                           <name>storageTexelBufferOffsetSingleTexelAlignment</name></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>                       <name>uniformTexelBufferOffsetAlignmentBytes</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                           <name>uniformTexelBufferOffsetSingleTexelAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>subgroupSizeControl</name></member>
+            <member><type>VkBool32</type> <name>computeFullSubgroups</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubgroupSizeControlPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                          <name>pNext</name></member>
+            <member limittype="min" noautovalidity="true"><type>uint32_t</type> <name>minSubgroupSize</name><comment>The minimum subgroup size supported by this device</comment></member>
+            <member limittype="max" noautovalidity="true"><type>uint32_t</type> <name>maxSubgroupSize</name><comment>The maximum subgroup size supported by this device</comment></member>
+            <member limittype="max" noautovalidity="true"><type>uint32_t</type> <name>maxComputeWorkgroupSubgroups</name><comment>The maximum number of subgroups supported in a workgroup</comment></member>
+            <member limittype="bitmask"><type>VkShaderStageFlags</type>             <name>requiredSubgroupSizeStages</name><comment>The shader stages that support specifying a subgroup size</comment></member>
+        </type>
+        <type category="struct" name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT" returnedonly="true" structextends="VkPipelineShaderStageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>uint32_t</type>               <name>requiredSubgroupSize</name></member>
+        </type>
+        <type category="struct" name="VkSubpassShadingPipelineCreateInfoHUAWEI" returnedonly="true" structextends="VkComputePipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkRenderPass</type>           <name>renderPass</name></member>
+            <member><type>uint32_t</type>               <name>subpass</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubpassShadingPropertiesHUAWEI" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>maxSubpassShadingWorkgroupSizeAspectRatio</name></member>
+        </type>
+        <type category="struct" name="VkMemoryOpaqueCaptureAddressAllocateInfo" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member><type>uint64_t</type>                      <name>opaqueCaptureAddress</name></member>
+        </type>
+        <type category="struct" name="VkMemoryOpaqueCaptureAddressAllocateInfoKHR"             alias="VkMemoryOpaqueCaptureAddressAllocateInfo"/>
+        <type category="struct" name="VkDeviceMemoryOpaqueCaptureAddressInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                   <name>memory</name></member>
+        </type>
+        <type category="struct" name="VkDeviceMemoryOpaqueCaptureAddressInfoKHR"               alias="VkDeviceMemoryOpaqueCaptureAddressInfo"/>
+        <type category="struct" name="VkPhysicalDeviceLineRasterizationFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>rectangularLines</name></member>
+            <member><type>VkBool32</type>                           <name>bresenhamLines</name></member>
+            <member><type>VkBool32</type>                           <name>smoothLines</name></member>
+            <member><type>VkBool32</type>                           <name>stippledRectangularLines</name></member>
+            <member><type>VkBool32</type>                           <name>stippledBresenhamLines</name></member>
+            <member><type>VkBool32</type>                           <name>stippledSmoothLines</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceLineRasterizationPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                            <name>lineSubPixelPrecisionBits</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationLineStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                      <name>pNext</name></member>
+            <member><type>VkLineRasterizationModeEXT</type>                                       <name>lineRasterizationMode</name></member>
+            <member><type>VkBool32</type>                                                         <name>stippledLineEnable</name></member>
+            <member><type>uint32_t</type>                                                         <name>lineStippleFactor</name></member>
+            <member><type>uint16_t</type>                                                         <name>lineStipplePattern</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                         <name>pipelineCreationCacheControl</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan11Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer16BitAccess</name><comment>16-bit integer/floating-point variables supported in BufferBlock and Block</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant16</name><comment>16-bit integer/floating-point variables supported in PushConstant</comment></member>
+            <member><type>VkBool32</type>                         <name>storageInputOutput16</name><comment>16-bit integer/floating-point variables supported in shader inputs and outputs</comment></member>
+            <member><type>VkBool32</type>                         <name>multiview</name><comment>Multiple views in a renderpass</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewGeometryShader</name><comment>Multiple views in a renderpass w/ geometry shader</comment></member>
+            <member><type>VkBool32</type>                         <name>multiviewTessellationShader</name><comment>Multiple views in a renderpass w/ tessellation shader</comment></member>
+            <member><type>VkBool32</type>                         <name>variablePointersStorageBuffer</name></member>
+            <member><type>VkBool32</type>                         <name>variablePointers</name></member>
+            <member><type>VkBool32</type>                         <name>protectedMemory</name></member>
+            <member><type>VkBool32</type>                         <name>samplerYcbcrConversion</name><comment>Sampler color conversion supported</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderDrawParameters</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan11Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*      <name>pNext</name></member>
+            <member limittype="noauto"><type>uint8_t</type>                          <name>deviceUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>                          <name>driverUUID</name>[<enum>VK_UUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint8_t</type>                          <name>deviceLUID</name>[<enum>VK_LUID_SIZE</enum>]</member>
+            <member limittype="noauto"><type>uint32_t</type>                         <name>deviceNodeMask</name></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>deviceLUIDValid</name></member>
+            <member limittype="noauto" noautovalidity="true"><type>uint32_t</type>                      <name>subgroupSize</name><comment>The size of a subgroup for this queue.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkShaderStageFlags</type>            <name>subgroupSupportedStages</name><comment>Bitfield of what shader stages support subgroup operations</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkSubgroupFeatureFlags</type>        <name>subgroupSupportedOperations</name><comment>Bitfield of what subgroup operations are supported.</comment></member>
+            <member limittype="bitmask" noautovalidity="true"><type>VkBool32</type>                      <name>subgroupQuadOperationsInAllStages</name><comment>Flag to specify whether quad operations are available in all stages.</comment></member>
+            <member limittype="noauto"><type>VkPointClippingBehavior</type>          <name>pointClippingBehavior</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewViewCount</name><comment>max number of views in a subpass</comment></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxMultiviewInstanceIndex</name><comment>max instance index for a draw in a multiview subpass</comment></member>
+            <member limittype="noauto"><type>VkBool32</type>                         <name>protectedNoFault</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerSetDescriptors</name></member>
+            <member limittype="max"><type>VkDeviceSize</type>                     <name>maxMemoryAllocationSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan12Features" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                         <name>samplerMirrorClampToEdge</name></member>
+            <member><type>VkBool32</type>                         <name>drawIndirectCount</name></member>
+            <member><type>VkBool32</type>                         <name>storageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer</comment></member>
+            <member><type>VkBool32</type>                         <name>uniformAndStorageBuffer8BitAccess</name><comment>8-bit integer variables supported in StorageBuffer and Uniform</comment></member>
+            <member><type>VkBool32</type>                         <name>storagePushConstant8</name><comment>8-bit integer variables supported in PushConstant</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderBufferInt64Atomics</name></member>
+            <member><type>VkBool32</type>                         <name>shaderSharedInt64Atomics</name></member>
+            <member><type>VkBool32</type>                         <name>shaderFloat16</name><comment>16-bit floats (halfs) in shaders</comment></member>
+            <member><type>VkBool32</type>                         <name>shaderInt8</name><comment>8-bit integers in shaders</comment></member>
+            <member><type>VkBool32</type>                         <name>descriptorIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderInputAttachmentArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderUniformTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageTexelBufferArrayDynamicIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderUniformBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderSampledImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageImageArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderInputAttachmentArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderUniformTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>shaderStorageTexelBufferArrayNonUniformIndexing</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingUniformBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingSampledImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingStorageImageUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingStorageBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingUniformTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingStorageTexelBufferUpdateAfterBind</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingUpdateUnusedWhilePending</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingPartiallyBound</name></member>
+            <member><type>VkBool32</type>                         <name>descriptorBindingVariableDescriptorCount</name></member>
+            <member><type>VkBool32</type>                         <name>runtimeDescriptorArray</name></member>
+            <member><type>VkBool32</type>                         <name>samplerFilterMinmax</name></member>
+            <member><type>VkBool32</type>                         <name>scalarBlockLayout</name></member>
+            <member><type>VkBool32</type>                         <name>imagelessFramebuffer</name></member>
+            <member><type>VkBool32</type>                         <name>uniformBufferStandardLayout</name></member>
+            <member><type>VkBool32</type>                         <name>shaderSubgroupExtendedTypes</name></member>
+            <member><type>VkBool32</type>                         <name>separateDepthStencilLayouts</name></member>
+            <member><type>VkBool32</type>                         <name>hostQueryReset</name></member>
+            <member><type>VkBool32</type>                         <name>timelineSemaphore</name></member>
+            <member><type>VkBool32</type>                         <name>bufferDeviceAddress</name></member>
+            <member><type>VkBool32</type>                         <name>bufferDeviceAddressCaptureReplay</name></member>
+            <member><type>VkBool32</type>                         <name>bufferDeviceAddressMultiDevice</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModel</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelDeviceScope</name></member>
+            <member><type>VkBool32</type>                         <name>vulkanMemoryModelAvailabilityVisibilityChains</name></member>
+            <member><type>VkBool32</type>                         <name>shaderOutputViewportIndex</name></member>
+            <member><type>VkBool32</type>                         <name>shaderOutputLayer</name></member>
+            <member><type>VkBool32</type>                         <name>subgroupBroadcastDynamicId</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVulkan12Properties" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member limittype="noauto"><type>VkDriverId</type>                       <name>driverID</name></member>
+            <member limittype="noauto"><type>char</type>                             <name>driverName</name>[<enum>VK_MAX_DRIVER_NAME_SIZE</enum>]</member>
+            <member limittype="noauto"><type>char</type>                             <name>driverInfo</name>[<enum>VK_MAX_DRIVER_INFO_SIZE</enum>]</member>
+            <member limittype="noauto"><type>VkConformanceVersion</type>             <name>conformanceVersion</name></member>
+            <member limittype="noauto"><type>VkShaderFloatControlsIndependence</type><name>denormBehaviorIndependence</name></member>
+            <member limittype="noauto"><type>VkShaderFloatControlsIndependence</type><name>roundingModeIndependence</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat16</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat32</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSignedZeroInfNanPreserveFloat64</name><comment>An implementation can preserve signed zero, nan, inf</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat16</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat32</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormPreserveFloat64</name><comment>An implementation can preserve  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat16</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat32</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderDenormFlushToZeroFloat64</name><comment>An implementation can flush to zero  denormals</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat16</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat32</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTEFloat64</name><comment>An implementation can support RTE</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat16</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat32</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderRoundingModeRTZFloat64</name><comment>An implementation can support RTZ</comment></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxUpdateAfterBindDescriptorsInAllPools</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderUniformBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderSampledImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderStorageBufferArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderStorageImageArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>shaderInputAttachmentArrayNonUniformIndexingNative</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>robustBufferAccessUpdateAfterBind</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>quadDivergentImplicitLod</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageDescriptorUpdateAfterBindInputAttachments</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxPerStageUpdateAfterBindResources</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindSamplers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindUniformBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindUniformBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindStorageBuffers</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindStorageBuffersDynamic</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindSampledImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindStorageImages</name></member>
+            <member limittype="max"><type>uint32_t</type>                         <name>maxDescriptorSetUpdateAfterBindInputAttachments</name></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>               <name>supportedDepthResolveModes</name><comment>supported depth resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkResolveModeFlags</type>               <name>supportedStencilResolveModes</name><comment>supported stencil resolve modes</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>independentResolveNone</name><comment>depth and stencil resolve modes can be set independently if one of them is none</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>independentResolve</name><comment>depth and stencil resolve modes can be set independently</comment></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>filterMinmaxSingleComponentFormats</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                         <name>filterMinmaxImageComponentMapping</name></member>
+            <member limittype="max"><type>uint64_t</type>                         <name>maxTimelineSemaphoreValueDifference</name></member>
+            <member limittype="bitmask" optional="true"><type>VkSampleCountFlags</type> <name>framebufferIntegerColorSampleCounts</name></member>
+        </type>
+        <type category="struct" name="VkPipelineCompilerControlCreateInfoAMD" structextends="VkGraphicsPipelineCreateInfo,VkComputePipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"><type>VkStructureType</type>   <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                            <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineCompilerControlFlagsAMD</type>                                      <name>compilerControlFlags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCoherentMemoryFeaturesAMD" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>deviceCoherentMemory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceToolPropertiesEXT" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member><type>char</type>            <name>name</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
+            <member><type>char</type>            <name>version</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
+            <member><type>VkToolPurposeFlagsEXT</type> <name>purposes</name></member>
+            <member><type>char</type>            <name>description</name>[<enum>VK_MAX_DESCRIPTION_SIZE</enum>]</member>
+            <member><type>char</type>            <name>layer</name>[<enum>VK_MAX_EXTENSION_NAME_SIZE</enum>]</member>
+        </type>
+        <type category="struct" name="VkSamplerCustomBorderColorCreateInfoEXT" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkClearColorValue</type>                                                                      <name>customBorderColor</name></member>
+            <member><type>VkFormat</type>                                                                               <name>format</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCustomBorderColorPropertiesEXT" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                                                                   <name>pNext</name></member>
+            <member limittype="max"><type>uint32_t</type>                                                                                      <name>maxCustomBorderColorSamplers</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceCustomBorderColorFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>customBorderColors</name></member>
+            <member><type>VkBool32</type>                           <name>customBorderColorWithoutFormat</name></member>
+        </type>
+        <type category="struct" name="VkSamplerBorderColorComponentMappingCreateInfoEXT" structextends="VkSamplerCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                       <name>pNext</name></member>
+            <member><type>VkComponentMapping</type>                                                                                <name>components</name></member>
+            <member><type>VkBool32</type>                                                                                          <name>srgb</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceBorderColorSwizzleFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>borderColorSwizzle</name></member>
+            <member><type>VkBool32</type>                     <name>borderColorSwizzleFromImage</name></member>
+        </type>
+        <type category="union" name="VkDeviceOrHostAddressKHR">
+            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
+            <member noautovalidity="true"><type>void</type>*                      <name>hostAddress</name></member>
+        </type>
+        <type category="union" name="VkDeviceOrHostAddressConstKHR">
+            <member noautovalidity="true"><type>VkDeviceAddress</type>            <name>deviceAddress</name></member>
+            <member noautovalidity="true">const <type>void</type>*                <name>hostAddress</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryTrianglesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member><type>VkFormat</type>                                      <name>vertexFormat</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>vertexData</name></member>
+            <member><type>VkDeviceSize</type>                                  <name>vertexStride</name></member>
+            <member><type>uint32_t</type>                                      <name>maxVertex</name></member>
+            <member><type>VkIndexType</type>                                   <name>indexType</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>indexData</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>transformData</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryAabbsDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>         <name>data</name></member>
+            <member><type>VkDeviceSize</type>                          <name>stride</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryInstancesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
+            <member><type>VkBool32</type>                              <name>arrayOfPointers</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>         <name>data</name></member>
+        </type>
+        <type category="union" name="VkAccelerationStructureGeometryDataKHR">
+            <member selection="VK_GEOMETRY_TYPE_TRIANGLES_KHR"><type>VkAccelerationStructureGeometryTrianglesDataKHR</type> <name>triangles</name></member>
+            <member selection="VK_GEOMETRY_TYPE_AABBS_KHR"><type>VkAccelerationStructureGeometryAabbsDataKHR</type>         <name>aabbs</name></member>
+            <member selection="VK_GEOMETRY_TYPE_INSTANCES_KHR"><type>VkAccelerationStructureGeometryInstancesDataKHR</type> <name>instances</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureGeometryKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkGeometryTypeKHR</type>                      <name>geometryType</name></member>
+            <member selector="geometryType"><type>VkAccelerationStructureGeometryDataKHR</type> <name>geometry</name></member>
+            <member optional="true"><type>VkGeometryFlagsKHR</type>     <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureBuildGeometryInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                        <name>pNext</name></member>
+            <member><type>VkAccelerationStructureTypeKHR</type>                                     <name>type</name></member>
+            <member optional="true"><type>VkBuildAccelerationStructureFlagsKHR</type>               <name>flags</name></member>
+            <member noautovalidity="true"><type>VkBuildAccelerationStructureModeKHR</type>          <name>mode</name></member>
+            <member optional="true" noautovalidity="true"><type>VkAccelerationStructureKHR</type>                   <name>srcAccelerationStructure</name></member>
+            <member optional="true" noautovalidity="true"><type>VkAccelerationStructureKHR</type>                   <name>dstAccelerationStructure</name></member>
+            <member optional="true"><type>uint32_t</type>                                           <name>geometryCount</name></member>
+            <member len="geometryCount" optional="true">const <type>VkAccelerationStructureGeometryKHR</type>*    <name>pGeometries</name></member>
+            <member len="geometryCount,1" optional="true,false">const <type>VkAccelerationStructureGeometryKHR</type>* const*   <name>ppGeometries</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                                           <name>scratchData</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureBuildRangeInfoKHR">
+            <member><type>uint32_t</type>                                                <name>primitiveCount</name></member>
+            <member><type>uint32_t</type>                                                <name>primitiveOffset</name></member>
+            <member><type>uint32_t</type>                                                <name>firstVertex</name></member>
+            <member><type>uint32_t</type>                                                <name>transformOffset</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member optional="true"><type>VkAccelerationStructureCreateFlagsKHR</type>   <name>createFlags</name></member>
+            <member><type>VkBuffer</type>                                                <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>                                            <name>offset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type>                                            <name>size</name></member>
+            <member><type>VkAccelerationStructureTypeKHR</type>                          <name>type</name></member>
+            <member optional="true"><type>VkDeviceAddress</type>                         <name>deviceAddress</name></member>
+        </type>
+        <type category="struct" name="VkAabbPositionsKHR">
+            <member><type>float</type>                                                   <name>minX</name></member>
+            <member><type>float</type>                                                   <name>minY</name></member>
+            <member><type>float</type>                                                   <name>minZ</name></member>
+            <member><type>float</type>                                                   <name>maxX</name></member>
+            <member><type>float</type>                                                   <name>maxY</name></member>
+            <member><type>float</type>                                                   <name>maxZ</name></member>
+        </type>
+        <type category="struct" name="VkAabbPositionsNV"                                       alias="VkAabbPositionsKHR"/>
+        <type category="struct" name="VkTransformMatrixKHR">
+            <member><type>float</type>                                                   <name>matrix</name>[3][4]</member>
+        </type>
+        <type category="struct" name="VkTransformMatrixNV"                                     alias="VkTransformMatrixKHR"/>
+        <type category="struct" name="VkAccelerationStructureInstanceKHR">
+            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>VkTransformMatrixKHR</type>                                    <name>transform</name></member>
+            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
+            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
+            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
+            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
+            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureInstanceNV"                       alias="VkAccelerationStructureInstanceKHR"/>
+        <type category="struct" name="VkAccelerationStructureDeviceAddressInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>accelerationStructure</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureVersionInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member len="latexmath:[2 \times \mathtt{VK\_UUID\_SIZE}]" altlen="2*VK_UUID_SIZE">const <type>uint8_t</type>*                    <name>pVersionData</name></member>
+        </type>
+        <type category="struct" name="VkCopyAccelerationStructureInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>src</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>dst</name></member>
+            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkCopyAccelerationStructureToMemoryInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>src</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressKHR</type>                               <name>dst</name></member>
+            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkCopyMemoryToAccelerationStructureInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                          <name>src</name></member>
+            <member><type>VkAccelerationStructureKHR</type>                             <name>dst</name></member>
+            <member><type>VkCopyAccelerationStructureModeKHR</type>                     <name>mode</name></member>
+        </type>
+        <type category="struct" name="VkRayTracingPipelineInterfaceCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                                               <name>maxPipelineRayPayloadSize</name></member>
+            <member><type>uint32_t</type>                                               <name>maxPipelineRayHitAttributeSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineLibraryCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                               <name>libraryCount</name></member>
+            <member len="libraryCount">const <type>VkPipeline</type>*                   <name>pLibraries</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>extendedDynamicState</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExtendedDynamicState2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState2</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState2LogicOp</name></member>
+            <member><type>VkBool32</type>                     <name>extendedDynamicState2PatchControlPoints</name></member>
+        </type>
+        <type category="struct" name="VkRenderPassTransformBeginInfoQCOM" structextends="VkRenderPassBeginInfo">
+            <member values="VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                           <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
+        </type>
+        <type category="struct" name="VkCopyCommandTransformInfoQCOM" structextends="VkBufferImageCopy2KHR,VkImageBlit2KHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>*     <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceRenderPassTransformInfoQCOM" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                           <name>pNext</name><comment>Pointer to next structure</comment></member>
+            <member noautovalidity="true"><type>VkSurfaceTransformFlagBitsKHR</type>   <name>transform</name></member>
+            <member><type>VkRect2D</type>                        <name>renderArea</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDiagnosticsConfigFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>diagnosticsConfig</name></member>
+        </type>
+        <type category="struct" name="VkDeviceDiagnosticsConfigCreateInfoNV" structextends="VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
+            <member optional="true"><type>VkDeviceDiagnosticsConfigFlagsNV</type>    <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*          <name>pNext</name></member>
+            <member><type>VkBool32</type>       <name>shaderZeroInitializeWorkgroupMemory</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type> <name>shaderSubgroupUniformControlFlow</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRobustness2FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>robustBufferAccess2</name></member>
+            <member><type>VkBool32</type>                           <name>robustImageAccess2</name></member>
+            <member><type>VkBool32</type>                           <name>nullDescriptor</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRobustness2PropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>                       <name>robustStorageBufferAccessSizeAlignment</name></member>
+            <member limittype="noauto"><type>VkDeviceSize</type>                       <name>robustUniformBufferAccessSizeAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceImageRobustnessFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>robustImageAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayoutScalarBlockLayout</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout8BitAccess</name></member>
+            <member><type>VkBool32</type>                           <name>workgroupMemoryExplicitLayout16BitAccess</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePortabilitySubsetFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>constantAlphaColorBlendFactors</name></member>
+            <member><type>VkBool32</type>                           <name>events</name></member>
+            <member><type>VkBool32</type>                           <name>imageViewFormatReinterpretation</name></member>
+            <member><type>VkBool32</type>                           <name>imageViewFormatSwizzle</name></member>
+            <member><type>VkBool32</type>                           <name>imageView2DOn3DImage</name></member>
+            <member><type>VkBool32</type>                           <name>multisampleArrayImage</name></member>
+            <member><type>VkBool32</type>                           <name>mutableComparisonSamplers</name></member>
+            <member><type>VkBool32</type>                           <name>pointPolygons</name></member>
+            <member><type>VkBool32</type>                           <name>samplerMipLodBias</name></member>
+            <member><type>VkBool32</type>                           <name>separateStencilMaskRef</name></member>
+            <member><type>VkBool32</type>                           <name>shaderSampleRateInterpolationFunctions</name></member>
+            <member><type>VkBool32</type>                           <name>tessellationIsolines</name></member>
+            <member><type>VkBool32</type>                           <name>tessellationPointMode</name></member>
+            <member><type>VkBool32</type>                           <name>triangleFans</name></member>
+            <member><type>VkBool32</type>                           <name>vertexAttributeAccessBeyondStride</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevicePortabilitySubsetPropertiesKHR" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member limittype="noauto"><type>uint32_t</type>                           <name>minVertexInputBindingStrideAlignment</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDevice4444FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>formatA4R4G4B4</name></member>
+            <member><type>VkBool32</type>                           <name>formatA4B4G4R4</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSubpassShadingFeaturesHUAWEI" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>subpassShading</name></member>
+        </type>
+        <type category="struct" name="VkBufferCopy2KHR">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member><type>VkDeviceSize</type> <name>srcOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>VkDeviceSize</type> <name>dstOffset</name><comment>Specified in bytes</comment></member>
+            <member noautovalidity="true"><type>VkDeviceSize</type> <name>size</name><comment>Specified in bytes</comment></member>
+        </type>
+        <type category="struct" name="VkImageCopy2KHR">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type> <name>srcOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type> <name>dstOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type> <name>extent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageBlit2KHR">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type> <name>srcOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type> <name>dstOffsets</name>[2]<comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkBufferImageCopy2KHR">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member><type>VkDeviceSize</type> <name>bufferOffset</name><comment>Specified in bytes</comment></member>
+            <member><type>uint32_t</type> <name>bufferRowLength</name><comment>Specified in texels</comment></member>
+            <member><type>uint32_t</type> <name>bufferImageHeight</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>imageSubresource</name></member>
+            <member><type>VkOffset3D</type> <name>imageOffset</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+            <member><type>VkExtent3D</type> <name>imageExtent</name><comment>Specified in pixels for both compressed and uncompressed images</comment></member>
+        </type>
+        <type category="struct" name="VkImageResolve2KHR">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*  <name>pNext</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>srcSubresource</name></member>
+            <member><type>VkOffset3D</type> <name>srcOffset</name></member>
+            <member><type>VkImageSubresourceLayers</type> <name>dstSubresource</name></member>
+            <member><type>VkOffset3D</type> <name>dstOffset</name></member>
+            <member><type>VkExtent3D</type> <name>extent</name></member>
+        </type>
+        <type category="struct" name="VkCopyBufferInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBuffer</type> <name>srcBuffer</name></member>
+            <member><type>VkBuffer</type> <name>dstBuffer</name></member>
+            <member><type>uint32_t</type> <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkBufferCopy2KHR</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyImageInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImage</type> <name>srcImage</name></member>
+            <member><type>VkImageLayout</type> <name>srcImageLayout</name></member>
+            <member><type>VkImage</type> <name>dstImage</name></member>
+            <member><type>VkImageLayout</type> <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type> <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageCopy2KHR</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkBlitImageInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImage</type> <name>srcImage</name></member>
+            <member><type>VkImageLayout</type> <name>srcImageLayout</name></member>
+            <member><type>VkImage</type> <name>dstImage</name></member>
+            <member><type>VkImageLayout</type> <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type> <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageBlit2KHR</type>* <name>pRegions</name></member>
+            <member><type>VkFilter</type> <name>filter</name></member>
+        </type>
+        <type category="struct" name="VkCopyBufferToImageInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkBuffer</type> <name>srcBuffer</name></member>
+            <member><type>VkImage</type> <name>dstImage</name></member>
+            <member><type>VkImageLayout</type> <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type> <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkBufferImageCopy2KHR</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkCopyImageToBufferInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImage</type> <name>srcImage</name></member>
+            <member><type>VkImageLayout</type> <name>srcImageLayout</name></member>
+            <member><type>VkBuffer</type> <name>dstBuffer</name></member>
+            <member><type>uint32_t</type> <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkBufferImageCopy2KHR</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkResolveImageInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>* <name>pNext</name></member>
+            <member><type>VkImage</type> <name>srcImage</name></member>
+            <member><type>VkImageLayout</type> <name>srcImageLayout</name></member>
+            <member><type>VkImage</type> <name>dstImage</name></member>
+            <member><type>VkImageLayout</type> <name>dstImageLayout</name></member>
+            <member><type>uint32_t</type> <name>regionCount</name></member>
+            <member len="regionCount">const <type>VkImageResolve2KHR</type>* <name>pRegions</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderImageInt64Atomics</name></member>
+            <member><type>VkBool32</type>                            <name>sparseImageInt64Atomics</name></member>
+        </type>
+        <type category="struct" name="VkFragmentShadingRateAttachmentInfoKHR" structextends="VkSubpassDescription2">
+            <member values="VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                <name>pNext</name></member>
+            <member optional="true">const <type>VkAttachmentReference2</type>* <name>pFragmentShadingRateAttachment</name></member>
+            <member><type>VkExtent2D</type>                 <name>shadingRateAttachmentTexelSize</name></member>
+        </type>
+        <type category="struct" name="VkPipelineFragmentShadingRateStateCreateInfoKHR" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member><type>VkExtent2D</type>                                 <name>fragmentSize</name></member>
+            <member><type>VkFragmentShadingRateCombinerOpKHR</type>         <name>combinerOps</name>[2]</member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkBool32</type>           <name>pipelineFragmentShadingRate</name></member>
+            <member><type>VkBool32</type>           <name>primitiveFragmentShadingRate</name></member>
+            <member><type>VkBool32</type>           <name>attachmentFragmentShadingRate</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRatePropertiesKHR" structextends="VkPhysicalDeviceProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member limittype="min"><type>VkExtent2D</type>             <name>minFragmentShadingRateAttachmentTexelSize</name></member>
+            <member limittype="max"><type>VkExtent2D</type>             <name>maxFragmentShadingRateAttachmentTexelSize</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>maxFragmentShadingRateAttachmentTexelSizeAspectRatio</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>primitiveFragmentShadingRateWithMultipleViewports</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>layeredShadingRateAttachments</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateNonTrivialCombinerOps</name></member>
+            <member limittype="max"><type>VkExtent2D</type>             <name>maxFragmentSize</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>maxFragmentSizeAspectRatio</name></member>
+            <member limittype="noauto"><type>uint32_t</type>               <name>maxFragmentShadingRateCoverageSamples</name></member>
+            <member limittype="max"><type>VkSampleCountFlagBits</type>  <name>maxFragmentShadingRateRasterizationSamples</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithShaderDepthStencilWrites</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithSampleMask</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithShaderSampleMask</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithConservativeRasterization</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithFragmentShaderInterlock</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateWithCustomSampleLocations</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>               <name>fragmentShadingRateStrictMultiplyCombiner</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*              <name>pNext</name></member>
+            <member><type>VkSampleCountFlags</type> <name>sampleCounts</name></member>
+            <member><type>VkExtent2D</type>         <name>fragmentSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>VkBool32</type>                       <name>shaderTerminateInvocation</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>fragmentShadingRateEnums</name></member>
+            <member><type>VkBool32</type>                           <name>supersampleFragmentShadingRates</name></member>
+            <member><type>VkBool32</type>                           <name>noInvocationFragmentShadingRates</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkSampleCountFlagBits</type>              <name>maxFragmentShadingRateInvocationCount</name></member>
+        </type>
+        <type category="struct" name="VkPipelineFragmentShadingRateEnumStateCreateInfoNV" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkFragmentShadingRateTypeNV</type>        <name>shadingRateType</name></member>
+            <member><type>VkFragmentShadingRateNV</type>            <name>shadingRate</name></member>
+            <member><type>VkFragmentShadingRateCombinerOpKHR</type> <name>combinerOps</name>[2]</member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureBuildSizesInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceSize</type>                       <name>accelerationStructureSize</name></member>
+            <member><type>VkDeviceSize</type>                       <name>updateScratchSize</name></member>
+            <member><type>VkDeviceSize</type>                       <name>buildScratchSize</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkBool32</type>                                        <name>mutableDescriptorType</name></member>
+        </type>
+        <type category="struct" name="VkMutableDescriptorTypeListVALVE">
+            <member optional="true"><type>uint32_t</type>                                          <name>descriptorTypeCount</name></member>
+            <member len="descriptorTypeCount">const <type>VkDescriptorType</type>* <name>pDescriptorTypes</name></member>
+        </type>
+        <type category="struct" name="VkMutableDescriptorTypeCreateInfoVALVE" structextends="VkDescriptorSetLayoutCreateInfo,VkDescriptorPoolCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                      <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>                                                         <name>mutableDescriptorTypeListCount</name></member>
+            <member len="mutableDescriptorTypeListCount">const <type>VkMutableDescriptorTypeListVALVE</type>* <name>pMutableDescriptorTypeLists</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>vertexInputDynamicState</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceExternalMemoryRDMAFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>externalMemoryRDMA</name></member>
+        </type>
+        <type category="struct" name="VkVertexInputBindingDescription2EXT">
+            <member values="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>uint32_t</type>                       <name>binding</name></member>
+            <member><type>uint32_t</type>                       <name>stride</name></member>
+            <member><type>VkVertexInputRate</type>              <name>inputRate</name></member>
+            <member><type>uint32_t</type>                       <name>divisor</name></member>
+        </type>
+        <type category="struct" name="VkVertexInputAttributeDescription2EXT">
+            <member values="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*    <name>pNext</name></member>
+            <member><type>uint32_t</type>                       <name>location</name><comment>location of the shader vertex attrib</comment></member>
+            <member><type>uint32_t</type>                       <name>binding</name><comment>Vertex buffer binding id</comment></member>
+            <member><type>VkFormat</type>                       <name>format</name><comment>format of source data</comment></member>
+            <member><type>uint32_t</type>                       <name>offset</name><comment>Offset of first element in bytes from base of vertex</comment></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceColorWriteEnableFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>colorWriteEnable</name></member>
+        </type>
+        <type category="struct" name="VkPipelineColorWriteCreateInfoEXT" structextends="VkPipelineColorBlendStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>attachmentCount</name><comment># of pAttachments</comment></member>
+            <member len="attachmentCount">const <type>VkBool32</type>*  <name>pColorWriteEnables</name></member>
+        </type>
+        <type category="struct" name="VkMemoryBarrier2KHR" structextends="VkSubpassDependency2">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                               <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2KHR</type>  <name>srcStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2KHR</type>         <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2KHR</type>  <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2KHR</type>         <name>dstAccessMask</name></member>
+        </type>
+        <type category="struct" name="VkImageMemoryBarrier2KHR">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                               <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2KHR</type>  <name>srcStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2KHR</type>         <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2KHR</type>  <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2KHR</type>         <name>dstAccessMask</name></member>
+            <member><type>VkImageLayout</type>                             <name>oldLayout</name></member>
+            <member><type>VkImageLayout</type>                             <name>newLayout</name></member>
+            <member><type>uint32_t</type>                                  <name>srcQueueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                                  <name>dstQueueFamilyIndex</name></member>
+            <member><type>VkImage</type>                                   <name>image</name></member>
+            <member><type>VkImageSubresourceRange</type>                   <name>subresourceRange</name></member>
+        </type>
+        <type category="struct" name="VkBufferMemoryBarrier2KHR">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                               <name>pNext</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2KHR</type>  <name>srcStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2KHR</type>         <name>srcAccessMask</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2KHR</type>  <name>dstStageMask</name></member>
+            <member optional="true"><type>VkAccessFlags2KHR</type>         <name>dstAccessMask</name></member>
+            <member><type>uint32_t</type>                                  <name>srcQueueFamilyIndex</name></member>
+            <member><type>uint32_t</type>                                  <name>dstQueueFamilyIndex</name></member>
+            <member><type>VkBuffer</type>                                  <name>buffer</name></member>
+            <member><type>VkDeviceSize</type>                              <name>offset</name></member>
+            <member><type>VkDeviceSize</type>                              <name>size</name></member>
+        </type>
+        <type category="struct" name="VkDependencyInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                               <name>pNext</name></member>
+            <member optional="true"><type>VkDependencyFlags</type>         <name>dependencyFlags</name></member>
+            <member optional="true"><type>uint32_t</type>                  <name>memoryBarrierCount</name></member>
+            <member len="memoryBarrierCount">const <type>VkMemoryBarrier2KHR</type>* <name>pMemoryBarriers</name></member>
+            <member optional="true"><type>uint32_t</type>                  <name>bufferMemoryBarrierCount</name></member>
+            <member len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier2KHR</type>* <name>pBufferMemoryBarriers</name></member>
+            <member optional="true"><type>uint32_t</type>                  <name>imageMemoryBarrierCount</name></member>
+            <member len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier2KHR</type>* <name>pImageMemoryBarriers</name></member>
+        </type>
+        <type category="struct" name="VkSemaphoreSubmitInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR"><type>VkStructureType</type>       <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                <name>pNext</name></member>
+            <member><type>VkSemaphore</type>                                                                <name>semaphore</name></member>
+            <member><type>uint64_t</type>                                                                   <name>value</name></member>
+            <member optional="true"><type>VkPipelineStageFlags2KHR</type>                                   <name>stageMask</name></member>
+            <member><type>uint32_t</type>                                                                   <name>deviceIndex</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferSubmitInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR"><type>VkStructureType</type>  <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                <name>pNext</name></member>
+            <member><type>VkCommandBuffer</type>                                                            <name>commandBuffer</name></member>
+            <member><type>uint32_t</type>                                                                   <name>deviceMask</name></member>
+        </type>
+        <type category="struct" name="VkSubmitInfo2KHR">
+            <member values="VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR"><type>VkStructureType</type>               <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                                <name>pNext</name></member>
+            <member optional="true"><type>VkSubmitFlagsKHR</type>                                           <name>flags</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>waitSemaphoreInfoCount</name></member>
+            <member len="waitSemaphoreInfoCount">const <type>VkSemaphoreSubmitInfoKHR</type>*               <name>pWaitSemaphoreInfos</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>commandBufferInfoCount</name></member>
+            <member len="commandBufferInfoCount">const <type>VkCommandBufferSubmitInfoKHR</type>*           <name>pCommandBufferInfos</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>signalSemaphoreInfoCount</name></member>
+            <member len="signalSemaphoreInfoCount">const <type>VkSemaphoreSubmitInfoKHR</type>*             <name>pSignalSemaphoreInfos</name></member>
+        </type>
+        <type category="struct" name="VkQueueFamilyCheckpointProperties2NV" structextends="VkQueueFamilyProperties2" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*           <name>pNext</name></member>
+            <member><type>VkPipelineStageFlags2KHR</type> <name>checkpointExecutionStageMask</name></member>
+        </type>
+        <type category="struct" name="VkCheckpointData2NV" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                  <name>pNext</name></member>
+            <member><type>VkPipelineStageFlags2KHR</type>   <name>stage</name></member>
+            <member noautovalidity="true"><type>void</type>* <name>pCheckpointMarker</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceSynchronization2FeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>synchronization2</name></member>
+        </type>
+        <type category="struct" name="VkVideoQueueFamilyProperties2KHR" structextends="VkQueueFamilyProperties2">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkVideoCodecOperationFlagsKHR</type>      <name>videoCodecOperations</name></member>
+        </type>
+        <type category="struct" name="VkVideoProfilesKHR" structextends="VkFormatProperties2,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>uint32_t</type>                           <name>profileCount</name></member>
+            <member>const <type>VkVideoProfileKHR</type>*           <name>pProfiles</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceVideoFormatInfoKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkImageUsageFlags</type>                  <name>imageUsage</name></member>
+            <member>const <type>VkVideoProfilesKHR</type>*          <name>pVideoProfiles</name></member>
+        </type>
+        <type category="struct" name="VkVideoFormatPropertiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkFormat</type>                           <name>format</name></member>
+        </type>
+        <type category="struct" name="VkVideoProfileKHR" structextends="VkQueryPoolCreateInfo,VkFormatProperties2,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkVideoCodecOperationFlagBitsKHR</type>   <name>videoCodecOperation</name></member>
+            <member><type>VkVideoChromaSubsamplingFlagsKHR</type>   <name>chromaSubsampling</name></member>
+            <member><type>VkVideoComponentBitDepthFlagsKHR</type>   <name>lumaBitDepth</name></member>
+            <member><type>VkVideoComponentBitDepthFlagsKHR</type>   <name>chromaBitDepth</name></member>
+        </type>
+        <type category="struct" name="VkVideoCapabilitiesKHR" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkVideoCapabilityFlagsKHR</type>        <name>capabilityFlags</name></member>
+            <member><type>VkDeviceSize</type>                     <name>minBitstreamBufferOffsetAlignment</name></member>
+            <member><type>VkDeviceSize</type>                     <name>minBitstreamBufferSizeAlignment</name></member>
+            <member><type>VkExtent2D</type>                       <name>videoPictureExtentGranularity</name></member>
+            <member><type>VkExtent2D</type>                       <name>minExtent</name></member>
+            <member><type>VkExtent2D</type>                       <name>maxExtent</name></member>
+            <member><type>uint32_t</type>                         <name>maxReferencePicturesSlotsCount</name></member>
+            <member><type>uint32_t</type>                         <name>maxReferencePicturesActiveCount</name></member>
+        </type>
+        <type category="struct" name="VkVideoGetMemoryPropertiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                       <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>memoryBindIndex</name></member>
+            <member><type>VkMemoryRequirements2</type>*            <name>pMemoryRequirements</name></member>
+        </type>
+        <type category="struct" name="VkVideoBindMemoryKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                       <name>pNext</name></member>
+            <member><type>uint32_t</type>                          <name>memoryBindIndex</name></member>
+            <member><type>VkDeviceMemory</type>                    <name>memory</name></member>
+            <member><type>VkDeviceSize</type>                      <name>memoryOffset</name></member>
+            <member><type>VkDeviceSize</type>                      <name>memorySize</name></member>
+        </type>
+        <type category="struct" name="VkVideoPictureResourceKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkOffset2D</type>         <name>codedOffset</name><comment>The offset to be used for the picture resource, currently only used in field mode</comment></member>
+            <member><type>VkExtent2D</type>         <name>codedExtent</name><comment>The extent to be used for the picture resource</comment></member>
+            <member><type>uint32_t</type>           <name>baseArrayLayer</name><comment>TThe first array layer to be accessed for the Decode or Encode Operations</comment></member>
+            <member><type>VkImageView</type>        <name>imageViewBinding</name><comment>The ImageView binding of the resource</comment></member>
+        </type>
+        <type category="struct" name="VkVideoReferenceSlotKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>int8_t</type>             <name>slotIndex</name><comment>The reference slot index</comment></member>
+            <member>const <type>VkVideoPictureResourceKHR</type>* <name>pPictureResource</name><comment>The reference picture resource</comment></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkVideoDecodeFlagsKHR</type>  <name>flags</name></member>
+            <member><type>VkOffset2D</type>                             <name>codedOffset</name></member>
+            <member><type>VkExtent2D</type>                             <name>codedExtent</name></member>
+            <member><type>VkBuffer</type>                               <name>srcBuffer</name></member>
+            <member><type>VkDeviceSize</type>                           <name>srcBufferOffset</name></member>
+            <member><type>VkDeviceSize</type>                           <name>srcBufferRange</name></member>
+            <member><type>VkVideoPictureResourceKHR</type>              <name>dstPictureResource</name></member>
+            <member>const <type>VkVideoReferenceSlotKHR</type>*         <name>pSetupReferenceSlot</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>referenceSlotCount</name></member>
+            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotKHR</type>* <name>pReferenceSlots</name></member>
+        </type>
+            <comment>Video Decode Codec Standard specific structures</comment>
+        <type category="include" name="vk_video/vulkan_video_codec_h264std.h">#include "vk_video/vulkan_video_codec_h264std.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ProfileIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264Level"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ChromaFormatIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PocType"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ScalingLists"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SequenceParameterSetVui"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264AspectRatioIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264HrdParameters"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SpsVuiFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264WeightedBipredIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SliceType"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264CabacInitIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264DisableDeblockingFilterIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PictureType"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264ModificationOfPicNumsIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264MemMgmtControlOp"/>
+        <type category="include" name="vk_video/vulkan_video_codec_h264std_decode.h">#include "vk_video/vulkan_video_codec_h264std_decode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264ReferenceInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264Mvc"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264ReferenceInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264MvcElement"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_decode.h" name="StdVideoDecodeH264MvcElementFlags"/>
+        <type category="struct" name="VkVideoDecodeH264ProfileEXT" structextends="VkVideoProfileKHR,VkQueryPoolCreateInfo,VkFormatProperties2,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>StdVideoH264ProfileIdc</type>                 <name>stdProfileIdc</name></member>
+            <member><type>VkVideoDecodeH264PictureLayoutFlagsEXT</type> <name>pictureLayout</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264CapabilitiesEXT" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>maxLevel</name></member>
+            <member><type>VkOffset2D</type>                       <name>fieldOffsetGranularity</name></member>
+            <member><type>VkExtensionProperties</type>            <name>stdExtensionVersion</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264SessionCreateInfoEXT" structextends="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkVideoDecodeH264CreateFlagsEXT</type>  <name>flags</name></member>
+            <member>const <type>VkExtensionProperties</type>*     <name>pStdExtensionVersion</name></member>
+        </type>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264SequenceParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h264std.h" name="StdVideoH264PictureParameterSet"/>
+        <type category="struct" name="VkVideoDecodeH264SessionParametersAddInfoEXT" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                  <name>spsStdCount</name></member>
+            <member len="spsStdCount" optional="true">const <type>StdVideoH264SequenceParameterSet</type>* <name>pSpsStd</name></member>
+            <member><type>uint32_t</type>                                                                  <name>ppsStdCount</name></member>
+            <member len="ppsStdCount" optional="true">const <type>StdVideoH264PictureParameterSet</type>*  <name>pPpsStd</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264SessionParametersCreateInfoEXT" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                  <name>maxSpsStdCount</name></member>
+            <member><type>uint32_t</type>                                                                  <name>maxPpsStdCount</name></member>
+            <member optional="true">const <type>VkVideoDecodeH264SessionParametersAddInfoEXT</type>*       <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264PictureInfoEXT" structextends="VkVideoDecodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>*     <name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH264PictureInfo</type>*  <name>pStdPictureInfo</name></member>
+            <member><type>uint32_t</type>                              <name>slicesCount</name></member>
+            <member len="slicesCount">const <type>uint32_t</type>*     <name>pSlicesDataOffsets</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264DpbSlotInfoEXT" structextends="VkVideoReferenceSlotKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH264ReferenceInfo</type>* <name>pStdReferenceInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH264MvcEXT" structextends="VkVideoDecodeH264PictureInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true" noautovalidity="true">const <type>void</type>*<name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH264Mvc</type>*   <name>pStdMvc</name></member>
+        </type>
+        <type category="include" name="vk_video/vulkan_video_codec_h265std.h">#include "vk_video/vulkan_video_codec_h265std.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265ProfileIdc"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265VideoParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SequenceParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PictureParameterSet"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265DecPicBufMgr"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265HrdParameters"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265VpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265Level"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265ScalingLists"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SequenceParameterSetVui"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PredictorPaletteEntries"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PpsFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SubLayerHrdParameters"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265HrdFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SpsVuiFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265SliceType"/>
+        <type requires="vk_video/vulkan_video_codec_h265std.h" name="StdVideoH265PictureType"/>
+        <type category="include" name="vk_video/vulkan_video_codec_h265std_decode.h">#include "vk_video/vulkan_video_codec_h265std_decode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265ReferenceInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_decode.h" name="StdVideoDecodeH265ReferenceInfoFlags"/>
+        <type category="struct" name="VkVideoDecodeH265ProfileEXT" structextends="VkVideoProfileKHR,VkQueryPoolCreateInfo,VkFormatProperties2,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>StdVideoH265ProfileIdc</type>         <name>stdProfileIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265CapabilitiesEXT" returnedonly="true" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>maxLevel</name></member>
+            <member><type>VkExtensionProperties</type>            <name>stdExtensionVersion</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265SessionCreateInfoEXT" structextends="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                      <name>pNext</name></member>
+            <member><type>VkVideoDecodeH265CreateFlagsEXT</type>  <name>flags</name></member>
+            <member>const <type>VkExtensionProperties</type>*     <name>pStdExtensionVersion</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265SessionParametersAddInfoEXT" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                  <name>spsStdCount</name></member>
+            <member len="spsStdCount" optional="true">const <type>StdVideoH265SequenceParameterSet</type>* <name>pSpsStd</name></member>
+            <member><type>uint32_t</type>                                                                  <name>ppsStdCount</name></member>
+            <member len="ppsStdCount" optional="true">const <type>StdVideoH265PictureParameterSet</type>*  <name>pPpsStd</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265SessionParametersCreateInfoEXT" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxSpsStdCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxPpsStdCount</name></member>
+            <member optional="true">const <type>VkVideoDecodeH265SessionParametersAddInfoEXT</type>* <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265PictureInfoEXT" structextends="VkVideoDecodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>StdVideoDecodeH265PictureInfo</type>*     <name>pStdPictureInfo</name></member>
+            <member><type>uint32_t</type>                           <name>slicesCount</name></member>
+            <member len="slicesCount">const <type>uint32_t</type>*  <name>pSlicesDataOffsets</name></member>
+        </type>
+        <type category="struct" name="VkVideoDecodeH265DpbSlotInfoEXT" structextends="VkVideoReferenceSlotKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member>const <type>StdVideoDecodeH265ReferenceInfo</type>*  <name>pStdReferenceInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                   <name>pNext</name></member>
+            <member><type>uint32_t</type>                                      <name>queueFamilyIndex</name></member>
+            <member optional="true"><type>VkVideoSessionCreateFlagsKHR</type>  <name>flags</name></member>
+            <member>const <type>VkVideoProfileKHR</type>*                      <name>pVideoProfile</name></member>
+            <member><type>VkFormat</type>                                      <name>pictureFormat</name></member>
+            <member><type>VkExtent2D</type>                                    <name>maxCodedExtent</name></member>
+            <member><type>VkFormat</type>                                      <name>referencePicturesFormat</name></member>
+            <member><type>uint32_t</type>                                      <name>maxReferencePicturesSlotsCount</name></member>
+            <member><type>uint32_t</type>                                      <name>maxReferencePicturesActiveCount</name></member>
+        </type>
+        <type category="struct" name="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member optional="true"><type>VkVideoSessionParametersKHR</type>            <name>videoSessionParametersTemplate</name></member>
+            <member><type>VkVideoSessionKHR</type>                                      <name>videoSession</name></member>
+        </type>
+        <type category="struct" name="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member><type>uint32_t</type>                                               <name>updateSequenceCount</name></member>
+        </type>
+        <type category="struct" name="VkVideoBeginCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                             <name>pNext</name></member>
+            <member optional="true"><type>VkVideoBeginCodingFlagsKHR</type>              <name>flags</name></member>
+            <member><type>VkVideoCodingQualityPresetFlagsKHR</type>                      <name>codecQualityPreset</name></member>
+            <member><type>VkVideoSessionKHR</type>                                       <name>videoSession</name></member>
+            <member optional="true"><type>VkVideoSessionParametersKHR</type>             <name>videoSessionParameters</name></member>
+            <member optional="true"><type>uint32_t</type>                                <name>referenceSlotCount</name></member>
+            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotKHR</type>* <name>pReferenceSlots</name></member>
+        </type>
+        <type category="struct" name="VkVideoEndCodingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEndCodingFlagsKHR</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkVideoCodingControlInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                  <name>pNext</name></member>
+            <member optional="true"><type>VkVideoCodingControlFlagsKHR</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member optional="true"><type>VkVideoEncodeFlagsKHR</type>  <name>flags</name></member>
+            <member><type>uint32_t</type>                               <name>qualityLevel</name></member>
+            <member><type>VkExtent2D</type>                             <name>codedExtent</name></member>
+            <member><type>VkBuffer</type>                               <name>dstBitstreamBuffer</name></member>
+            <member><type>VkDeviceSize</type>                           <name>dstBitstreamBufferOffset</name></member>
+            <member><type>VkDeviceSize</type>                           <name>dstBitstreamBufferMaxRange</name></member>
+            <member><type>VkVideoPictureResourceKHR</type>              <name>srcPictureResource</name></member>
+            <member>const <type>VkVideoReferenceSlotKHR</type>*         <name>pSetupReferenceSlot</name></member>
+            <member optional="true"><type>uint32_t</type>               <name>referenceSlotCount</name></member>
+            <member len="referenceSlotCount">const <type>VkVideoReferenceSlotKHR</type>* <name>pReferenceSlots</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeRateControlInfoKHR" structextends="VkVideoCodingControlInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkVideoEncodeRateControlFlagsKHR</type>         <name>flags</name></member>
+            <member><type>VkVideoEncodeRateControlModeFlagBitsKHR</type>  <name>rateControlMode</name></member>
+            <member><type>uint32_t</type>                                 <name>averageBitrate</name></member>
+            <member><type>uint16_t</type>                                 <name>peakToAverageBitrateRatio</name></member>
+            <member><type>uint16_t</type>                                 <name>frameRateNumerator</name></member>
+            <member><type>uint16_t</type>                                 <name>frameRateDenominator</name></member>
+            <member><type>uint32_t</type>                                 <name>virtualBufferSizeInMs</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264CapabilitiesEXT" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                           <name>pNext</name></member>
+            <member><type>VkVideoEncodeH264CapabilityFlagsEXT</type>   <name>flags</name></member>
+            <member><type>VkVideoEncodeH264InputModeFlagsEXT</type>    <name>inputModeFlags</name></member>
+            <member><type>VkVideoEncodeH264OutputModeFlagsEXT</type>   <name>outputModeFlags</name></member>
+            <member><type>VkExtent2D</type>                            <name>minPictureSizeInMbs</name></member>
+            <member><type>VkExtent2D</type>                            <name>maxPictureSizeInMbs</name></member>
+            <member><type>VkExtent2D</type>                            <name>inputImageDataAlignment</name></member>
+            <member><type>uint8_t</type>                               <name>maxNumL0ReferenceForP</name></member>
+            <member><type>uint8_t</type>                               <name>maxNumL0ReferenceForB</name></member>
+            <member><type>uint8_t</type>                               <name>maxNumL1Reference</name></member>
+            <member><type>uint8_t</type>                               <name>qualityLevelCount</name></member>
+            <member><type>VkExtensionProperties</type>                 <name>stdExtensionVersion</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264SessionCreateInfoEXT" structextends="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                     <name>pNext</name></member>
+            <member><type>VkVideoEncodeH264CreateFlagsEXT</type> <name>flags</name></member>
+            <member><type>VkExtent2D</type>                      <name>maxPictureSizeInMbs</name></member>
+            <member>const <type>VkExtensionProperties</type>*    <name>pStdExtensionVersion</name></member>
+        </type>
+        <type category="include" name="vk_video/vulkan_video_codec_h264std_encode.h">#include "vk_video/vulkan_video_codec_h264std_encode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264SliceHeader"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264SliceHeaderFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264RefMemMgmtCtrlOperations"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264RefMgmtFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264RefListModEntry"/>
+        <type requires="vk_video/vulkan_video_codec_h264std_encode.h" name="StdVideoEncodeH264RefPicMarkingEntry"/>
+        <type category="struct" name="VkVideoEncodeH264SessionParametersAddInfoEXT" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                  <name>spsStdCount</name></member>
+            <member len="spsStdCount" optional="true">const <type>StdVideoH264SequenceParameterSet</type>* <name>pSpsStd</name></member>
+            <member><type>uint32_t</type>                                                                  <name>ppsStdCount</name></member>
+            <member len="ppsStdCount" optional="true">const <type>StdVideoH264PictureParameterSet</type>*  <name>pPpsStd</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264SessionParametersCreateInfoEXT" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxSpsStdCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxPpsStdCount</name></member>
+            <member optional="true">const <type>VkVideoEncodeH264SessionParametersAddInfoEXT</type>* <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264DpbSlotInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>int8_t</type>                                                               <name>slotIndex</name></member>
+            <member>const <type>StdVideoEncodeH264PictureInfo</type>*                                 <name>pStdPictureInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264VclFrameInfoEXT" structextends="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                          <name>pNext</name></member>
+            <member><type>uint8_t</type>                                                              <name>refDefaultFinalList0EntryCount</name></member>
+            <member len="refDefaultFinalList0EntryCount">const <type>VkVideoEncodeH264DpbSlotInfoEXT</type>* <name>pRefDefaultFinalList0Entries</name></member>
+            <member><type>uint8_t</type>                                                              <name>refDefaultFinalList1EntryCount</name></member>
+            <member len="refDefaultFinalList1EntryCount">const <type>VkVideoEncodeH264DpbSlotInfoEXT</type>* <name>pRefDefaultFinalList1Entries</name></member>
+            <member><type>uint32_t</type>                                                             <name>naluSliceEntryCount</name></member>
+            <member len="naluSliceEntryCount">const <type>VkVideoEncodeH264NaluSliceEXT</type>*     <name>pNaluSliceEntries</name></member>
+            <member>const <type>VkVideoEncodeH264DpbSlotInfoEXT</type>*                               <name>pCurrentPictureInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264EmitPictureParametersEXT" structextends="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                             <name>pNext</name></member>
+            <member><type>uint8_t</type>                                 <name>spsId</name></member>
+            <member><type>VkBool32</type>                                <name>emitSpsEnable</name></member>
+            <member><type>uint32_t</type>                                <name>ppsIdEntryCount</name></member>
+            <member len="ppsIdEntryCount">const <type>uint8_t</type>*  <name>ppsIdEntries</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264ProfileEXT" structextends="VkVideoProfileKHR,VkQueryPoolCreateInfo,VkFormatProperties2,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>StdVideoH264ProfileIdc</type>         <name>stdProfileIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH264NaluSliceEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                     <name>pNext</name></member>
+            <member>const <type>StdVideoEncodeH264SliceHeader</type>*            <name>pSliceHeaderStd</name></member>
+            <member><type>uint32_t</type>                                        <name>mbCount</name></member>
+            <member><type>uint8_t</type>                                         <name>refFinalList0EntryCount</name></member>
+            <member len="refFinalList0EntryCount">const <type>VkVideoEncodeH264DpbSlotInfoEXT</type>* <name>pRefFinalList0Entries</name></member>
+            <member><type>uint8_t</type>                                         <name>refFinalList1EntryCount</name></member>
+            <member len="refFinalList1EntryCount">const <type>VkVideoEncodeH264DpbSlotInfoEXT</type>* <name>pRefFinalList1Entries</name></member>
+            <member><type>uint32_t</type>                                        <name>precedingNaluBytes</name></member>
+            <member><type>uint8_t</type>                                         <name>minQp</name></member>
+            <member><type>uint8_t</type>                                         <name>maxQp</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265CapabilitiesEXT" structextends="VkVideoCapabilitiesKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*           <name>pNext</name></member>
+            <member><type>VkVideoEncodeH265CapabilityFlagsEXT</type>   <name>flags</name></member>
+            <member><type>VkVideoEncodeH265InputModeFlagsEXT</type>    <name>inputModeFlags</name></member>
+            <member><type>VkVideoEncodeH265OutputModeFlagsEXT</type>   <name>outputModeFlags</name></member>
+            <member><type>VkVideoEncodeH265CtbSizeFlagsEXT</type>      <name>ctbSizes</name></member>
+            <member><type>VkExtent2D</type>                            <name>inputImageDataAlignment</name></member>
+            <member><type>uint8_t</type>                               <name>maxNumL0ReferenceForP</name></member>
+            <member><type>uint8_t</type>                               <name>maxNumL0ReferenceForB</name></member>
+            <member><type>uint8_t</type>                               <name>maxNumL1Reference</name></member>
+            <member><type>uint8_t</type>                               <name>maxNumSubLayers</name></member>
+            <member><type>uint8_t</type>                               <name>qualityLevelCount</name></member>
+            <member><type>VkExtensionProperties</type>                 <name>stdExtensionVersion</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265SessionCreateInfoEXT" structextends="VkVideoSessionCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkVideoEncodeH265CreateFlagsEXT</type>  <name>flags</name></member>
+            <member>const <type>VkExtensionProperties</type>*     <name>pStdExtensionVersion</name></member>
+        </type>
+        <type category="include" name="vk_video/vulkan_video_codec_h265std_encode.h">#include "vk_video/vulkan_video_codec_h265std_encode.h"</type>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265PictureInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265SliceSegmentHeader"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265PictureInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265SliceHeader"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceInfo"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceModifications"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265SliceHeaderFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceInfoFlags"/>
+        <type requires="vk_video/vulkan_video_codec_h265std_encode.h" name="StdVideoEncodeH265ReferenceModificationFlags"/>
+        <type category="struct" name="VkVideoEncodeH265SessionParametersAddInfoEXT" structextends="VkVideoSessionParametersUpdateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                               <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                  <name>vpsStdCount</name></member>
+            <member len="vpsStdCount" optional="true">const <type>StdVideoH265VideoParameterSet</type>*    <name>pVpsStd</name></member>
+            <member><type>uint32_t</type>                                                                  <name>spsStdCount</name></member>
+            <member len="spsStdCount" optional="true">const <type>StdVideoH265SequenceParameterSet</type>* <name>pSpsStd</name></member>
+            <member><type>uint32_t</type>                                                                  <name>ppsStdCount</name></member>
+            <member len="ppsStdCount" optional="true">const <type>StdVideoH265PictureParameterSet</type>*  <name>pPpsStd</name><comment>List of Picture Parameters associated with the spsStd, above</comment></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265SessionParametersCreateInfoEXT" structextends="VkVideoSessionParametersCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                         <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxVpsStdCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxSpsStdCount</name></member>
+            <member><type>uint32_t</type>                                                            <name>maxPpsStdCount</name></member>
+            <member optional="true">const <type>VkVideoEncodeH265SessionParametersAddInfoEXT</type>* <name>pParametersAddInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265VclFrameInfoEXT" structextends="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                       <name>pNext</name></member>
+            <member optional="true">const <type>VkVideoEncodeH265ReferenceListsEXT</type>*         <name>pReferenceFinalLists</name></member>
+            <member><type>uint32_t</type>                                                          <name>naluSliceEntryCount</name></member>
+            <member len="naluSliceEntryCount">const <type>VkVideoEncodeH265NaluSliceEXT</type>*    <name>pNaluSliceEntries</name></member>
+            <member>const <type>StdVideoEncodeH265PictureInfo</type>*                              <name>pCurrentPictureInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265EmitPictureParametersEXT" structextends="VkVideoEncodeInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*             <name>pNext</name></member>
+            <member><type>uint8_t</type>                                 <name>vpsId</name></member>
+            <member><type>uint8_t</type>                                 <name>spsId</name></member>
+            <member><type>VkBool32</type>                                <name>emitVpsEnable</name></member>
+            <member><type>VkBool32</type>                                <name>emitSpsEnable</name></member>
+            <member optional="true"><type>uint32_t</type>                <name>ppsIdEntryCount</name></member>
+            <member len="ppsIdEntryCount">const <type>uint8_t</type>*    <name>ppsIdEntries</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265NaluSliceEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                   <name>ctbCount</name></member>
+            <member optional="true">const <type>VkVideoEncodeH265ReferenceListsEXT</type>*  <name>pReferenceFinalLists</name></member>
+            <member>const <type>StdVideoEncodeH265SliceHeader</type>*                       <name>pSliceHeaderStd</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265ProfileEXT" structextends="VkVideoProfileKHR,VkQueryPoolCreateInfo,VkFormatProperties2,VkImageCreateInfo,VkImageViewCreateInfo,VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*    <name>pNext</name></member>
+            <member><type>StdVideoH265ProfileIdc</type>         <name>stdProfileIdc</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265DpbSlotInfoEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*              <name>pNext</name></member>
+            <member><type>int8_t</type>                                   <name>slotIndex</name></member>
+            <member>const <type>StdVideoEncodeH265ReferenceInfo</type>*   <name>pStdReferenceInfo</name></member>
+        </type>
+        <type category="struct" name="VkVideoEncodeH265ReferenceListsEXT">
+            <member values="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_EXT"><type>VkStructureType</type><name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                            <name>pNext</name></member>
+            <member optional="true"><type>uint8_t</type>                                                <name>referenceList0EntryCount</name></member>
+            <member len="referenceList0EntryCount">const <type>VkVideoEncodeH265DpbSlotInfoEXT</type>*  <name>pReferenceList0Entries</name></member>
+            <member optional="true"><type>uint8_t</type>                                                <name>referenceList1EntryCount</name></member>
+            <member len="referenceList1EntryCount">const <type>VkVideoEncodeH265DpbSlotInfoEXT</type>*  <name>pReferenceList1Entries</name></member>
+            <member>const <type>StdVideoEncodeH265ReferenceModifications</type>*                        <name>pReferenceModifications</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceInheritedViewportScissorFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>inheritedViewportScissor2D</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceViewportScissorInfoNV" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                    <name>pNext</name></member>
+            <member><type>VkBool32</type>                                       <name>viewportScissor2D</name></member>
+            <member><type>uint32_t</type>                                       <name>viewportDepthCount</name></member>
+            <member noautovalidity="true">const <type>VkViewport</type>*        <name>pViewportDepths</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                     <name>ycbcr2plane444Formats</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProvokingVertexFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>provokingVertexLast</name></member>
+            <member><type>VkBool32</type>                           <name>transformFeedbackPreservesProvokingVertex</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceProvokingVertexPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                               <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                            <name>provokingVertexModePerPipeline</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>                            <name>transformFeedbackPreservesTriangleFanProvokingVertex</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRasterizationProvokingVertexStateCreateInfoEXT" structextends="VkPipelineRasterizationStateCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkProvokingVertexModeEXT</type>           <name>provokingVertexMode</name></member>
+        </type>
+        <type category="struct" name="VkCuModuleCreateInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>size_t</type>                 <name>dataSize</name></member>
+            <member len="dataSize">const <type>void</type>*            <name>pData</name></member>
+        </type>
+        <type category="struct" name="VkCuFunctionCreateInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                        <name>pNext</name></member>
+            <member><type>VkCuModuleNVX</type>                      <name>module</name></member>
+            <member len="null-terminated">const <type>char</type>*  <name>pName</name></member>
+        </type>
+        <type category="struct" name="VkCuLaunchInfoNVX">
+            <member values="VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkCuFunctionNVX</type>        <name>function</name></member>
+            <member><type>uint32_t</type>               <name>gridDimX</name></member>
+            <member><type>uint32_t</type>               <name>gridDimY</name></member>
+            <member><type>uint32_t</type>               <name>gridDimZ</name></member>
+            <member><type>uint32_t</type>               <name>blockDimX</name></member>
+            <member><type>uint32_t</type>               <name>blockDimY</name></member>
+            <member><type>uint32_t</type>               <name>blockDimZ</name></member>
+            <member><type>uint32_t</type>               <name>sharedMemBytes</name></member>
+            <member><type>size_t</type>                 <name>paramCount</name></member>
+            <member len="paramCount">const <type>void</type>* const *    <name>pParams</name></member>
+            <member><type>size_t</type>                 <name>extraCount</name></member>
+            <member len="extraCount">const <type>void</type>* const *    <name>pExtras</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBool32</type>                            <name>shaderIntegerDotProduct</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*               <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct8BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct8BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct8BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct4x8BitPackedUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct4x8BitPackedSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct4x8BitPackedMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct16BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct16BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct16BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct32BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct32BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct32BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct64BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct64BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProduct64BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating8BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating8BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating16BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating16BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating32BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating32BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating64BitUnsignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating64BitSignedAccelerated</name></member>
+            <member limittype="bitmask"><type>VkBool32</type>        <name>integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDrmPropertiesEXT" returnedonly="true" structextends="VkPhysicalDeviceProperties2">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member limittype="bitmask"><type>VkBool32</type> <name>hasPrimary</name></member>
+            <member limittype="bitmask"><type>VkBool32</type> <name>hasRender</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>primaryMajor</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>primaryMinor</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>renderMajor</name></member>
+            <member limittype="noauto"><type>int64_t</type> <name>renderMinor</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>rayTracingMotionBlur</name></member>
+            <member><type>VkBool32</type>                           <name>rayTracingMotionBlurPipelineTraceRaysIndirect</name></member>
+        </type>
+        <type name="VkAccelerationStructureMotionInstanceTypeNV" category="enum"/>
+        <type category="struct" name="VkAccelerationStructureGeometryMotionTrianglesDataNV" structextends="VkAccelerationStructureGeometryTrianglesDataKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                   <name>pNext</name></member>
+            <member noautovalidity="true"><type>VkDeviceOrHostAddressConstKHR</type>                 <name>vertexData</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMotionInfoNV" structextends="VkAccelerationStructureCreateInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                    <name>pNext</name></member>
+            <member><type>uint32_t</type>                                       <name>maxInstances</name></member>
+            <member optional="true"><type>VkAccelerationStructureMotionInfoFlagsNV</type> <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkSRTDataNV">
+            <member><type>float</type> <name>sx</name></member>
+            <member><type>float</type> <name>a</name></member>
+            <member><type>float</type> <name>b</name></member>
+            <member><type>float</type> <name>pvx</name></member>
+            <member><type>float</type> <name>sy</name></member>
+            <member><type>float</type> <name>c</name></member>
+            <member><type>float</type> <name>pvy</name></member>
+            <member><type>float</type> <name>sz</name></member>
+            <member><type>float</type> <name>pvz</name></member>
+            <member><type>float</type> <name>qx</name></member>
+            <member><type>float</type> <name>qy</name></member>
+            <member><type>float</type> <name>qz</name></member>
+            <member><type>float</type> <name>qw</name></member>
+            <member><type>float</type> <name>tx</name></member>
+            <member><type>float</type> <name>ty</name></member>
+            <member><type>float</type> <name>tz</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureSRTMotionInstanceNV">
+            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>VkSRTDataNV</type>                                             <name>transformT0</name></member>
+            <member><type>VkSRTDataNV</type>                                             <name>transformT1</name></member>
+            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
+            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
+            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
+            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
+            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMatrixMotionInstanceNV">
+            <comment>The bitfields in this structure are non-normative since bitfield ordering is implementation-defined in C. The specification defines the normative layout.</comment>
+            <member><type>VkTransformMatrixKHR</type>                                    <name>transformT0</name></member>
+            <member><type>VkTransformMatrixKHR</type>                                    <name>transformT1</name></member>
+            <member><type>uint32_t</type>                                                <name>instanceCustomIndex</name>:24</member>
+            <member><type>uint32_t</type>                                                <name>mask</name>:8</member>
+            <member><type>uint32_t</type>                                                <name>instanceShaderBindingTableRecordOffset</name>:24</member>
+            <member optional="true"><type>VkGeometryInstanceFlagsKHR</type>              <name>flags</name>:8</member>
+            <member><type>uint64_t</type>                                                <name>accelerationStructureReference</name></member>
+        </type>
+        <type category="union" name="VkAccelerationStructureMotionInstanceDataNV">
+            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"><type>VkAccelerationStructureInstanceKHR</type>            <name>staticInstance</name></member>
+            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"><type>VkAccelerationStructureMatrixMotionInstanceNV</type> <name>matrixMotionInstance</name></member>
+            <member selection="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"><type>VkAccelerationStructureSRTMotionInstanceNV</type>    <name>srtMotionInstance</name></member>
+        </type>
+        <type category="struct" name="VkAccelerationStructureMotionInstanceNV">
+            <member><type>VkAccelerationStructureMotionInstanceTypeNV</type> <name>type</name></member>
+            <member optional="true"><type>VkAccelerationStructureMotionInstanceFlagsNV</type> <name>flags</name></member>
+            <member selector="type"><type>VkAccelerationStructureMotionInstanceDataNV</type> <name>data</name></member>
+        </type>
+        <type category="basetype">typedef <type>void</type>* <name>VkRemoteAddressNV</name>;</type>
+        <type category="struct" name="VkMemoryGetRemoteAddressInfoNV">
+            <member values="VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*        <name>pNext</name></member>
+            <member><type>VkDeviceMemory</type>                     <name>memory</name></member>
+            <member><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></member>
+        </type>
+        <type category="struct" name="VkImportMemoryBufferCollectionFUCHSIA" structextends="VkMemoryAllocateInfo">
+            <member values="VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
+            <member><type>uint32_t</type>                         <name>index</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionImageCreateInfoFUCHSIA" structextends="VkImageCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
+            <member><type>uint32_t</type>                         <name>index</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionBufferCreateInfoFUCHSIA" structextends="VkBufferCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>VkBufferCollectionFUCHSIA</type>        <name>collection</name></member>
+            <member><type>uint32_t</type>                         <name>index</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionCreateInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*      <name>pNext</name></member>
+            <member><type>zx_handle_t</type>                      <name>collectionToken</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionPropertiesFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*            <name>pNext</name></member>
+            <member><type>uint32_t</type>                         <name>memoryTypeBits</name></member>
+            <member><type>uint32_t</type>                         <name>bufferCount</name></member>
+            <member><type>uint32_t</type>                         <name>createInfoIndex</name></member>
+            <member><type>uint64_t</type>                         <name>sysmemPixelFormat</name></member>
+            <member><type>VkFormatFeatureFlags</type>             <name>formatFeatures</name></member>
+            <member><type>VkSysmemColorSpaceFUCHSIA</type>        <name>sysmemColorSpaceIndex</name></member>
+            <member><type>VkComponentMapping</type>               <name>samplerYcbcrConversionComponents</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type>    <name>suggestedYcbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>              <name>suggestedYcbcrRange</name></member>
+            <member><type>VkChromaLocation</type>                 <name>suggestedXChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>                 <name>suggestedYChromaOffset</name></member>
+        </type>
+        <type category="struct" name="VkBufferConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*               <name>pNext</name></member>
+            <member><type>VkBufferCreateInfo</type>                        <name>createInfo</name></member>
+            <member optional="true"><type>VkFormatFeatureFlags</type>      <name>requiredFormatFeatures</name></member>
+            <member><type>VkBufferCollectionConstraintsInfoFUCHSIA</type>  <name>bufferCollectionConstraints</name></member>
+        </type>
+        <type category="struct" name="VkSysmemColorSpaceFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member><type>uint32_t</type>                        <name>colorSpace</name></member>
+        </type>
+        <type category="struct" name="VkImageFormatConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                            <name>pNext</name></member>
+            <member><type>VkImageCreateInfo</type>                                      <name>imageCreateInfo</name></member>
+            <member><type>VkFormatFeatureFlags</type>                                   <name>requiredFormatFeatures</name></member>
+            <member optional="true"><type>VkImageFormatConstraintsFlagsFUCHSIA</type>   <name>flags</name></member>
+            <member optional="true"><type>uint64_t</type>                               <name>sysmemPixelFormat</name></member>
+            <member><type>uint32_t</type>                                               <name>colorSpaceCount</name></member>
+            <member>const <type>VkSysmemColorSpaceFUCHSIA</type>*                       <name>pColorSpaces</name></member>
+        </type>
+        <type category="struct" name="VkImageConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                      <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                         <name>formatConstraintsCount</name></member>
+            <member len="formatConstraintsCount">const <type>VkImageFormatConstraintsInfoFUCHSIA</type>* <name>pFormatConstraints</name></member>
+            <member><type>VkBufferCollectionConstraintsInfoFUCHSIA</type>                         <name>bufferCollectionConstraints</name></member>
+            <member optional="true"><type>VkImageConstraintsInfoFlagsFUCHSIA</type>               <name>flags</name></member>
+        </type>
+        <type category="struct" name="VkBufferCollectionConstraintsInfoFUCHSIA">
+            <member values="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*     <name>pNext</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCount</name></member>
+            <member><type>uint32_t</type>                        <name>maxBufferCount</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCountForCamping</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCountForDedicatedSlack</name></member>
+            <member><type>uint32_t</type>                        <name>minBufferCountForSharedSlack</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*        <name>pNext</name></member>
+            <member><type>VkBool32</type>                           <name>formatRgba10x6WithoutYCbCrSampler</name></member>
+        </type>
+        <type category="struct" name="VkFormatProperties3KHR" returnedonly="true" structextends="VkFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                            <name>pNext</name></member>
+            <member optional="true"><type>VkFormatFeatureFlags2KHR</type>         <name>linearTilingFeatures</name></member>
+            <member optional="true"><type>VkFormatFeatureFlags2KHR</type>         <name>optimalTilingFeatures</name></member>
+            <member optional="true"><type>VkFormatFeatureFlags2KHR</type>         <name>bufferFeatures</name></member>
+        </type>
+        <type category="struct" name="VkDrmFormatModifierPropertiesList2EXT" returnedonly="true" structextends="VkFormatProperties2">
+            <member values="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>* <name>pNext</name></member>
+            <member optional="true"><type>uint32_t</type> <name>drmFormatModifierCount</name></member>
+            <member optional="true,false" len="drmFormatModifierCount"><type>VkDrmFormatModifierProperties2EXT</type>* <name>pDrmFormatModifierProperties</name></member>
+        </type>
+        <type category="struct" name="VkDrmFormatModifierProperties2EXT" returnedonly="true">
+            <member><type>uint64_t</type> <name>drmFormatModifier</name></member>
+            <member><type>uint32_t</type> <name>drmFormatModifierPlaneCount</name></member>
+            <member><type>VkFormatFeatureFlags2KHR</type> <name>drmFormatModifierTilingFeatures</name></member>
+        </type>
+        <type category="struct" name="VkAndroidHardwareBufferFormatProperties2ANDROID" structextends="VkAndroidHardwareBufferPropertiesANDROID" returnedonly="true">
+            <member values="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true"><type>void</type>*                              <name>pNext</name></member>
+            <member><type>VkFormat</type>                           <name>format</name></member>
+            <member><type>uint64_t</type>                           <name>externalFormat</name></member>
+            <member><type>VkFormatFeatureFlags2KHR</type>           <name>formatFeatures</name></member>
+            <member><type>VkComponentMapping</type>                 <name>samplerYcbcrConversionComponents</name></member>
+            <member><type>VkSamplerYcbcrModelConversion</type>      <name>suggestedYcbcrModel</name></member>
+            <member><type>VkSamplerYcbcrRange</type>                <name>suggestedYcbcrRange</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedXChromaOffset</name></member>
+            <member><type>VkChromaLocation</type>                   <name>suggestedYChromaOffset</name></member>
+        </type>
+        <type category="struct" name="VkPipelineRenderingCreateInfoKHR" structextends="VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkFormat</type>*                                 <name>pColorAttachmentFormats</name></member>
+            <member><type>VkFormat</type>                                                                   <name>depthAttachmentFormat</name></member>
+            <member><type>VkFormat</type>                                                                   <name>stencilAttachmentFormat</name></member>
+        </type>
+        <type category="struct" name="VkRenderingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_INFO_KHR"><type>VkStructureType</type>              <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member optional="true"><type>VkRenderingFlagsKHR</type>                                        <name>flags</name></member>
+            <member><type>VkRect2D</type>                                                                   <name>renderArea</name></member>
+            <member><type>uint32_t</type>                                                                   <name>layerCount</name></member>
+            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
+            <member optional="true"><type>uint32_t</type>                                                   <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkRenderingAttachmentInfoKHR</type>*             <name>pColorAttachments</name></member>
+            <member optional="true">const <type>VkRenderingAttachmentInfoKHR</type>*                        <name>pDepthAttachment</name></member>
+            <member optional="true">const <type>VkRenderingAttachmentInfoKHR</type>*                        <name>pStencilAttachment</name></member>
+        </type>
+        <type category="struct" name="VkRenderingAttachmentInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR"><type>VkStructureType</type>   <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member optional="true"><type>VkImageView</type>                                                <name>imageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
+            <member optional="true"><type>VkResolveModeFlagBits</type>                                      <name>resolveMode</name></member>
+            <member optional="true"><type>VkImageView</type>                                                <name>resolveImageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>resolveImageLayout</name></member>
+            <member><type>VkAttachmentLoadOp</type>                                                         <name>loadOp</name></member>
+            <member><type>VkAttachmentStoreOp</type>                                                        <name>storeOp</name></member>
+            <member><type>VkClearValue</type>                                                               <name>clearValue</name></member>
+        </type>
+        <type category="struct" name="VkRenderingFragmentShadingRateAttachmentInfoKHR" structextends="VkRenderingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member  optional="true">const <type>void</type>*                                               <name>pNext</name></member>
+            <member optional="true"><type>VkImageView</type>                                                <name>imageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
+            <member><type>VkExtent2D</type>                                                                 <name>shadingRateAttachmentTexelSize</name></member>
+        </type>
+        <type category="struct" name="VkRenderingFragmentDensityMapAttachmentInfoEXT" structextends="VkRenderingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>VkImageView</type>                                                                <name>imageView</name></member>
+            <member><type>VkImageLayout</type>                                                              <name>imageLayout</name></member>
+        </type>
+        <type category="struct" name="VkPhysicalDeviceDynamicRenderingFeaturesKHR" structextends="VkPhysicalDeviceFeatures2,VkDeviceCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true" noautovalidity="true"><type>void</type>*                                <name>pNext</name></member>
+            <member><type>VkBool32</type>                                                                   <name>dynamicRendering</name></member>
+        </type>
+        <type category="struct" name="VkCommandBufferInheritanceRenderingInfoKHR" structextends="VkCommandBufferInheritanceInfo">
+            <member values="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member optional="true"><type>VkRenderingFlagsKHR</type>                                        <name>flags</name></member>
+            <member><type>uint32_t</type>                                                                   <name>viewMask</name></member>
+            <member><type>uint32_t</type>                                                                   <name>colorAttachmentCount</name></member>
+            <member len="colorAttachmentCount">const <type>VkFormat</type>*                                 <name>pColorAttachmentFormats</name></member>
+            <member><type>VkFormat</type>                                                                   <name>depthAttachmentFormat</name></member>
+            <member><type>VkFormat</type>                                                                   <name>stencilAttachmentFormat</name></member>
+            <member optional="true"><type>VkSampleCountFlagBits</type>                                      <name>rasterizationSamples</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentSampleCountInfoAMD" structextends="VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo">
+            <member values="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*                                                <name>pNext</name></member>
+            <member><type>uint32_t</type>                                                                   <name>colorAttachmentCount</name></member>
+            <member optional="false,true" len="colorAttachmentCount">const <type>VkSampleCountFlagBits</type>* <name>pColorAttachmentSamples</name></member>
+            <member optional="true"><type>VkSampleCountFlagBits</type>                                      <name>depthStencilAttachmentSamples</name></member>
+        </type>
+        <type category="struct" name="VkAttachmentSampleCountInfoNV" alias="VkAttachmentSampleCountInfoAMD"/>
+        <type category="struct" name="VkMultiviewPerViewAttributesInfoNVX" structextends="VkCommandBufferInheritanceInfo,VkGraphicsPipelineCreateInfo,VkRenderingInfoKHR">
+            <member values="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"><type>VkStructureType</type> <name>sType</name></member>
+            <member optional="true">const <type>void</type>*            <name>pNext</name></member>
+            <member><type>VkBool32</type>                               <name>perViewAttributes</name></member>
+            <member><type>VkBool32</type>                               <name>perViewAttributesPositionXOnly</name></member>
+        </type>
+    </types>
+    <comment>Vulkan enumerant (token) definitions</comment>
+
+    <enums name="API Constants" comment="Vulkan hardcoded constants - not an enumerated type, part of the header boilerplate">
+        <enum type="uint32_t" value="256"       name="VK_MAX_PHYSICAL_DEVICE_NAME_SIZE"/>
+        <enum type="uint32_t" value="16"        name="VK_UUID_SIZE"/>
+        <enum type="uint32_t" value="8"         name="VK_LUID_SIZE"/>
+        <enum                                   name="VK_LUID_SIZE_KHR" alias="VK_LUID_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_EXTENSION_NAME_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_DESCRIPTION_SIZE"/>
+        <enum type="uint32_t" value="32"        name="VK_MAX_MEMORY_TYPES"/>
+        <enum type="uint32_t" value="16"        name="VK_MAX_MEMORY_HEAPS" comment="The maximum number of unique memory heaps, each of which supporting 1 or more memory types"/>
+        <enum type="float"    value="1000.0F"   name="VK_LOD_CLAMP_NONE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_MIP_LEVELS"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_REMAINING_ARRAY_LAYERS"/>
+        <enum type="uint64_t" value="(~0ULL)"   name="VK_WHOLE_SIZE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_ATTACHMENT_UNUSED"/>
+        <enum type="uint32_t" value="1"         name="VK_TRUE"/>
+        <enum type="uint32_t" value="0"         name="VK_FALSE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_QUEUE_FAMILY_IGNORED"/>
+        <enum type="uint32_t" value="(~1U)"     name="VK_QUEUE_FAMILY_EXTERNAL"/>
+        <enum                                   name="VK_QUEUE_FAMILY_EXTERNAL_KHR" alias="VK_QUEUE_FAMILY_EXTERNAL"/>
+        <enum type="uint32_t" value="(~2U)"     name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_SUBPASS_EXTERNAL"/>
+        <enum type="uint32_t" value="32"        name="VK_MAX_DEVICE_GROUP_SIZE"/>
+        <enum                                   name="VK_MAX_DEVICE_GROUP_SIZE_KHR" alias="VK_MAX_DEVICE_GROUP_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_DRIVER_NAME_SIZE"/>
+        <enum                                   name="VK_MAX_DRIVER_NAME_SIZE_KHR" alias="VK_MAX_DRIVER_NAME_SIZE"/>
+        <enum type="uint32_t" value="256"       name="VK_MAX_DRIVER_INFO_SIZE"/>
+        <enum                                   name="VK_MAX_DRIVER_INFO_SIZE_KHR" alias="VK_MAX_DRIVER_INFO_SIZE"/>
+        <enum type="uint32_t" value="(~0U)"     name="VK_SHADER_UNUSED_KHR"/>
+        <enum                                   name="VK_SHADER_UNUSED_NV" alias="VK_SHADER_UNUSED_KHR"/>
+        <enum type="uint32_t" value="16"        name="VK_MAX_GLOBAL_PRIORITY_SIZE_EXT"/>
+    </enums>
+
+    <comment>
+        Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
+        their own numeric namespaces. The "name" attribute is the C enum
+        type name, and is pulled in from a type tag definition above
+        (slightly clunky, but retains the type / enum distinction). "type"
+        attributes of "enum" or "bitmask" indicate that these values should
+        be generated inside an appropriate definition.
+    </comment>
+
+    <enums name="VkImageLayout" type="enum">
+        <enum value="0"     name="VK_IMAGE_LAYOUT_UNDEFINED"                         comment="Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)"/>
+        <enum value="1"     name="VK_IMAGE_LAYOUT_GENERAL"                           comment="General layout when image can be used for any kind of access"/>
+        <enum value="2"     name="VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL"          comment="Optimal layout when image is only used for color attachment read/write"/>
+        <enum value="3"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL"  comment="Optimal layout when image is only used for depth/stencil attachment read/write"/>
+        <enum value="4"     name="VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL"   comment="Optimal layout when image is used for read only depth/stencil attachment and shader access"/>
+        <enum value="5"     name="VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL"          comment="Optimal layout when image is used for read only shader access"/>
+        <enum value="6"     name="VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL"              comment="Optimal layout when image is used only as source of transfer operations"/>
+        <enum value="7"     name="VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL"              comment="Optimal layout when image is used only as destination of transfer operations"/>
+        <enum value="8"     name="VK_IMAGE_LAYOUT_PREINITIALIZED"                    comment="Initial layout used when the data is populated by the CPU"/>
+    </enums>
+    <enums name="VkAttachmentLoadOp" type="enum">
+        <enum value="0"     name="VK_ATTACHMENT_LOAD_OP_LOAD"/>
+        <enum value="1"     name="VK_ATTACHMENT_LOAD_OP_CLEAR"/>
+        <enum value="2"     name="VK_ATTACHMENT_LOAD_OP_DONT_CARE"/>
+    </enums>
+    <enums name="VkAttachmentStoreOp" type="enum">
+        <enum value="0"     name="VK_ATTACHMENT_STORE_OP_STORE"/>
+        <enum value="1"     name="VK_ATTACHMENT_STORE_OP_DONT_CARE"/>
+    </enums>
+    <enums name="VkImageType" type="enum">
+        <enum value="0"     name="VK_IMAGE_TYPE_1D"/>
+        <enum value="1"     name="VK_IMAGE_TYPE_2D"/>
+        <enum value="2"     name="VK_IMAGE_TYPE_3D"/>
+    </enums>
+    <enums name="VkImageTiling" type="enum">
+        <enum value="0"     name="VK_IMAGE_TILING_OPTIMAL"/>
+        <enum value="1"     name="VK_IMAGE_TILING_LINEAR"/>
+    </enums>
+    <enums name="VkImageViewType" type="enum">
+        <enum value="0"     name="VK_IMAGE_VIEW_TYPE_1D"/>
+        <enum value="1"     name="VK_IMAGE_VIEW_TYPE_2D"/>
+        <enum value="2"     name="VK_IMAGE_VIEW_TYPE_3D"/>
+        <enum value="3"     name="VK_IMAGE_VIEW_TYPE_CUBE"/>
+        <enum value="4"     name="VK_IMAGE_VIEW_TYPE_1D_ARRAY"/>
+        <enum value="5"     name="VK_IMAGE_VIEW_TYPE_2D_ARRAY"/>
+        <enum value="6"     name="VK_IMAGE_VIEW_TYPE_CUBE_ARRAY"/>
+    </enums>
+    <enums name="VkCommandBufferLevel" type="enum">
+        <enum value="0"     name="VK_COMMAND_BUFFER_LEVEL_PRIMARY"/>
+        <enum value="1"     name="VK_COMMAND_BUFFER_LEVEL_SECONDARY"/>
+    </enums>
+    <enums name="VkComponentSwizzle" type="enum">
+        <enum value="0"     name="VK_COMPONENT_SWIZZLE_IDENTITY"/>
+        <enum value="1"     name="VK_COMPONENT_SWIZZLE_ZERO"/>
+        <enum value="2"     name="VK_COMPONENT_SWIZZLE_ONE"/>
+        <enum value="3"     name="VK_COMPONENT_SWIZZLE_R"/>
+        <enum value="4"     name="VK_COMPONENT_SWIZZLE_G"/>
+        <enum value="5"     name="VK_COMPONENT_SWIZZLE_B"/>
+        <enum value="6"     name="VK_COMPONENT_SWIZZLE_A"/>
+    </enums>
+    <enums name="VkDescriptorType" type="enum">
+        <enum value="0"     name="VK_DESCRIPTOR_TYPE_SAMPLER"/>
+        <enum value="1"     name="VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER"/>
+        <enum value="2"     name="VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE"/>
+        <enum value="3"     name="VK_DESCRIPTOR_TYPE_STORAGE_IMAGE"/>
+        <enum value="4"     name="VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER"/>
+        <enum value="5"     name="VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER"/>
+        <enum value="6"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER"/>
+        <enum value="7"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER"/>
+        <enum value="8"     name="VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC"/>
+        <enum value="9"     name="VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC"/>
+        <enum value="10"    name="VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT"/>
+    </enums>
+    <enums name="VkQueryType" type="enum">
+        <enum value="0"     name="VK_QUERY_TYPE_OCCLUSION"/>
+        <enum value="1"     name="VK_QUERY_TYPE_PIPELINE_STATISTICS"                 comment="Optional"/>
+        <enum value="2"     name="VK_QUERY_TYPE_TIMESTAMP"/>
+    </enums>
+    <enums name="VkBorderColor" type="enum">
+        <enum value="0"     name="VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK"/>
+        <enum value="1"     name="VK_BORDER_COLOR_INT_TRANSPARENT_BLACK"/>
+        <enum value="2"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK"/>
+        <enum value="3"     name="VK_BORDER_COLOR_INT_OPAQUE_BLACK"/>
+        <enum value="4"     name="VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE"/>
+        <enum value="5"     name="VK_BORDER_COLOR_INT_OPAQUE_WHITE"/>
+    </enums>
+    <enums name="VkPipelineBindPoint" type="enum">
+        <enum value="0"     name="VK_PIPELINE_BIND_POINT_GRAPHICS"/>
+        <enum value="1"     name="VK_PIPELINE_BIND_POINT_COMPUTE"/>
+    </enums>
+    <enums name="VkPipelineCacheHeaderVersion" type="enum">
+        <enum value="1"     name="VK_PIPELINE_CACHE_HEADER_VERSION_ONE"/>
+    </enums>
+    <enums name="VkPipelineCacheCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPrimitiveTopology" type="enum">
+        <enum value="0"     name="VK_PRIMITIVE_TOPOLOGY_POINT_LIST"/>
+        <enum value="1"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST"/>
+        <enum value="2"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP"/>
+        <enum value="3"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST"/>
+        <enum value="4"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP"/>
+        <enum value="5"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN"/>
+        <enum value="6"     name="VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY"/>
+        <enum value="7"     name="VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY"/>
+        <enum value="8"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY"/>
+        <enum value="9"     name="VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY"/>
+        <enum value="10"    name="VK_PRIMITIVE_TOPOLOGY_PATCH_LIST"/>
+    </enums>
+    <enums name="VkSharingMode" type="enum">
+        <enum value="0"     name="VK_SHARING_MODE_EXCLUSIVE"/>
+        <enum value="1"     name="VK_SHARING_MODE_CONCURRENT"/>
+    </enums>
+    <enums name="VkIndexType" type="enum">
+        <enum value="0"     name="VK_INDEX_TYPE_UINT16"/>
+        <enum value="1"     name="VK_INDEX_TYPE_UINT32"/>
+    </enums>
+    <enums name="VkFilter" type="enum">
+        <enum value="0"     name="VK_FILTER_NEAREST"/>
+        <enum value="1"     name="VK_FILTER_LINEAR"/>
+    </enums>
+    <enums name="VkSamplerMipmapMode" type="enum">
+        <enum value="0"     name="VK_SAMPLER_MIPMAP_MODE_NEAREST"                        comment="Choose nearest mip level"/>
+        <enum value="1"     name="VK_SAMPLER_MIPMAP_MODE_LINEAR"                         comment="Linear filter between mip levels"/>
+    </enums>
+    <enums name="VkSamplerAddressMode" type="enum">
+        <enum value="0"     name="VK_SAMPLER_ADDRESS_MODE_REPEAT"/>
+        <enum value="1"     name="VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT"/>
+        <enum value="2"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE"/>
+        <enum value="3"     name="VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER"/>
+            <comment>
+                value="4" reserved for VK_KHR_sampler_mirror_clamp_to_edge
+                enum VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; do not
+                alias!
+            </comment>
+    </enums>
+    <enums name="VkCompareOp" type="enum">
+        <enum value="0"     name="VK_COMPARE_OP_NEVER"/>
+        <enum value="1"     name="VK_COMPARE_OP_LESS"/>
+        <enum value="2"     name="VK_COMPARE_OP_EQUAL"/>
+        <enum value="3"     name="VK_COMPARE_OP_LESS_OR_EQUAL"/>
+        <enum value="4"     name="VK_COMPARE_OP_GREATER"/>
+        <enum value="5"     name="VK_COMPARE_OP_NOT_EQUAL"/>
+        <enum value="6"     name="VK_COMPARE_OP_GREATER_OR_EQUAL"/>
+        <enum value="7"     name="VK_COMPARE_OP_ALWAYS"/>
+    </enums>
+    <enums name="VkPolygonMode" type="enum">
+        <enum value="0"     name="VK_POLYGON_MODE_FILL"/>
+        <enum value="1"     name="VK_POLYGON_MODE_LINE"/>
+        <enum value="2"     name="VK_POLYGON_MODE_POINT"/>
+    </enums>
+    <enums name="VkFrontFace" type="enum">
+        <enum value="0"     name="VK_FRONT_FACE_COUNTER_CLOCKWISE"/>
+        <enum value="1"     name="VK_FRONT_FACE_CLOCKWISE"/>
+    </enums>
+    <enums name="VkBlendFactor" type="enum">
+        <enum value="0"     name="VK_BLEND_FACTOR_ZERO"/>
+        <enum value="1"     name="VK_BLEND_FACTOR_ONE"/>
+        <enum value="2"     name="VK_BLEND_FACTOR_SRC_COLOR"/>
+        <enum value="3"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR"/>
+        <enum value="4"     name="VK_BLEND_FACTOR_DST_COLOR"/>
+        <enum value="5"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR"/>
+        <enum value="6"     name="VK_BLEND_FACTOR_SRC_ALPHA"/>
+        <enum value="7"     name="VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA"/>
+        <enum value="8"     name="VK_BLEND_FACTOR_DST_ALPHA"/>
+        <enum value="9"     name="VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA"/>
+        <enum value="10"    name="VK_BLEND_FACTOR_CONSTANT_COLOR"/>
+        <enum value="11"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR"/>
+        <enum value="12"    name="VK_BLEND_FACTOR_CONSTANT_ALPHA"/>
+        <enum value="13"    name="VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA"/>
+        <enum value="14"    name="VK_BLEND_FACTOR_SRC_ALPHA_SATURATE"/>
+        <enum value="15"    name="VK_BLEND_FACTOR_SRC1_COLOR"/>
+        <enum value="16"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR"/>
+        <enum value="17"    name="VK_BLEND_FACTOR_SRC1_ALPHA"/>
+        <enum value="18"    name="VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA"/>
+    </enums>
+    <enums name="VkBlendOp" type="enum">
+        <enum value="0"     name="VK_BLEND_OP_ADD"/>
+        <enum value="1"     name="VK_BLEND_OP_SUBTRACT"/>
+        <enum value="2"     name="VK_BLEND_OP_REVERSE_SUBTRACT"/>
+        <enum value="3"     name="VK_BLEND_OP_MIN"/>
+        <enum value="4"     name="VK_BLEND_OP_MAX"/>
+    </enums>
+    <enums name="VkStencilOp" type="enum">
+        <enum value="0"     name="VK_STENCIL_OP_KEEP"/>
+        <enum value="1"     name="VK_STENCIL_OP_ZERO"/>
+        <enum value="2"     name="VK_STENCIL_OP_REPLACE"/>
+        <enum value="3"     name="VK_STENCIL_OP_INCREMENT_AND_CLAMP"/>
+        <enum value="4"     name="VK_STENCIL_OP_DECREMENT_AND_CLAMP"/>
+        <enum value="5"     name="VK_STENCIL_OP_INVERT"/>
+        <enum value="6"     name="VK_STENCIL_OP_INCREMENT_AND_WRAP"/>
+        <enum value="7"     name="VK_STENCIL_OP_DECREMENT_AND_WRAP"/>
+    </enums>
+    <enums name="VkLogicOp" type="enum">
+        <enum value="0"     name="VK_LOGIC_OP_CLEAR"/>
+        <enum value="1"     name="VK_LOGIC_OP_AND"/>
+        <enum value="2"     name="VK_LOGIC_OP_AND_REVERSE"/>
+        <enum value="3"     name="VK_LOGIC_OP_COPY"/>
+        <enum value="4"     name="VK_LOGIC_OP_AND_INVERTED"/>
+        <enum value="5"     name="VK_LOGIC_OP_NO_OP"/>
+        <enum value="6"     name="VK_LOGIC_OP_XOR"/>
+        <enum value="7"     name="VK_LOGIC_OP_OR"/>
+        <enum value="8"     name="VK_LOGIC_OP_NOR"/>
+        <enum value="9"     name="VK_LOGIC_OP_EQUIVALENT"/>
+        <enum value="10"    name="VK_LOGIC_OP_INVERT"/>
+        <enum value="11"    name="VK_LOGIC_OP_OR_REVERSE"/>
+        <enum value="12"    name="VK_LOGIC_OP_COPY_INVERTED"/>
+        <enum value="13"    name="VK_LOGIC_OP_OR_INVERTED"/>
+        <enum value="14"    name="VK_LOGIC_OP_NAND"/>
+        <enum value="15"    name="VK_LOGIC_OP_SET"/>
+    </enums>
+    <enums name="VkInternalAllocationType" type="enum">
+        <enum value="0"     name="VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE"/>
+    </enums>
+    <enums name="VkSystemAllocationScope" type="enum">
+        <enum value="0"     name="VK_SYSTEM_ALLOCATION_SCOPE_COMMAND"/>
+        <enum value="1"     name="VK_SYSTEM_ALLOCATION_SCOPE_OBJECT"/>
+        <enum value="2"     name="VK_SYSTEM_ALLOCATION_SCOPE_CACHE"/>
+        <enum value="3"     name="VK_SYSTEM_ALLOCATION_SCOPE_DEVICE"/>
+        <enum value="4"     name="VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE"/>
+    </enums>
+    <enums name="VkPhysicalDeviceType" type="enum">
+        <enum value="0"     name="VK_PHYSICAL_DEVICE_TYPE_OTHER"/>
+        <enum value="1"     name="VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU"/>
+        <enum value="2"     name="VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU"/>
+        <enum value="3"     name="VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU"/>
+        <enum value="4"     name="VK_PHYSICAL_DEVICE_TYPE_CPU"/>
+    </enums>
+    <enums name="VkVertexInputRate" type="enum">
+        <enum value="0"     name="VK_VERTEX_INPUT_RATE_VERTEX"/>
+        <enum value="1"     name="VK_VERTEX_INPUT_RATE_INSTANCE"/>
+    </enums>
+    <enums name="VkFormat" type="enum" comment="Vulkan format definitions">
+        <enum value="0"     name="VK_FORMAT_UNDEFINED"/>
+        <enum value="1"     name="VK_FORMAT_R4G4_UNORM_PACK8"/>
+        <enum value="2"     name="VK_FORMAT_R4G4B4A4_UNORM_PACK16"/>
+        <enum value="3"     name="VK_FORMAT_B4G4R4A4_UNORM_PACK16"/>
+        <enum value="4"     name="VK_FORMAT_R5G6B5_UNORM_PACK16"/>
+        <enum value="5"     name="VK_FORMAT_B5G6R5_UNORM_PACK16"/>
+        <enum value="6"     name="VK_FORMAT_R5G5B5A1_UNORM_PACK16"/>
+        <enum value="7"     name="VK_FORMAT_B5G5R5A1_UNORM_PACK16"/>
+        <enum value="8"     name="VK_FORMAT_A1R5G5B5_UNORM_PACK16"/>
+        <enum value="9"     name="VK_FORMAT_R8_UNORM"/>
+        <enum value="10"    name="VK_FORMAT_R8_SNORM"/>
+        <enum value="11"    name="VK_FORMAT_R8_USCALED"/>
+        <enum value="12"    name="VK_FORMAT_R8_SSCALED"/>
+        <enum value="13"    name="VK_FORMAT_R8_UINT"/>
+        <enum value="14"    name="VK_FORMAT_R8_SINT"/>
+        <enum value="15"    name="VK_FORMAT_R8_SRGB"/>
+        <enum value="16"    name="VK_FORMAT_R8G8_UNORM"/>
+        <enum value="17"    name="VK_FORMAT_R8G8_SNORM"/>
+        <enum value="18"    name="VK_FORMAT_R8G8_USCALED"/>
+        <enum value="19"    name="VK_FORMAT_R8G8_SSCALED"/>
+        <enum value="20"    name="VK_FORMAT_R8G8_UINT"/>
+        <enum value="21"    name="VK_FORMAT_R8G8_SINT"/>
+        <enum value="22"    name="VK_FORMAT_R8G8_SRGB"/>
+        <enum value="23"    name="VK_FORMAT_R8G8B8_UNORM"/>
+        <enum value="24"    name="VK_FORMAT_R8G8B8_SNORM"/>
+        <enum value="25"    name="VK_FORMAT_R8G8B8_USCALED"/>
+        <enum value="26"    name="VK_FORMAT_R8G8B8_SSCALED"/>
+        <enum value="27"    name="VK_FORMAT_R8G8B8_UINT"/>
+        <enum value="28"    name="VK_FORMAT_R8G8B8_SINT"/>
+        <enum value="29"    name="VK_FORMAT_R8G8B8_SRGB"/>
+        <enum value="30"    name="VK_FORMAT_B8G8R8_UNORM"/>
+        <enum value="31"    name="VK_FORMAT_B8G8R8_SNORM"/>
+        <enum value="32"    name="VK_FORMAT_B8G8R8_USCALED"/>
+        <enum value="33"    name="VK_FORMAT_B8G8R8_SSCALED"/>
+        <enum value="34"    name="VK_FORMAT_B8G8R8_UINT"/>
+        <enum value="35"    name="VK_FORMAT_B8G8R8_SINT"/>
+        <enum value="36"    name="VK_FORMAT_B8G8R8_SRGB"/>
+        <enum value="37"    name="VK_FORMAT_R8G8B8A8_UNORM"/>
+        <enum value="38"    name="VK_FORMAT_R8G8B8A8_SNORM"/>
+        <enum value="39"    name="VK_FORMAT_R8G8B8A8_USCALED"/>
+        <enum value="40"    name="VK_FORMAT_R8G8B8A8_SSCALED"/>
+        <enum value="41"    name="VK_FORMAT_R8G8B8A8_UINT"/>
+        <enum value="42"    name="VK_FORMAT_R8G8B8A8_SINT"/>
+        <enum value="43"    name="VK_FORMAT_R8G8B8A8_SRGB"/>
+        <enum value="44"    name="VK_FORMAT_B8G8R8A8_UNORM"/>
+        <enum value="45"    name="VK_FORMAT_B8G8R8A8_SNORM"/>
+        <enum value="46"    name="VK_FORMAT_B8G8R8A8_USCALED"/>
+        <enum value="47"    name="VK_FORMAT_B8G8R8A8_SSCALED"/>
+        <enum value="48"    name="VK_FORMAT_B8G8R8A8_UINT"/>
+        <enum value="49"    name="VK_FORMAT_B8G8R8A8_SINT"/>
+        <enum value="50"    name="VK_FORMAT_B8G8R8A8_SRGB"/>
+        <enum value="51"    name="VK_FORMAT_A8B8G8R8_UNORM_PACK32"/>
+        <enum value="52"    name="VK_FORMAT_A8B8G8R8_SNORM_PACK32"/>
+        <enum value="53"    name="VK_FORMAT_A8B8G8R8_USCALED_PACK32"/>
+        <enum value="54"    name="VK_FORMAT_A8B8G8R8_SSCALED_PACK32"/>
+        <enum value="55"    name="VK_FORMAT_A8B8G8R8_UINT_PACK32"/>
+        <enum value="56"    name="VK_FORMAT_A8B8G8R8_SINT_PACK32"/>
+        <enum value="57"    name="VK_FORMAT_A8B8G8R8_SRGB_PACK32"/>
+        <enum value="58"    name="VK_FORMAT_A2R10G10B10_UNORM_PACK32"/>
+        <enum value="59"    name="VK_FORMAT_A2R10G10B10_SNORM_PACK32"/>
+        <enum value="60"    name="VK_FORMAT_A2R10G10B10_USCALED_PACK32"/>
+        <enum value="61"    name="VK_FORMAT_A2R10G10B10_SSCALED_PACK32"/>
+        <enum value="62"    name="VK_FORMAT_A2R10G10B10_UINT_PACK32"/>
+        <enum value="63"    name="VK_FORMAT_A2R10G10B10_SINT_PACK32"/>
+        <enum value="64"    name="VK_FORMAT_A2B10G10R10_UNORM_PACK32"/>
+        <enum value="65"    name="VK_FORMAT_A2B10G10R10_SNORM_PACK32"/>
+        <enum value="66"    name="VK_FORMAT_A2B10G10R10_USCALED_PACK32"/>
+        <enum value="67"    name="VK_FORMAT_A2B10G10R10_SSCALED_PACK32"/>
+        <enum value="68"    name="VK_FORMAT_A2B10G10R10_UINT_PACK32"/>
+        <enum value="69"    name="VK_FORMAT_A2B10G10R10_SINT_PACK32"/>
+        <enum value="70"    name="VK_FORMAT_R16_UNORM"/>
+        <enum value="71"    name="VK_FORMAT_R16_SNORM"/>
+        <enum value="72"    name="VK_FORMAT_R16_USCALED"/>
+        <enum value="73"    name="VK_FORMAT_R16_SSCALED"/>
+        <enum value="74"    name="VK_FORMAT_R16_UINT"/>
+        <enum value="75"    name="VK_FORMAT_R16_SINT"/>
+        <enum value="76"    name="VK_FORMAT_R16_SFLOAT"/>
+        <enum value="77"    name="VK_FORMAT_R16G16_UNORM"/>
+        <enum value="78"    name="VK_FORMAT_R16G16_SNORM"/>
+        <enum value="79"    name="VK_FORMAT_R16G16_USCALED"/>
+        <enum value="80"    name="VK_FORMAT_R16G16_SSCALED"/>
+        <enum value="81"    name="VK_FORMAT_R16G16_UINT"/>
+        <enum value="82"    name="VK_FORMAT_R16G16_SINT"/>
+        <enum value="83"    name="VK_FORMAT_R16G16_SFLOAT"/>
+        <enum value="84"    name="VK_FORMAT_R16G16B16_UNORM"/>
+        <enum value="85"    name="VK_FORMAT_R16G16B16_SNORM"/>
+        <enum value="86"    name="VK_FORMAT_R16G16B16_USCALED"/>
+        <enum value="87"    name="VK_FORMAT_R16G16B16_SSCALED"/>
+        <enum value="88"    name="VK_FORMAT_R16G16B16_UINT"/>
+        <enum value="89"    name="VK_FORMAT_R16G16B16_SINT"/>
+        <enum value="90"    name="VK_FORMAT_R16G16B16_SFLOAT"/>
+        <enum value="91"    name="VK_FORMAT_R16G16B16A16_UNORM"/>
+        <enum value="92"    name="VK_FORMAT_R16G16B16A16_SNORM"/>
+        <enum value="93"    name="VK_FORMAT_R16G16B16A16_USCALED"/>
+        <enum value="94"    name="VK_FORMAT_R16G16B16A16_SSCALED"/>
+        <enum value="95"    name="VK_FORMAT_R16G16B16A16_UINT"/>
+        <enum value="96"    name="VK_FORMAT_R16G16B16A16_SINT"/>
+        <enum value="97"    name="VK_FORMAT_R16G16B16A16_SFLOAT"/>
+        <enum value="98"    name="VK_FORMAT_R32_UINT"/>
+        <enum value="99"    name="VK_FORMAT_R32_SINT"/>
+        <enum value="100"   name="VK_FORMAT_R32_SFLOAT"/>
+        <enum value="101"   name="VK_FORMAT_R32G32_UINT"/>
+        <enum value="102"   name="VK_FORMAT_R32G32_SINT"/>
+        <enum value="103"   name="VK_FORMAT_R32G32_SFLOAT"/>
+        <enum value="104"   name="VK_FORMAT_R32G32B32_UINT"/>
+        <enum value="105"   name="VK_FORMAT_R32G32B32_SINT"/>
+        <enum value="106"   name="VK_FORMAT_R32G32B32_SFLOAT"/>
+        <enum value="107"   name="VK_FORMAT_R32G32B32A32_UINT"/>
+        <enum value="108"   name="VK_FORMAT_R32G32B32A32_SINT"/>
+        <enum value="109"   name="VK_FORMAT_R32G32B32A32_SFLOAT"/>
+        <enum value="110"   name="VK_FORMAT_R64_UINT"/>
+        <enum value="111"   name="VK_FORMAT_R64_SINT"/>
+        <enum value="112"   name="VK_FORMAT_R64_SFLOAT"/>
+        <enum value="113"   name="VK_FORMAT_R64G64_UINT"/>
+        <enum value="114"   name="VK_FORMAT_R64G64_SINT"/>
+        <enum value="115"   name="VK_FORMAT_R64G64_SFLOAT"/>
+        <enum value="116"   name="VK_FORMAT_R64G64B64_UINT"/>
+        <enum value="117"   name="VK_FORMAT_R64G64B64_SINT"/>
+        <enum value="118"   name="VK_FORMAT_R64G64B64_SFLOAT"/>
+        <enum value="119"   name="VK_FORMAT_R64G64B64A64_UINT"/>
+        <enum value="120"   name="VK_FORMAT_R64G64B64A64_SINT"/>
+        <enum value="121"   name="VK_FORMAT_R64G64B64A64_SFLOAT"/>
+        <enum value="122"   name="VK_FORMAT_B10G11R11_UFLOAT_PACK32"/>
+        <enum value="123"   name="VK_FORMAT_E5B9G9R9_UFLOAT_PACK32"/>
+        <enum value="124"   name="VK_FORMAT_D16_UNORM"/>
+        <enum value="125"   name="VK_FORMAT_X8_D24_UNORM_PACK32"/>
+        <enum value="126"   name="VK_FORMAT_D32_SFLOAT"/>
+        <enum value="127"   name="VK_FORMAT_S8_UINT"/>
+        <enum value="128"   name="VK_FORMAT_D16_UNORM_S8_UINT"/>
+        <enum value="129"   name="VK_FORMAT_D24_UNORM_S8_UINT"/>
+        <enum value="130"   name="VK_FORMAT_D32_SFLOAT_S8_UINT"/>
+        <enum value="131"   name="VK_FORMAT_BC1_RGB_UNORM_BLOCK"/>
+        <enum value="132"   name="VK_FORMAT_BC1_RGB_SRGB_BLOCK"/>
+        <enum value="133"   name="VK_FORMAT_BC1_RGBA_UNORM_BLOCK"/>
+        <enum value="134"   name="VK_FORMAT_BC1_RGBA_SRGB_BLOCK"/>
+        <enum value="135"   name="VK_FORMAT_BC2_UNORM_BLOCK"/>
+        <enum value="136"   name="VK_FORMAT_BC2_SRGB_BLOCK"/>
+        <enum value="137"   name="VK_FORMAT_BC3_UNORM_BLOCK"/>
+        <enum value="138"   name="VK_FORMAT_BC3_SRGB_BLOCK"/>
+        <enum value="139"   name="VK_FORMAT_BC4_UNORM_BLOCK"/>
+        <enum value="140"   name="VK_FORMAT_BC4_SNORM_BLOCK"/>
+        <enum value="141"   name="VK_FORMAT_BC5_UNORM_BLOCK"/>
+        <enum value="142"   name="VK_FORMAT_BC5_SNORM_BLOCK"/>
+        <enum value="143"   name="VK_FORMAT_BC6H_UFLOAT_BLOCK"/>
+        <enum value="144"   name="VK_FORMAT_BC6H_SFLOAT_BLOCK"/>
+        <enum value="145"   name="VK_FORMAT_BC7_UNORM_BLOCK"/>
+        <enum value="146"   name="VK_FORMAT_BC7_SRGB_BLOCK"/>
+        <enum value="147"   name="VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK"/>
+        <enum value="148"   name="VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK"/>
+        <enum value="149"   name="VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK"/>
+        <enum value="150"   name="VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK"/>
+        <enum value="151"   name="VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK"/>
+        <enum value="152"   name="VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK"/>
+        <enum value="153"   name="VK_FORMAT_EAC_R11_UNORM_BLOCK"/>
+        <enum value="154"   name="VK_FORMAT_EAC_R11_SNORM_BLOCK"/>
+        <enum value="155"   name="VK_FORMAT_EAC_R11G11_UNORM_BLOCK"/>
+        <enum value="156"   name="VK_FORMAT_EAC_R11G11_SNORM_BLOCK"/>
+        <enum value="157"   name="VK_FORMAT_ASTC_4x4_UNORM_BLOCK"/>
+        <enum value="158"   name="VK_FORMAT_ASTC_4x4_SRGB_BLOCK"/>
+        <enum value="159"   name="VK_FORMAT_ASTC_5x4_UNORM_BLOCK"/>
+        <enum value="160"   name="VK_FORMAT_ASTC_5x4_SRGB_BLOCK"/>
+        <enum value="161"   name="VK_FORMAT_ASTC_5x5_UNORM_BLOCK"/>
+        <enum value="162"   name="VK_FORMAT_ASTC_5x5_SRGB_BLOCK"/>
+        <enum value="163"   name="VK_FORMAT_ASTC_6x5_UNORM_BLOCK"/>
+        <enum value="164"   name="VK_FORMAT_ASTC_6x5_SRGB_BLOCK"/>
+        <enum value="165"   name="VK_FORMAT_ASTC_6x6_UNORM_BLOCK"/>
+        <enum value="166"   name="VK_FORMAT_ASTC_6x6_SRGB_BLOCK"/>
+        <enum value="167"   name="VK_FORMAT_ASTC_8x5_UNORM_BLOCK"/>
+        <enum value="168"   name="VK_FORMAT_ASTC_8x5_SRGB_BLOCK"/>
+        <enum value="169"   name="VK_FORMAT_ASTC_8x6_UNORM_BLOCK"/>
+        <enum value="170"   name="VK_FORMAT_ASTC_8x6_SRGB_BLOCK"/>
+        <enum value="171"   name="VK_FORMAT_ASTC_8x8_UNORM_BLOCK"/>
+        <enum value="172"   name="VK_FORMAT_ASTC_8x8_SRGB_BLOCK"/>
+        <enum value="173"   name="VK_FORMAT_ASTC_10x5_UNORM_BLOCK"/>
+        <enum value="174"   name="VK_FORMAT_ASTC_10x5_SRGB_BLOCK"/>
+        <enum value="175"   name="VK_FORMAT_ASTC_10x6_UNORM_BLOCK"/>
+        <enum value="176"   name="VK_FORMAT_ASTC_10x6_SRGB_BLOCK"/>
+        <enum value="177"   name="VK_FORMAT_ASTC_10x8_UNORM_BLOCK"/>
+        <enum value="178"   name="VK_FORMAT_ASTC_10x8_SRGB_BLOCK"/>
+        <enum value="179"   name="VK_FORMAT_ASTC_10x10_UNORM_BLOCK"/>
+        <enum value="180"   name="VK_FORMAT_ASTC_10x10_SRGB_BLOCK"/>
+        <enum value="181"   name="VK_FORMAT_ASTC_12x10_UNORM_BLOCK"/>
+        <enum value="182"   name="VK_FORMAT_ASTC_12x10_SRGB_BLOCK"/>
+        <enum value="183"   name="VK_FORMAT_ASTC_12x12_UNORM_BLOCK"/>
+        <enum value="184"   name="VK_FORMAT_ASTC_12x12_SRGB_BLOCK"/>
+    </enums>
+    <enums name="VkStructureType" type="enum" comment="Structure type enumerant">
+        <enum value="0"     name="VK_STRUCTURE_TYPE_APPLICATION_INFO"/>
+        <enum value="1"     name="VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO"/>
+        <enum value="2"     name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO"/>
+        <enum value="3"     name="VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO"/>
+        <enum value="4"     name="VK_STRUCTURE_TYPE_SUBMIT_INFO"/>
+        <enum value="5"     name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO"/>
+        <enum value="6"     name="VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE"/>
+        <enum value="7"     name="VK_STRUCTURE_TYPE_BIND_SPARSE_INFO"/>
+        <enum value="8"     name="VK_STRUCTURE_TYPE_FENCE_CREATE_INFO"/>
+        <enum value="9"     name="VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO"/>
+        <enum value="10"    name="VK_STRUCTURE_TYPE_EVENT_CREATE_INFO"/>
+        <enum value="11"    name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO"/>
+        <enum value="12"    name="VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO"/>
+        <enum value="13"    name="VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO"/>
+        <enum value="14"    name="VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO"/>
+        <enum value="15"    name="VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO"/>
+        <enum value="16"    name="VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO"/>
+        <enum value="17"    name="VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO"/>
+        <enum value="18"    name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO"/>
+        <enum value="19"    name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO"/>
+        <enum value="20"    name="VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO"/>
+        <enum value="21"    name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO"/>
+        <enum value="22"    name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO"/>
+        <enum value="23"    name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO"/>
+        <enum value="24"    name="VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO"/>
+        <enum value="25"    name="VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO"/>
+        <enum value="26"    name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO"/>
+        <enum value="27"    name="VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO"/>
+        <enum value="28"    name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO"/>
+        <enum value="29"    name="VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO"/>
+        <enum value="30"    name="VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO"/>
+        <enum value="31"    name="VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO"/>
+        <enum value="32"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO"/>
+        <enum value="33"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO"/>
+        <enum value="34"    name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO"/>
+        <enum value="35"    name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET"/>
+        <enum value="36"    name="VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET"/>
+        <enum value="37"    name="VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO"/>
+        <enum value="38"    name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO"/>
+        <enum value="39"    name="VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO"/>
+        <enum value="40"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO"/>
+        <enum value="41"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO"/>
+        <enum value="42"    name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO"/>
+        <enum value="43"    name="VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO"/>
+        <enum value="44"    name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER"/>
+        <enum value="45"    name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER"/>
+        <enum value="46"    name="VK_STRUCTURE_TYPE_MEMORY_BARRIER"/>
+        <enum value="47"    name="VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
+        <enum value="48"    name="VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO" comment="Reserved for internal use by the loader, layers, and ICDs"/>
+    </enums>
+    <enums name="VkSubpassContents" type="enum">
+        <enum value="0"     name="VK_SUBPASS_CONTENTS_INLINE"/>
+        <enum value="1"     name="VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS"/>
+    </enums>
+    <enums name="VkResult" type="enum" comment="API result codes">
+            <comment>Return codes (positive values)</comment>
+        <enum value="0"     name="VK_SUCCESS" comment="Command completed successfully"/>
+        <enum value="1"     name="VK_NOT_READY" comment="A fence or query has not yet completed"/>
+        <enum value="2"     name="VK_TIMEOUT" comment="A wait operation has not completed in the specified time"/>
+        <enum value="3"     name="VK_EVENT_SET" comment="An event is signaled"/>
+        <enum value="4"     name="VK_EVENT_RESET" comment="An event is unsignaled"/>
+        <enum value="5"     name="VK_INCOMPLETE" comment="A return array was too small for the result"/>
+            <comment>Error codes (negative values)</comment>
+        <enum value="-1"    name="VK_ERROR_OUT_OF_HOST_MEMORY" comment="A host memory allocation has failed"/>
+        <enum value="-2"    name="VK_ERROR_OUT_OF_DEVICE_MEMORY" comment="A device memory allocation has failed"/>
+        <enum value="-3"    name="VK_ERROR_INITIALIZATION_FAILED" comment="Initialization of a object has failed"/>
+        <enum value="-4"    name="VK_ERROR_DEVICE_LOST" comment="The logical device has been lost. See &lt;&lt;devsandqueues-lost-device&gt;&gt;"/>
+        <enum value="-5"    name="VK_ERROR_MEMORY_MAP_FAILED" comment="Mapping of a memory object has failed"/>
+        <enum value="-6"    name="VK_ERROR_LAYER_NOT_PRESENT" comment="Layer specified does not exist"/>
+        <enum value="-7"    name="VK_ERROR_EXTENSION_NOT_PRESENT" comment="Extension specified does not exist"/>
+        <enum value="-8"    name="VK_ERROR_FEATURE_NOT_PRESENT" comment="Requested feature is not available on this device"/>
+        <enum value="-9"    name="VK_ERROR_INCOMPATIBLE_DRIVER" comment="Unable to find a Vulkan driver"/>
+        <enum value="-10"   name="VK_ERROR_TOO_MANY_OBJECTS" comment="Too many objects of the type have already been created"/>
+        <enum value="-11"   name="VK_ERROR_FORMAT_NOT_SUPPORTED" comment="Requested format is not supported on this device"/>
+        <enum value="-12"   name="VK_ERROR_FRAGMENTED_POOL" comment="A requested pool allocation has failed due to fragmentation of the pool's memory"/>
+        <enum value="-13"   name="VK_ERROR_UNKNOWN" comment="An unknown error has occurred, due to an implementation or application bug"/>
+            <unused start="-14" comment="This is the next unused available error code (negative value)"/>
+    </enums>
+    <enums name="VkDynamicState" type="enum">
+        <enum value="0"     name="VK_DYNAMIC_STATE_VIEWPORT"/>
+        <enum value="1"     name="VK_DYNAMIC_STATE_SCISSOR"/>
+        <enum value="2"     name="VK_DYNAMIC_STATE_LINE_WIDTH"/>
+        <enum value="3"     name="VK_DYNAMIC_STATE_DEPTH_BIAS"/>
+        <enum value="4"     name="VK_DYNAMIC_STATE_BLEND_CONSTANTS"/>
+        <enum value="5"     name="VK_DYNAMIC_STATE_DEPTH_BOUNDS"/>
+        <enum value="6"     name="VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK"/>
+        <enum value="7"     name="VK_DYNAMIC_STATE_STENCIL_WRITE_MASK"/>
+        <enum value="8"     name="VK_DYNAMIC_STATE_STENCIL_REFERENCE"/>
+    </enums>
+    <enums name="VkDescriptorUpdateTemplateType" type="enum">
+        <enum value="0"     name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"   comment="Create descriptor update template for descriptor set updates"/>
+    </enums>
+    <enums name="VkObjectType" type="enum" comment="Enums to track objects of various types - also see objtypeenum attributes on type tags">
+        <enum value="0"     name="VK_OBJECT_TYPE_UNKNOWN"/>
+        <enum value="1"     name="VK_OBJECT_TYPE_INSTANCE"/>
+        <enum value="2"     name="VK_OBJECT_TYPE_PHYSICAL_DEVICE"/>
+        <enum value="3"     name="VK_OBJECT_TYPE_DEVICE"/>
+        <enum value="4"     name="VK_OBJECT_TYPE_QUEUE"/>
+        <enum value="5"     name="VK_OBJECT_TYPE_SEMAPHORE"/>
+        <enum value="6"     name="VK_OBJECT_TYPE_COMMAND_BUFFER"/>
+        <enum value="7"     name="VK_OBJECT_TYPE_FENCE"/>
+        <enum value="8"     name="VK_OBJECT_TYPE_DEVICE_MEMORY"/>
+        <enum value="9"     name="VK_OBJECT_TYPE_BUFFER"/>
+        <enum value="10"    name="VK_OBJECT_TYPE_IMAGE"/>
+        <enum value="11"    name="VK_OBJECT_TYPE_EVENT"/>
+        <enum value="12"    name="VK_OBJECT_TYPE_QUERY_POOL"/>
+        <enum value="13"    name="VK_OBJECT_TYPE_BUFFER_VIEW"/>
+        <enum value="14"    name="VK_OBJECT_TYPE_IMAGE_VIEW"/>
+        <enum value="15"    name="VK_OBJECT_TYPE_SHADER_MODULE"/>
+        <enum value="16"    name="VK_OBJECT_TYPE_PIPELINE_CACHE"/>
+        <enum value="17"    name="VK_OBJECT_TYPE_PIPELINE_LAYOUT"/>
+        <enum value="18"    name="VK_OBJECT_TYPE_RENDER_PASS"/>
+        <enum value="19"    name="VK_OBJECT_TYPE_PIPELINE"/>
+        <enum value="20"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT"/>
+        <enum value="21"    name="VK_OBJECT_TYPE_SAMPLER"/>
+        <enum value="22"    name="VK_OBJECT_TYPE_DESCRIPTOR_POOL"/>
+        <enum value="23"    name="VK_OBJECT_TYPE_DESCRIPTOR_SET"/>
+        <enum value="24"    name="VK_OBJECT_TYPE_FRAMEBUFFER"/>
+        <enum value="25"    name="VK_OBJECT_TYPE_COMMAND_POOL"/>
+    </enums>
+
+        <comment>Flags</comment>
+    <enums name="VkQueueFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUEUE_GRAPHICS_BIT"                             comment="Queue supports graphics operations"/>
+        <enum bitpos="1"    name="VK_QUEUE_COMPUTE_BIT"                              comment="Queue supports compute operations"/>
+        <enum bitpos="2"    name="VK_QUEUE_TRANSFER_BIT"                             comment="Queue supports transfer operations"/>
+        <enum bitpos="3"    name="VK_QUEUE_SPARSE_BINDING_BIT"                       comment="Queue supports sparse resource memory management operations"/>
+    </enums>
+    <enums name="VkCullModeFlagBits" type="bitmask">
+        <enum value="0"     name="VK_CULL_MODE_NONE"/>
+        <enum bitpos="0"    name="VK_CULL_MODE_FRONT_BIT"/>
+        <enum bitpos="1"    name="VK_CULL_MODE_BACK_BIT"/>
+        <enum value="0x00000003" name="VK_CULL_MODE_FRONT_AND_BACK"/>
+    </enums>
+    <enums name="VkRenderPassCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkDeviceQueueCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkMemoryPropertyFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT"               comment="If otherwise stated, then allocate memory on device"/>
+        <enum bitpos="1"    name="VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT"               comment="Memory is mappable by host"/>
+        <enum bitpos="2"    name="VK_MEMORY_PROPERTY_HOST_COHERENT_BIT"              comment="Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache"/>
+        <enum bitpos="3"    name="VK_MEMORY_PROPERTY_HOST_CACHED_BIT"                comment="Memory will be cached by the host"/>
+        <enum bitpos="4"    name="VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT"           comment="Memory may be allocated by the driver when it is required"/>
+    </enums>
+    <enums name="VkMemoryHeapFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_MEMORY_HEAP_DEVICE_LOCAL_BIT"                   comment="If set, heap represents device memory"/>
+    </enums>
+    <enums name="VkAccessFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_ACCESS_INDIRECT_COMMAND_READ_BIT"               comment="Controls coherency of indirect command reads"/>
+        <enum bitpos="1"    name="VK_ACCESS_INDEX_READ_BIT"                          comment="Controls coherency of index reads"/>
+        <enum bitpos="2"    name="VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT"               comment="Controls coherency of vertex attribute reads"/>
+        <enum bitpos="3"    name="VK_ACCESS_UNIFORM_READ_BIT"                        comment="Controls coherency of uniform buffer reads"/>
+        <enum bitpos="4"    name="VK_ACCESS_INPUT_ATTACHMENT_READ_BIT"               comment="Controls coherency of input attachment reads"/>
+        <enum bitpos="5"    name="VK_ACCESS_SHADER_READ_BIT"                         comment="Controls coherency of shader reads"/>
+        <enum bitpos="6"    name="VK_ACCESS_SHADER_WRITE_BIT"                        comment="Controls coherency of shader writes"/>
+        <enum bitpos="7"    name="VK_ACCESS_COLOR_ATTACHMENT_READ_BIT"               comment="Controls coherency of color attachment reads"/>
+        <enum bitpos="8"    name="VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT"              comment="Controls coherency of color attachment writes"/>
+        <enum bitpos="9"    name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT"       comment="Controls coherency of depth/stencil attachment reads"/>
+        <enum bitpos="10"   name="VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT"      comment="Controls coherency of depth/stencil attachment writes"/>
+        <enum bitpos="11"   name="VK_ACCESS_TRANSFER_READ_BIT"                       comment="Controls coherency of transfer reads"/>
+        <enum bitpos="12"   name="VK_ACCESS_TRANSFER_WRITE_BIT"                      comment="Controls coherency of transfer writes"/>
+        <enum bitpos="13"   name="VK_ACCESS_HOST_READ_BIT"                           comment="Controls coherency of host reads"/>
+        <enum bitpos="14"   name="VK_ACCESS_HOST_WRITE_BIT"                          comment="Controls coherency of host writes"/>
+        <enum bitpos="15"   name="VK_ACCESS_MEMORY_READ_BIT"                         comment="Controls coherency of memory reads"/>
+        <enum bitpos="16"   name="VK_ACCESS_MEMORY_WRITE_BIT"                        comment="Controls coherency of memory writes"/>
+    </enums>
+    <enums name="VkBufferUsageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_BUFFER_USAGE_TRANSFER_SRC_BIT"                  comment="Can be used as a source of transfer operations"/>
+        <enum bitpos="1"    name="VK_BUFFER_USAGE_TRANSFER_DST_BIT"                  comment="Can be used as a destination of transfer operations"/>
+        <enum bitpos="2"    name="VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT"          comment="Can be used as TBO"/>
+        <enum bitpos="3"    name="VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT"          comment="Can be used as IBO"/>
+        <enum bitpos="4"    name="VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT"                comment="Can be used as UBO"/>
+        <enum bitpos="5"    name="VK_BUFFER_USAGE_STORAGE_BUFFER_BIT"                comment="Can be used as SSBO"/>
+        <enum bitpos="6"    name="VK_BUFFER_USAGE_INDEX_BUFFER_BIT"                  comment="Can be used as source of fixed-function index fetch (index buffer)"/>
+        <enum bitpos="7"    name="VK_BUFFER_USAGE_VERTEX_BUFFER_BIT"                 comment="Can be used as source of fixed-function vertex fetch (VBO)"/>
+        <enum bitpos="8"    name="VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT"               comment="Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)"/>
+    </enums>
+    <enums name="VkBufferCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_BUFFER_CREATE_SPARSE_BINDING_BIT"               comment="Buffer should support sparse backing"/>
+        <enum bitpos="1"    name="VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT"             comment="Buffer should support sparse backing with partial residency"/>
+        <enum bitpos="2"    name="VK_BUFFER_CREATE_SPARSE_ALIASED_BIT"               comment="Buffer should support constant data access to physical memory ranges mapped into multiple locations of sparse buffers"/>
+    </enums>
+    <enums name="VkShaderStageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SHADER_STAGE_VERTEX_BIT"/>
+        <enum bitpos="1"    name="VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT"/>
+        <enum bitpos="2"    name="VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT"/>
+        <enum bitpos="3"    name="VK_SHADER_STAGE_GEOMETRY_BIT"/>
+        <enum bitpos="4"    name="VK_SHADER_STAGE_FRAGMENT_BIT"/>
+        <enum bitpos="5"    name="VK_SHADER_STAGE_COMPUTE_BIT"/>
+        <enum value="0x0000001F" name="VK_SHADER_STAGE_ALL_GRAPHICS"/>
+        <enum value="0x7FFFFFFF" name="VK_SHADER_STAGE_ALL"/>
+    </enums>
+    <enums name="VkImageUsageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_USAGE_TRANSFER_SRC_BIT"                   comment="Can be used as a source of transfer operations"/>
+        <enum bitpos="1"    name="VK_IMAGE_USAGE_TRANSFER_DST_BIT"                   comment="Can be used as a destination of transfer operations"/>
+        <enum bitpos="2"    name="VK_IMAGE_USAGE_SAMPLED_BIT"                        comment="Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
+        <enum bitpos="3"    name="VK_IMAGE_USAGE_STORAGE_BIT"                        comment="Can be used as storage image (STORAGE_IMAGE descriptor type)"/>
+        <enum bitpos="4"    name="VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT"               comment="Can be used as framebuffer color attachment"/>
+        <enum bitpos="5"    name="VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT"       comment="Can be used as framebuffer depth/stencil attachment"/>
+        <enum bitpos="6"    name="VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT"           comment="Image data not needed outside of rendering"/>
+        <enum bitpos="7"    name="VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT"               comment="Can be used as framebuffer input attachment"/>
+    </enums>
+    <enums name="VkImageCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_CREATE_SPARSE_BINDING_BIT"                comment="Image should support sparse backing"/>
+        <enum bitpos="1"    name="VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT"              comment="Image should support sparse backing with partial residency"/>
+        <enum bitpos="2"    name="VK_IMAGE_CREATE_SPARSE_ALIASED_BIT"                comment="Image should support constant data access to physical memory ranges mapped into multiple locations of sparse images"/>
+        <enum bitpos="3"    name="VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT"                comment="Allows image views to have different format than the base image"/>
+        <enum bitpos="4"    name="VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT"               comment="Allows creating image views with cube type from the created image"/>
+    </enums>
+    <enums name="VkImageViewCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkSamplerCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPipelineCreateFlagBits" type="bitmask" comment="Note that the gap at bitpos 10 is unused, and can be reserved">
+        <enum bitpos="0"    name="VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT"/>
+        <enum bitpos="1"    name="VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT"/>
+        <enum bitpos="2"    name="VK_PIPELINE_CREATE_DERIVATIVE_BIT"/>
+    </enums>
+    <enums name="VkPipelineShaderStageCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkColorComponentFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COLOR_COMPONENT_R_BIT"/>
+        <enum bitpos="1"    name="VK_COLOR_COMPONENT_G_BIT"/>
+        <enum bitpos="2"    name="VK_COLOR_COMPONENT_B_BIT"/>
+        <enum bitpos="3"    name="VK_COLOR_COMPONENT_A_BIT"/>
+    </enums>
+    <enums name="VkFenceCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_FENCE_CREATE_SIGNALED_BIT"/>
+    </enums>
+    <enums name="VkSemaphoreCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkFormatFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT"               comment="Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)"/>
+        <enum bitpos="1"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT"               comment="Format can be used for storage images (STORAGE_IMAGE descriptor type)"/>
+        <enum bitpos="2"    name="VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT"        comment="Format supports atomic operations in case it is used for storage images"/>
+        <enum bitpos="3"    name="VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT"        comment="Format can be used for uniform texel buffers (TBOs)"/>
+        <enum bitpos="4"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT"        comment="Format can be used for storage texel buffers (IBOs)"/>
+        <enum bitpos="5"    name="VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT" comment="Format supports atomic operations in case it is used for storage texel buffers"/>
+        <enum bitpos="6"    name="VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT"               comment="Format can be used for vertex buffers (VBOs)"/>
+        <enum bitpos="7"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT"            comment="Format can be used for color attachment images"/>
+        <enum bitpos="8"    name="VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT"      comment="Format supports blending in case it is used for color attachment images"/>
+        <enum bitpos="9"    name="VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT"    comment="Format can be used for depth/stencil attachment images"/>
+        <enum bitpos="10"   name="VK_FORMAT_FEATURE_BLIT_SRC_BIT"                    comment="Format can be used as the source image of blits with vkCmdBlitImage"/>
+        <enum bitpos="11"   name="VK_FORMAT_FEATURE_BLIT_DST_BIT"                    comment="Format can be used as the destination image of blits with vkCmdBlitImage"/>
+        <enum bitpos="12"   name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT" comment="Format can be filtered with VK_FILTER_LINEAR when being sampled"/>
+    </enums>
+    <enums name="VkQueryControlFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUERY_CONTROL_PRECISE_BIT"                      comment="Require precise results to be collected by the query"/>
+    </enums>
+    <enums name="VkQueryResultFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUERY_RESULT_64_BIT"                            comment="Results of the queries are written to the destination buffer as 64-bit values"/>
+        <enum bitpos="1"    name="VK_QUERY_RESULT_WAIT_BIT"                          comment="Results of the queries are waited on before proceeding with the result copy"/>
+        <enum bitpos="2"    name="VK_QUERY_RESULT_WITH_AVAILABILITY_BIT"             comment="Besides the results of the query, the availability of the results is also written"/>
+        <enum bitpos="3"    name="VK_QUERY_RESULT_PARTIAL_BIT"                       comment="Copy the partial results of the query even if the final results are not available"/>
+    </enums>
+    <enums name="VkCommandBufferUsageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT"/>
+        <enum bitpos="1"    name="VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT"/>
+        <enum bitpos="2"    name="VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT"      comment="Command buffer may be submitted/executed more than once simultaneously"/>
+    </enums>
+    <enums name="VkQueryPipelineStatisticFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT"                    comment="Optional"/>
+        <enum bitpos="1"    name="VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT"                  comment="Optional"/>
+        <enum bitpos="2"    name="VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT"                  comment="Optional"/>
+        <enum bitpos="3"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
+        <enum bitpos="4"    name="VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT"                 comment="Optional"/>
+        <enum bitpos="5"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT"                       comment="Optional"/>
+        <enum bitpos="6"    name="VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT"                        comment="Optional"/>
+        <enum bitpos="7"    name="VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT"                comment="Optional"/>
+        <enum bitpos="8"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT"        comment="Optional"/>
+        <enum bitpos="9"    name="VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT" comment="Optional"/>
+        <enum bitpos="10"   name="VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT"                 comment="Optional"/>
+    </enums>
+    <enums name="VkImageAspectFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_ASPECT_COLOR_BIT"/>
+        <enum bitpos="1"    name="VK_IMAGE_ASPECT_DEPTH_BIT"/>
+        <enum bitpos="2"    name="VK_IMAGE_ASPECT_STENCIL_BIT"/>
+        <enum bitpos="3"    name="VK_IMAGE_ASPECT_METADATA_BIT"/>
+    </enums>
+    <enums name="VkSparseImageFormatFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT"         comment="Image uses a single mip tail region for all array layers"/>
+        <enum bitpos="1"    name="VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT"       comment="Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels."/>
+        <enum bitpos="2"    name="VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT" comment="Image uses a non-standard sparse image block dimensions"/>
+    </enums>
+    <enums name="VkSparseMemoryBindFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SPARSE_MEMORY_BIND_METADATA_BIT"                comment="Operation binds resource metadata to memory"/>
+    </enums>
+    <enums name="VkPipelineStageFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT"                 comment="Before subsequent commands are processed"/>
+        <enum bitpos="1"    name="VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT"               comment="Draw/DispatchIndirect command fetch"/>
+        <enum bitpos="2"    name="VK_PIPELINE_STAGE_VERTEX_INPUT_BIT"                comment="Vertex/index fetch"/>
+        <enum bitpos="3"    name="VK_PIPELINE_STAGE_VERTEX_SHADER_BIT"               comment="Vertex shading"/>
+        <enum bitpos="4"    name="VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT" comment="Tessellation control shading"/>
+        <enum bitpos="5"    name="VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT" comment="Tessellation evaluation shading"/>
+        <enum bitpos="6"    name="VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT"             comment="Geometry shading"/>
+        <enum bitpos="7"    name="VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT"             comment="Fragment shading"/>
+        <enum bitpos="8"    name="VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT"        comment="Early fragment (depth and stencil) tests"/>
+        <enum bitpos="9"    name="VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT"         comment="Late fragment (depth and stencil) tests"/>
+        <enum bitpos="10"   name="VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT"     comment="Color attachment writes"/>
+        <enum bitpos="11"   name="VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT"              comment="Compute shading"/>
+        <enum bitpos="12"   name="VK_PIPELINE_STAGE_TRANSFER_BIT"                    comment="Transfer/copy operations"/>
+        <enum bitpos="13"   name="VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT"              comment="After previous commands have completed"/>
+        <enum bitpos="14"   name="VK_PIPELINE_STAGE_HOST_BIT"                        comment="Indicates host (CPU) is a source/sink of the dependency"/>
+        <enum bitpos="15"   name="VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT"                comment="All stages of the graphics pipeline"/>
+        <enum bitpos="16"   name="VK_PIPELINE_STAGE_ALL_COMMANDS_BIT"                comment="All stages supported on the queue"/>
+    </enums>
+    <enums name="VkCommandPoolCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_POOL_CREATE_TRANSIENT_BIT"              comment="Command buffers have a short lifetime"/>
+        <enum bitpos="1"    name="VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT"   comment="Command buffers may release their memory individually"/>
+    </enums>
+    <enums name="VkCommandPoolResetFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT"       comment="Release resources owned by the pool"/>
+    </enums>
+    <enums name="VkCommandBufferResetFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT"     comment="Release resources owned by the buffer"/>
+    </enums>
+    <enums name="VkSampleCountFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SAMPLE_COUNT_1_BIT"                             comment="Sample count 1 supported"/>
+        <enum bitpos="1"    name="VK_SAMPLE_COUNT_2_BIT"                             comment="Sample count 2 supported"/>
+        <enum bitpos="2"    name="VK_SAMPLE_COUNT_4_BIT"                             comment="Sample count 4 supported"/>
+        <enum bitpos="3"    name="VK_SAMPLE_COUNT_8_BIT"                             comment="Sample count 8 supported"/>
+        <enum bitpos="4"    name="VK_SAMPLE_COUNT_16_BIT"                            comment="Sample count 16 supported"/>
+        <enum bitpos="5"    name="VK_SAMPLE_COUNT_32_BIT"                            comment="Sample count 32 supported"/>
+        <enum bitpos="6"    name="VK_SAMPLE_COUNT_64_BIT"                            comment="Sample count 64 supported"/>
+    </enums>
+    <enums name="VkAttachmentDescriptionFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT"           comment="The attachment may alias physical memory of another attachment in the same render pass"/>
+    </enums>
+    <enums name="VkStencilFaceFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_STENCIL_FACE_FRONT_BIT"                         comment="Front face"/>
+        <enum bitpos="1"    name="VK_STENCIL_FACE_BACK_BIT"                          comment="Back face"/>
+        <enum value="0x00000003" name="VK_STENCIL_FACE_FRONT_AND_BACK"               comment="Front and back faces"/>
+        <enum                    name="VK_STENCIL_FRONT_AND_BACK" alias="VK_STENCIL_FACE_FRONT_AND_BACK" comment="Alias for backwards compatibility"/>
+    </enums>
+    <enums name="VkDescriptorPoolCreateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT" comment="Descriptor sets may be freed individually"/>
+    </enums>
+    <enums name="VkDependencyFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_DEPENDENCY_BY_REGION_BIT"                       comment="Dependency is per pixel region "/>
+    </enums>
+    <enums name="VkSemaphoreType" type="enum">
+        <enum value="0"     name="VK_SEMAPHORE_TYPE_BINARY"/>
+        <enum value="1"     name="VK_SEMAPHORE_TYPE_TIMELINE"/>
+    </enums>
+    <enums name="VkSemaphoreWaitFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SEMAPHORE_WAIT_ANY_BIT"/>
+    </enums>
+
+        <comment>WSI Extensions</comment>
+    <enums name="VkPresentModeKHR" type="enum">
+        <enum value="0"     name="VK_PRESENT_MODE_IMMEDIATE_KHR"/>
+        <enum value="1"     name="VK_PRESENT_MODE_MAILBOX_KHR"/>
+        <enum value="2"     name="VK_PRESENT_MODE_FIFO_KHR"/>
+        <enum value="3"     name="VK_PRESENT_MODE_FIFO_RELAXED_KHR"/>
+    </enums>
+    <enums name="VkColorSpaceKHR" type="enum">
+        <enum value="0"     name="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR"/>
+        <enum               name="VK_COLORSPACE_SRGB_NONLINEAR_KHR" alias="VK_COLOR_SPACE_SRGB_NONLINEAR_KHR" comment="Backwards-compatible alias containing a typo"/>
+    </enums>
+    <enums name="VkDisplayPlaneAlphaFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR"/>
+    </enums>
+    <enums name="VkCompositeAlphaFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR"/>
+    </enums>
+    <enums name="VkSurfaceTransformFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR"/>
+        <enum bitpos="4"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR"/>
+        <enum bitpos="5"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR"/>
+        <enum bitpos="6"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR"/>
+        <enum bitpos="7"    name="VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR"/>
+        <enum bitpos="8"    name="VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR"/>
+    </enums>
+    <enums name="VkSwapchainImageUsageFlagBitsANDROID" type="bitmask">
+      <enum bitpos="0"      name="VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID"/>
+    </enums>
+    <enums name="VkTimeDomainEXT" type="enum">
+        <enum value="0"     name="VK_TIME_DOMAIN_DEVICE_EXT"/>
+        <enum value="1"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT"/>
+        <enum value="2"     name="VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT"/>
+        <enum value="3"     name="VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT"/>
+    </enums>
+    <enums name="VkDebugReportFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_DEBUG_REPORT_INFORMATION_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_DEBUG_REPORT_WARNING_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT"/>
+        <enum bitpos="3"    name="VK_DEBUG_REPORT_ERROR_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_DEBUG_REPORT_DEBUG_BIT_EXT"/>
+    </enums>
+    <enums name="VkDebugReportObjectTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT"/>
+        <enum value="1"     name="VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT"/>
+        <enum value="2"     name="VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT"/>
+        <enum value="3"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT"/>
+        <enum value="4"     name="VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT"/>
+        <enum value="5"     name="VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT"/>
+        <enum value="6"     name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT"/>
+        <enum value="7"     name="VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT"/>
+        <enum value="8"     name="VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT"/>
+        <enum value="9"     name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT"/>
+        <enum value="10"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT"/>
+        <enum value="11"    name="VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT"/>
+        <enum value="12"    name="VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT"/>
+        <enum value="13"    name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT"/>
+        <enum value="14"    name="VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT"/>
+        <enum value="15"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT"/>
+        <enum value="16"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT"/>
+        <enum value="17"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT"/>
+        <enum value="18"    name="VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT"/>
+        <enum value="19"    name="VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT"/>
+        <enum value="20"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT"/>
+        <enum value="21"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT"/>
+        <enum value="22"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT"/>
+        <enum value="23"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT"/>
+        <enum value="24"    name="VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT"/>
+        <enum value="25"    name="VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT"/>
+        <enum value="26"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT"/>
+        <enum value="27"    name="VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT"/>
+        <enum value="28"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT"/>
+        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT" comment="Backwards-compatible alias containing a typo"/>
+        <enum value="29"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT"/>
+        <enum value="30"    name="VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT"/>
+        <!--<enum value="31"    name="VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT" comment="Removed NVX_device_generated_commands"/>-->
+        <!--<enum value="32"    name="VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT" comment="Removed NVX_device_generated_commands"/>-->
+        <enum value="33"    name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT"/>
+        <enum               name="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT" comment="Backwards-compatible alias containing a typo"/>
+    </enums>
+    <enums name="VkDeviceMemoryReportEventTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT"/>
+        <enum value="1"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT"/>
+        <enum value="2"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT"/>
+        <enum value="3"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT"/>
+        <enum value="4"     name="VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT"/>
+    </enums>
+    <enums name="VkRasterizationOrderAMD" type="enum">
+        <enum value="0"     name="VK_RASTERIZATION_ORDER_STRICT_AMD"/>
+        <enum value="1"     name="VK_RASTERIZATION_ORDER_RELAXED_AMD"/>
+    </enums>
+    <enums name="VkExternalMemoryHandleTypeFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV"/>
+    </enums>
+    <enums name="VkExternalMemoryFeatureFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV"/>
+    </enums>
+    <enums name="VkValidationCheckEXT" type="enum">
+        <enum value="0"     name="VK_VALIDATION_CHECK_ALL_EXT"/>
+        <enum value="1"     name="VK_VALIDATION_CHECK_SHADERS_EXT"/>
+    </enums>
+    <enums name="VkValidationFeatureEnableEXT" type="enum">
+        <enum value="0"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT"/>
+        <enum value="1"     name="VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT"/>
+        <enum value="2"     name="VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT"/>
+        <enum value="3"     name="VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT"/>
+        <enum value="4"     name="VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT"/>
+    </enums>
+    <enums name="VkValidationFeatureDisableEXT" type="enum">
+        <enum value="0"     name="VK_VALIDATION_FEATURE_DISABLE_ALL_EXT"/>
+        <enum value="1"     name="VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT"/>
+        <enum value="2"     name="VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT"/>
+        <enum value="3"     name="VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT"/>
+        <enum value="4"     name="VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT"/>
+        <enum value="5"     name="VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT"/>
+        <enum value="6"     name="VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT"/>
+        <enum value="7"     name="VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT"/>
+    </enums>
+    <enums name="VkSubgroupFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SUBGROUP_FEATURE_BASIC_BIT"              comment="Basic subgroup operations"/>
+        <enum bitpos="1"    name="VK_SUBGROUP_FEATURE_VOTE_BIT"               comment="Vote subgroup operations"/>
+        <enum bitpos="2"    name="VK_SUBGROUP_FEATURE_ARITHMETIC_BIT"         comment="Arithmetic subgroup operations"/>
+        <enum bitpos="3"    name="VK_SUBGROUP_FEATURE_BALLOT_BIT"             comment="Ballot subgroup operations"/>
+        <enum bitpos="4"    name="VK_SUBGROUP_FEATURE_SHUFFLE_BIT"            comment="Shuffle subgroup operations"/>
+        <enum bitpos="5"    name="VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT"   comment="Shuffle relative subgroup operations"/>
+        <enum bitpos="6"    name="VK_SUBGROUP_FEATURE_CLUSTERED_BIT"          comment="Clustered subgroup operations"/>
+        <enum bitpos="7"    name="VK_SUBGROUP_FEATURE_QUAD_BIT"               comment="Quad subgroup operations"/>
+    </enums>
+    <enums name="VkIndirectCommandsLayoutUsageFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV"/>
+        <enum bitpos="1"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV"/>
+        <enum bitpos="2"    name="VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV"/>
+    </enums>
+    <enums name="VkIndirectStateFlagBitsNV" type="bitmask">
+        <enum bitpos="0"    name="VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV"/>
+    </enums>
+    <enums name="VkIndirectCommandsTokenTypeNV" type="enum">
+        <enum value="0"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV"/>
+        <enum value="1"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV"/>
+        <enum value="2"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV"/>
+        <enum value="3"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV"/>
+        <enum value="4"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV"/>
+        <enum value="5"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV"/>
+        <enum value="6"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV"/>
+        <enum value="7"     name="VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV"/>
+    </enums>
+    <enums name="VkPrivateDataSlotCreateFlagBitsEXT" type="bitmask">
+    </enums>
+    <enums name="VkDescriptorSetLayoutCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkExternalMemoryHandleTypeFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
+        <enum bitpos="4"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
+        <enum bitpos="5"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
+        <enum bitpos="6"    name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
+    </enums>
+    <enums name="VkExternalMemoryFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
+    </enums>
+    <enums name="VkExternalSemaphoreHandleTypeFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
+        <enum               name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
+        <enum bitpos="4"    name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
+    </enums>
+    <enums name="VkExternalSemaphoreFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
+    </enums>
+    <enums name="VkSemaphoreImportFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
+    </enums>
+    <enums name="VkExternalFenceHandleTypeFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+        <enum bitpos="2"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+        <enum bitpos="3"    name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
+    </enums>
+    <enums name="VkExternalFenceFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
+        <enum bitpos="1"    name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
+    </enums>
+    <enums name="VkFenceImportFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
+    </enums>
+    <enums name="VkSurfaceCounterFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_SURFACE_COUNTER_VBLANK_BIT_EXT"/>
+        <enum               name="VK_SURFACE_COUNTER_VBLANK_EXT" alias="VK_SURFACE_COUNTER_VBLANK_BIT_EXT" comment="Backwards-compatible alias containing a typo"/>
+    </enums>
+    <enums name="VkDisplayPowerStateEXT" type="enum">
+        <enum value="0"     name="VK_DISPLAY_POWER_STATE_OFF_EXT"/>
+        <enum value="1"     name="VK_DISPLAY_POWER_STATE_SUSPEND_EXT"/>
+        <enum value="2"     name="VK_DISPLAY_POWER_STATE_ON_EXT"/>
+    </enums>
+    <enums name="VkDeviceEventTypeEXT" type="enum">
+        <enum value="0"     name="VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT"/>
+    </enums>
+    <enums name="VkDisplayEventTypeEXT" type="enum">
+        <enum value="0"     name="VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT"/>
+    </enums>
+    <enums name="VkPeerMemoryFeatureFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"           comment="Can read with vkCmdCopy commands"/>
+        <enum bitpos="1"    name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"           comment="Can write with vkCmdCopy commands"/>
+        <enum bitpos="2"    name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"        comment="Can read with any access type/command"/>
+        <enum bitpos="3"    name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"        comment="Can write with and access type/command"/>
+    </enums>
+    <enums name="VkMemoryAllocateFlagBits" type="bitmask">
+        <enum bitpos="0"    name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"            comment="Force allocation on specific devices"/>
+    </enums>
+    <enums name="VkDeviceGroupPresentModeFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR"        comment="Present from local memory"/>
+        <enum bitpos="1"    name="VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR"       comment="Present from remote memory"/>
+        <enum bitpos="2"    name="VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR"          comment="Present sum of local and/or remote memory"/>
+        <enum bitpos="3"    name="VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR" comment="Each physical device presents from local memory"/>
+    </enums>
+    <enums name="VkSwapchainCreateFlagBitsKHR" type="bitmask">
+    </enums>
+    <enums name="VkViewportCoordinateSwizzleNV" type="enum">
+        <enum value="0"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV"/>
+        <enum value="1"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV"/>
+        <enum value="2"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV"/>
+        <enum value="3"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV"/>
+        <enum value="4"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV"/>
+        <enum value="5"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV"/>
+        <enum value="6"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV"/>
+        <enum value="7"     name="VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV"/>
+    </enums>
+    <enums name="VkDiscardRectangleModeEXT" type="enum">
+        <enum value="0"     name="VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT"/>
+        <enum value="1"     name="VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT"/>
+    </enums>
+    <enums name="VkSubpassDescriptionFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPointClippingBehavior" type="enum">
+        <enum value="0"     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
+        <enum value="1"     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
+    </enums>
+    <enums name="VkSamplerReductionMode" type="enum">
+        <enum value="0"     name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"/>
+        <enum value="1"     name="VK_SAMPLER_REDUCTION_MODE_MIN"/>
+        <enum value="2"     name="VK_SAMPLER_REDUCTION_MODE_MAX"/>
+    </enums>
+    <enums name="VkTessellationDomainOrigin" type="enum">
+        <enum value="0"     name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
+        <enum value="1"     name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
+    </enums>
+    <enums name="VkSamplerYcbcrModelConversion" type="enum">
+        <enum value="0"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
+        <enum value="1"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY" comment="just range expansion"/>
+        <enum value="2"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"      comment="aka HD YUV"/>
+        <enum value="3"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"      comment="aka SD YUV"/>
+        <enum value="4"     name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"     comment="aka UHD YUV"/>
+    </enums>
+    <enums name="VkSamplerYcbcrRange" type="enum">
+        <enum value="0"     name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"    comment="Luma 0..1 maps to 0..255, chroma -0.5..0.5 to 1..255 (clamped)"/>
+        <enum value="1"     name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"  comment="Luma 0..1 maps to 16..235, chroma -0.5..0.5 to 16..240"/>
+    </enums>
+    <enums name="VkChromaLocation" type="enum">
+        <enum value="0"     name="VK_CHROMA_LOCATION_COSITED_EVEN"/>
+        <enum value="1"     name="VK_CHROMA_LOCATION_MIDPOINT"/>
+    </enums>
+    <enums name="VkBlendOverlapEXT" type="enum">
+        <enum value="0"     name="VK_BLEND_OVERLAP_UNCORRELATED_EXT"/>
+        <enum value="1"     name="VK_BLEND_OVERLAP_DISJOINT_EXT"/>
+        <enum value="2"     name="VK_BLEND_OVERLAP_CONJOINT_EXT"/>
+    </enums>
+    <enums name="VkCoverageModulationModeNV" type="enum">
+        <enum value="0"     name="VK_COVERAGE_MODULATION_MODE_NONE_NV"/>
+        <enum value="1"     name="VK_COVERAGE_MODULATION_MODE_RGB_NV"/>
+        <enum value="2"     name="VK_COVERAGE_MODULATION_MODE_ALPHA_NV"/>
+        <enum value="3"     name="VK_COVERAGE_MODULATION_MODE_RGBA_NV"/>
+    </enums>
+    <enums name="VkCoverageReductionModeNV" type="enum">
+        <enum value="0"     name="VK_COVERAGE_REDUCTION_MODE_MERGE_NV"/>
+        <enum value="1"     name="VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV"/>
+    </enums>
+    <enums name="VkValidationCacheHeaderVersionEXT" type="enum">
+        <enum value="1"     name="VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT"/>
+    </enums>
+    <enums name="VkShaderInfoTypeAMD" type="enum">
+        <enum value="0"     name="VK_SHADER_INFO_TYPE_STATISTICS_AMD"/>
+        <enum value="1"     name="VK_SHADER_INFO_TYPE_BINARY_AMD"/>
+        <enum value="2"     name="VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD"/>
+    </enums>
+    <enums name="VkQueueGlobalPriorityEXT" type="enum">
+        <enum value="128"   name="VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT"/>
+        <enum value="256"   name="VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT"/>
+        <enum value="512"   name="VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT"/>
+        <enum value="1024"  name="VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT"/>
+    </enums>
+    <enums name="VkDebugUtilsMessageSeverityFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT"/>
+        <enum bitpos="4"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT"/>
+        <enum bitpos="8"    name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT"/>
+        <enum bitpos="12"   name="VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT"/>
+    </enums>
+    <enums name="VkDebugUtilsMessageTypeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT"/>
+    </enums>
+    <enums name="VkConservativeRasterizationModeEXT" type="enum">
+        <enum value="0"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT"/>
+        <enum value="1"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT"/>
+        <enum value="2"     name="VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT"/>
+    </enums>
+    <enums name="VkDescriptorBindingFlagBits" type="bitmask">
+        <enum bitpos="0" name="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"/>
+        <enum bitpos="1" name="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"/>
+        <enum bitpos="2" name="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"/>
+        <enum bitpos="3" name="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"/>
+    </enums>
+    <enums name="VkVendorId" type="enum">
+        <comment>Vendor IDs are now represented as enums instead of the old
+                 &lt;vendorids&gt; tag, allowing them to be included in the
+                 API headers.</comment>
+        <enum value="0x10001" name="VK_VENDOR_ID_VIV"   comment="Vivante vendor ID"/>
+        <enum value="0x10002" name="VK_VENDOR_ID_VSI"   comment="VeriSilicon vendor ID"/>
+        <enum value="0x10003" name="VK_VENDOR_ID_KAZAN" comment="Kazan Software Renderer"/>
+        <enum value="0x10004" name="VK_VENDOR_ID_CODEPLAY" comment="Codeplay Software Ltd. vendor ID"/>
+        <enum value="0x10005" name="VK_VENDOR_ID_MESA"  comment="Mesa vendor ID"/>
+        <enum value="0x10006" name="VK_VENDOR_ID_POCL"  comment="PoCL vendor ID"/>
+            <unused start="0x10007" comment="This is the next unused available Khronos vendor ID"/>
+    </enums>
+    <enums name="VkDriverId" type="enum">
+        <comment>Driver IDs are now represented as enums instead of the old
+                 &lt;driverids&gt; tag, allowing them to be included in the
+                 API headers.</comment>
+        <enum value="1"       name="VK_DRIVER_ID_AMD_PROPRIETARY"               comment="Advanced Micro Devices, Inc."/>
+        <enum value="2"       name="VK_DRIVER_ID_AMD_OPEN_SOURCE"               comment="Advanced Micro Devices, Inc."/>
+        <enum value="3"       name="VK_DRIVER_ID_MESA_RADV"                     comment="Mesa open source project"/>
+        <enum value="4"       name="VK_DRIVER_ID_NVIDIA_PROPRIETARY"            comment="NVIDIA Corporation"/>
+        <enum value="5"       name="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"     comment="Intel Corporation"/>
+        <enum value="6"       name="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"        comment="Intel Corporation"/>
+        <enum value="7"       name="VK_DRIVER_ID_IMAGINATION_PROPRIETARY"       comment="Imagination Technologies"/>
+        <enum value="8"       name="VK_DRIVER_ID_QUALCOMM_PROPRIETARY"          comment="Qualcomm Technologies, Inc."/>
+        <enum value="9"       name="VK_DRIVER_ID_ARM_PROPRIETARY"               comment="Arm Limited"/>
+        <enum value="10"      name="VK_DRIVER_ID_GOOGLE_SWIFTSHADER"            comment="Google LLC"/>
+        <enum value="11"      name="VK_DRIVER_ID_GGP_PROPRIETARY"               comment="Google LLC"/>
+        <enum value="12"      name="VK_DRIVER_ID_BROADCOM_PROPRIETARY"          comment="Broadcom Inc."/>
+        <enum value="13"      name="VK_DRIVER_ID_MESA_LLVMPIPE"                 comment="Mesa"/>
+        <enum value="14"      name="VK_DRIVER_ID_MOLTENVK"                      comment="MoltenVK"/>
+        <enum value="15"      name="VK_DRIVER_ID_COREAVI_PROPRIETARY"           comment="Core Avionics &amp; Industrial Inc."/>
+        <enum value="16"      name="VK_DRIVER_ID_JUICE_PROPRIETARY"             comment="Juice Technologies, Inc."/>
+        <enum value="17"      name="VK_DRIVER_ID_VERISILICON_PROPRIETARY"       comment="Verisilicon, Inc."/>
+        <enum value="18"      name="VK_DRIVER_ID_MESA_TURNIP"                   comment="Mesa open source project"/>
+        <enum value="19"      name="VK_DRIVER_ID_MESA_V3DV"                     comment="Mesa open source project"/>
+        <enum value="20"      name="VK_DRIVER_ID_MESA_PANVK"                    comment="Mesa open source project"/>
+    </enums>
+    <enums name="VkConditionalRenderingFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT"/>
+    </enums>
+    <enums name="VkResolveModeFlagBits" type="bitmask">
+        <enum value="0" name="VK_RESOLVE_MODE_NONE"/>
+        <enum bitpos="0" name="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"/>
+        <enum bitpos="1" name="VK_RESOLVE_MODE_AVERAGE_BIT"/>
+        <enum bitpos="2" name="VK_RESOLVE_MODE_MIN_BIT"/>
+        <enum bitpos="3" name="VK_RESOLVE_MODE_MAX_BIT"/>
+    </enums>
+    <enums name="VkShadingRatePaletteEntryNV" type="enum">
+        <enum value="0" name="VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV"/>
+        <enum value="1" name="VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="2" name="VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="3" name="VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="4" name="VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="5" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV"/>
+        <enum value="6" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV"/>
+        <enum value="7" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV"/>
+        <enum value="8" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV"/>
+        <enum value="9" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV"/>
+        <enum value="10" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV"/>
+        <enum value="11" name="VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV"/>
+    </enums>
+    <enums name="VkCoarseSampleOrderTypeNV" type="enum">
+        <enum value="0" name="VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV"/>
+        <enum value="1" name="VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV"/>
+        <enum value="2" name="VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV"/>
+        <enum value="3" name="VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV"/>
+    </enums>
+    <enums name="VkGeometryInstanceFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"/>
+        <enum bitpos="1" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"/>
+        <enum bitpos="2" name="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"/>
+        <enum bitpos="3" name="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"/>
+        <enum            name="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR"/>
+    </enums>
+    <enums name="VkGeometryFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_GEOMETRY_OPAQUE_BIT_KHR"/>
+        <enum bitpos="1" name="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"/>
+    </enums>
+    <enums name="VkBuildAccelerationStructureFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"/>
+        <enum bitpos="1" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"/>
+        <enum bitpos="2" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"/>
+        <enum bitpos="3" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"/>
+        <enum bitpos="4" name="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureCreateFlagBitsKHR" type="bitmask">
+        <enum bitpos="0" name="VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR"/>
+    </enums>
+    <enums name="VkCopyAccelerationStructureModeKHR" type="enum">
+        <enum value="0" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"/>
+        <enum value="1" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"/>
+        <enum value="2" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR"/>
+        <enum value="3" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR"/>
+    </enums>
+    <enums name="VkBuildAccelerationStructureModeKHR" type="enum">
+        <enum value="0" name="VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR"/>
+        <enum value="1" name="VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureTypeKHR" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR"/>
+    </enums>
+    <enums name="VkGeometryTypeKHR" type="enum">
+        <enum value="0" name="VK_GEOMETRY_TYPE_TRIANGLES_KHR"/>
+        <enum value="1" name="VK_GEOMETRY_TYPE_AABBS_KHR"/>
+        <enum value="2" name="VK_GEOMETRY_TYPE_INSTANCES_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureMemoryRequirementsTypeNV" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV"/>
+    </enums>
+    <enums name="VkAccelerationStructureBuildTypeKHR" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR"/>
+    </enums>
+    <enums name="VkRayTracingShaderGroupTypeKHR" type="enum">
+        <enum value="0" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"/>
+        <enum value="1" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"/>
+        <enum value="2" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"/>
+    </enums>
+    <enums name="VkAccelerationStructureCompatibilityKHR" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR"/>
+    </enums>
+    <enums name="VkShaderGroupShaderKHR" type="enum">
+        <enum value="0" name="VK_SHADER_GROUP_SHADER_GENERAL_KHR"/>
+        <enum value="1" name="VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR"/>
+        <enum value="2" name="VK_SHADER_GROUP_SHADER_ANY_HIT_KHR"/>
+        <enum value="3" name="VK_SHADER_GROUP_SHADER_INTERSECTION_KHR"/>
+    </enums>
+    <enums name="VkMemoryOverallocationBehaviorAMD" type="enum">
+        <enum value="0"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD"/>
+        <enum value="1"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD"/>
+        <enum value="2"     name="VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD"/>
+    </enums>
+    <enums name="VkFramebufferCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkScopeNV" type="enum">
+        <enum value="1"     name="VK_SCOPE_DEVICE_NV"/>
+        <enum value="2"     name="VK_SCOPE_WORKGROUP_NV"/>
+        <enum value="3"     name="VK_SCOPE_SUBGROUP_NV"/>
+        <enum value="5"     name="VK_SCOPE_QUEUE_FAMILY_NV"/>
+    </enums>
+    <enums name="VkComponentTypeNV" type="enum">
+        <enum value="0"     name="VK_COMPONENT_TYPE_FLOAT16_NV"/>
+        <enum value="1"     name="VK_COMPONENT_TYPE_FLOAT32_NV"/>
+        <enum value="2"     name="VK_COMPONENT_TYPE_FLOAT64_NV"/>
+        <enum value="3"     name="VK_COMPONENT_TYPE_SINT8_NV"/>
+        <enum value="4"     name="VK_COMPONENT_TYPE_SINT16_NV"/>
+        <enum value="5"     name="VK_COMPONENT_TYPE_SINT32_NV"/>
+        <enum value="6"     name="VK_COMPONENT_TYPE_SINT64_NV"/>
+        <enum value="7"     name="VK_COMPONENT_TYPE_UINT8_NV"/>
+        <enum value="8"     name="VK_COMPONENT_TYPE_UINT16_NV"/>
+        <enum value="9"     name="VK_COMPONENT_TYPE_UINT32_NV"/>
+        <enum value="10"    name="VK_COMPONENT_TYPE_UINT64_NV"/>
+    </enums>
+    <enums name="VkDeviceDiagnosticsConfigFlagBitsNV" type="bitmask">
+        <enum bitpos="0" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV"/>
+        <enum bitpos="1" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV"/>
+        <enum bitpos="2" name="VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV"/>
+    </enums>
+    <enums name="VkPipelineCreationFeedbackFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"    name="VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT"/>
+        <enum bitpos="1"    name="VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT"/>
+        <enum bitpos="2"    name="VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT"/>
+    </enums>
+    <enums name="VkFullScreenExclusiveEXT" type="enum">
+        <enum value="0"     name="VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT"/>
+        <enum value="1"     name="VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT"/>
+        <enum value="2"     name="VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT"/>
+        <enum value="3"     name="VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT"/>
+    </enums>
+    <enums name="VkPerformanceCounterScopeKHR" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR"/>
+        <enum value="1"     name="VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR"/>
+        <enum value="2"     name="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR"/>
+        <enum               name="VK_QUERY_SCOPE_COMMAND_BUFFER_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR"/>
+        <enum               name="VK_QUERY_SCOPE_RENDER_PASS_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR"/>
+        <enum               name="VK_QUERY_SCOPE_COMMAND_KHR" alias="VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR"/>
+    </enums>
+    <enums name="VkPerformanceCounterUnitKHR" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR"/>
+        <enum value="1"     name="VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR"/>
+        <enum value="2"     name="VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR"/>
+        <enum value="3"     name="VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR"/>
+        <enum value="4"     name="VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR"/>
+        <enum value="5"     name="VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR"/>
+        <enum value="6"     name="VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR"/>
+        <enum value="7"     name="VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR"/>
+        <enum value="8"     name="VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR"/>
+        <enum value="9"     name="VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR"/>
+        <enum value="10"    name="VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR"/>
+    </enums>
+    <enums name="VkPerformanceCounterStorageKHR" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR"/>
+        <enum value="1"     name="VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR"/>
+        <enum value="2"     name="VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR"/>
+        <enum value="3"     name="VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR"/>
+        <enum value="4"     name="VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR"/>
+        <enum value="5"     name="VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR"/>
+    </enums>
+    <enums name="VkPerformanceCounterDescriptionFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR"/>
+        <enum               name="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR" alias="VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR" comment="Backwards-compatible alias containing a typo"/>
+        <enum bitpos="1"    name="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR"/>
+        <enum               name="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR" alias="VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR" comment="Backwards-compatible alias containing a typo"/>
+    </enums>
+    <enums name="VkAcquireProfilingLockFlagBitsKHR" type="bitmask">
+    </enums>
+    <enums name="VkShaderCorePropertiesFlagBitsAMD" type="bitmask">
+    </enums>
+    <enums name="VkPerformanceConfigurationTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL"/>
+    </enums>
+    <enums name="VkQueryPoolSamplingModeINTEL" type="enum">
+        <enum value="0"     name="VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL"/>
+    </enums>
+    <enums name="VkPerformanceOverrideTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL"/>
+        <enum value="1"     name="VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL"/>
+    </enums>
+    <enums name="VkPerformanceParameterTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL"/>
+        <enum value="1"     name="VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL"/>
+    </enums>
+    <enums name="VkPerformanceValueTypeINTEL" type="enum">
+        <enum value="0"     name="VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL"/>
+        <enum value="1"     name="VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL"/>
+        <enum value="2"     name="VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL"/>
+        <enum value="3"     name="VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL"/>
+        <enum value="4"     name="VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL"/>
+    </enums>
+    <enums name="VkShaderFloatControlsIndependence" type="enum">
+        <enum value="0"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"/>
+        <enum value="1"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"/>
+        <enum value="2"     name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"/>
+    </enums>
+    <enums name="VkPipelineExecutableStatisticFormatKHR" type="enum">
+        <enum value="0" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR"/>
+        <enum value="1" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR"/>
+        <enum value="2" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR"/>
+        <enum value="3" name="VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR"/>
+    </enums>
+    <enums name="VkLineRasterizationModeEXT" type="enum">
+        <enum value="0"     name="VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT"/>
+        <enum value="1"     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT"/>
+        <enum value="2"     name="VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT"/>
+        <enum value="3"     name="VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT"/>
+    </enums>
+    <enums name="VkShaderModuleCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPipelineCompilerControlFlagBitsAMD" type="bitmask">
+    </enums>
+    <enums name="VkToolPurposeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"     name="VK_TOOL_PURPOSE_VALIDATION_BIT_EXT"/>
+        <enum bitpos="1"     name="VK_TOOL_PURPOSE_PROFILING_BIT_EXT"/>
+        <enum bitpos="2"     name="VK_TOOL_PURPOSE_TRACING_BIT_EXT"/>
+        <enum bitpos="3"     name="VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT"/>
+        <enum bitpos="4"     name="VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT"/>
+    </enums>
+    <enums name="VkFragmentShadingRateCombinerOpKHR" type="enum">
+        <enum value="0" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR"/>
+        <enum value="1" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR"/>
+        <enum value="2" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR"/>
+        <enum value="3" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR"/>
+        <enum value="4" name="VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR"/>
+    </enums>
+    <enums name="VkFragmentShadingRateNV" type="enum">
+        <enum value="0"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV"/>
+        <enum value="1"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV"/>
+        <enum value="4"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV"/>
+        <enum value="5"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV"/>
+        <enum value="6"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV"/>
+        <enum value="9"  name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV"/>
+        <enum value="10" name="VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV"/>
+        <enum value="11" name="VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="12" name="VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="13" name="VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="14" name="VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV"/>
+        <enum value="15" name="VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV"/>
+    </enums>
+    <enums name="VkFragmentShadingRateTypeNV" type="enum">
+        <enum value="0"  name="VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV"/>
+        <enum value="1"  name="VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV"/>
+    </enums>
+    <enums name="VkAccessFlagBits2KHR" type="bitmask" bitwidth="64">
+        <enum value="0"     name="VK_ACCESS_2_NONE_KHR"/>
+        <enum bitpos="0"    name="VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_ACCESS_2_INDEX_READ_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_ACCESS_2_UNIFORM_READ_BIT_KHR"/>
+        <enum bitpos="4"    name="VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR"/>
+        <enum bitpos="5"    name="VK_ACCESS_2_SHADER_READ_BIT_KHR"/>
+        <enum bitpos="6"    name="VK_ACCESS_2_SHADER_WRITE_BIT_KHR"/>
+        <enum bitpos="7"    name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR"/>
+        <enum bitpos="8"    name="VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR"/>
+        <enum bitpos="9"    name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR"/>
+        <enum bitpos="10"   name="VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR"/>
+        <enum bitpos="11"   name="VK_ACCESS_2_TRANSFER_READ_BIT_KHR"/>
+        <enum bitpos="12"   name="VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR"/>
+        <enum bitpos="13"   name="VK_ACCESS_2_HOST_READ_BIT_KHR"/>
+        <enum bitpos="14"   name="VK_ACCESS_2_HOST_WRITE_BIT_KHR"/>
+        <enum bitpos="15"   name="VK_ACCESS_2_MEMORY_READ_BIT_KHR"/>
+        <enum bitpos="16"   name="VK_ACCESS_2_MEMORY_WRITE_BIT_KHR"/>
+        <!-- bitpos 17-31 are specified by extensions to the original VkAccessFlagBits enum -->
+        <enum bitpos="32"   name="VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR"/>
+        <enum bitpos="33"   name="VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR"/>
+        <enum bitpos="34"   name="VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR"/>
+    </enums>
+    <enums name="VkPipelineStageFlagBits2KHR" type="bitmask" bitwidth="64">
+        <enum value="0"    name="VK_PIPELINE_STAGE_2_NONE_KHR"/>
+        <enum bitpos="0"    name="VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR"/>
+        <enum bitpos="4"    name="VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR"/>
+        <enum bitpos="5"    name="VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR"/>
+        <enum bitpos="6"    name="VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR"/>
+        <enum bitpos="7"    name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR"/>
+        <enum bitpos="8"    name="VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR"/>
+        <enum bitpos="9"    name="VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR"/>
+        <enum bitpos="10"   name="VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR"/>
+        <enum bitpos="11"   name="VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR"/>
+        <enum bitpos="12"   name="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR"/>
+        <enum               name="VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR" alias="VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR"/>
+        <enum bitpos="13"   name="VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR"/>
+        <enum bitpos="14"   name="VK_PIPELINE_STAGE_2_HOST_BIT_KHR"/>
+        <enum bitpos="15"   name="VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR"/>
+        <enum bitpos="16"   name="VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR"/>
+        <!-- bitpos 17-31 are specified by extensions to the original VkPipelineStageFlagBits enum -->
+        <enum bitpos="32"   name="VK_PIPELINE_STAGE_2_COPY_BIT_KHR"/>
+        <enum bitpos="33"   name="VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR"/>
+        <enum bitpos="34"   name="VK_PIPELINE_STAGE_2_BLIT_BIT_KHR"/>
+        <enum bitpos="35"   name="VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR"/>
+        <enum bitpos="36"   name="VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR"/>
+        <enum bitpos="37"   name="VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR"/>
+        <enum bitpos="38"   name="VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR"/>
+    </enums>
+    <enums name="VkSubmitFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_SUBMIT_PROTECTED_BIT_KHR"/>
+    </enums>
+    <enums name="VkEventCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkPipelineLayoutCreateFlagBits" type="bitmask">
+    </enums>
+    <enums name="VkProvokingVertexModeEXT" type="enum">
+        <enum value="0"     name="VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT"/>
+        <enum value="1"     name="VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT"/>
+    </enums>
+    <enums name="VkAccelerationStructureMotionInstanceTypeNV" type="enum">
+        <enum value="0" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV"/>
+        <enum value="1" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV"/>
+        <enum value="2" name="VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV"/>
+    </enums>
+
+    <enums name="VkVideoCodecOperationFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_CODEC_OPERATION_INVALID_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoChromaSubsamplingFlagBitsKHR" type="bitmask" comment="Vulkan video chroma subsampling definitions">
+        <enum value="0"     name="VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_BIT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR"/>
+        <enum bitpos="3"    name="VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoComponentBitDepthFlagBitsKHR" type="bitmask" comment="Vulkan video component bit depth definitions">
+        <enum value="0"     name="VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR"/>
+        <enum bitpos="4"    name="VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoCapabilityFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoSessionCreateFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_SESSION_CREATE_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoCodingQualityPresetFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"       name="VK_VIDEO_CODING_QUALITY_PRESET_NORMAL_BIT_KHR"/>
+        <enum bitpos="1"       name="VK_VIDEO_CODING_QUALITY_PRESET_POWER_BIT_KHR"/>
+        <enum bitpos="2"       name="VK_VIDEO_CODING_QUALITY_PRESET_QUALITY_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoDecodeH264PictureLayoutFlagBitsEXT" type="bitmask">
+        <enum value="0"       name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_EXT"/>
+        <enum bitpos="0"      name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoCodingControlFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_CODING_CONTROL_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR"/>
+    </enums>
+    <enums name="VkQueryResultStatusKHR" type="enum">
+        <enum value="-1"    name="VK_QUERY_RESULT_STATUS_ERROR_KHR"/>
+        <enum value="0"     name="VK_QUERY_RESULT_STATUS_NOT_READY_KHR"/>
+        <enum value="1"     name="VK_QUERY_RESULT_STATUS_COMPLETE_KHR"/>
+    </enums>
+    <enums name="VkVideoDecodeFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_DECODE_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_DECODE_RESERVED_0_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_ENCODE_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_RESERVED_0_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeRateControlFlagBitsKHR" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_ENCODE_RATE_CONTROL_DEFAULT_KHR"/>
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_RATE_CONTROL_RESET_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeRateControlModeFlagBitsKHR" type="bitmask">
+        <enum value="0"      name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_NONE_BIT_KHR"/>
+        <enum value="1"      name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR"/>
+        <enum value="2"      name="VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeH264CapabilityFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_CABAC_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_CAVLC_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_WEIGHTED_BI_PRED_IMPLICIT_BIT_EXT"/>
+        <enum bitpos="3"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_TRANSFORM_8X8_BIT_EXT"/>
+        <enum bitpos="4"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_CHROMA_QP_OFFSET_BIT_EXT"/>
+        <enum bitpos="5"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_SECOND_CHROMA_QP_OFFSET_BIT_EXT"/>
+        <enum bitpos="6"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_DISABLED_BIT_EXT"/>
+        <enum bitpos="7"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_ENABLED_BIT_EXT"/>
+        <enum bitpos="8"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_DEBLOCKING_FILTER_PARTIAL_BIT_EXT"/>
+        <enum bitpos="9"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICE_PER_FRAME_BIT_EXT"/>
+        <enum bitpos="10"      name="VK_VIDEO_ENCODE_H264_CAPABILITY_EVENLY_DISTRIBUTED_SLICE_SIZE_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH264InputModeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H264_INPUT_MODE_FRAME_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H264_INPUT_MODE_SLICE_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H264_INPUT_MODE_NON_VCL_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH264OutputModeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H264_OUTPUT_MODE_FRAME_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H264_OUTPUT_MODE_SLICE_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H264_OUTPUT_MODE_NON_VCL_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH264CreateFlagBitsEXT" type="bitmask">
+        <enum value="0"     name="VK_VIDEO_ENCODE_H264_CREATE_DEFAULT_EXT"/>
+        <enum bitpos="0"    name="VK_VIDEO_ENCODE_H264_CREATE_RESERVED_0_BIT_EXT"/>
+    </enums>
+    <enums name="VkImageFormatConstraintsFlagBitsFUCHSIA" type="bitmask">
+    </enums>
+    <enums name="VkImageConstraintsInfoFlagBitsFUCHSIA" type="bitmask">
+        <enum bitpos="0"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA"/>
+        <enum bitpos="1"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA"/>
+        <enum bitpos="2"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA"/>
+        <enum bitpos="3"    name="VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA"/>
+        <enum bitpos="4"    name="VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA"/>
+    </enums>
+    <enums name="VkFormatFeatureFlagBits2KHR" type="bitmask" bitwidth="64">
+      <enum bitpos="0"  name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR"/>
+      <enum bitpos="1"  name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR"/>
+      <enum bitpos="2"  name="VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR"/>
+      <enum bitpos="3"  name="VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR"/>
+      <enum bitpos="4"  name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR"/>
+      <enum bitpos="5"  name="VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR"/>
+      <enum bitpos="6"  name="VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR"/>
+      <enum bitpos="7"  name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR"/>
+      <enum bitpos="8"  name="VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR"/>
+      <enum bitpos="9"  name="VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR"/>
+      <enum bitpos="10" name="VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR"/>
+      <enum bitpos="11" name="VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR"/>
+      <enum bitpos="12" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR"/>
+      <enum bitpos="13" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT"/>
+      <enum bitpos="14" name="VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR"/>
+      <enum bitpos="15" name="VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR"/>
+      <enum bitpos="16" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR"/>
+      <enum bitpos="17" name="VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR"/>
+      <enum bitpos="18" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR"/>
+      <enum bitpos="19" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR"/>
+      <enum bitpos="20" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR"/>
+      <enum bitpos="21" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR"/>
+      <enum bitpos="22" name="VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR"/>
+      <enum bitpos="23" name="VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR"/>
+      <enum bitpos="31" name="VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR"/>
+      <enum bitpos="32" name="VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR"/>
+      <enum bitpos="33" name="VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR"/>
+    </enums>
+    <enums name="VkVideoEncodeH265InputModeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_INPUT_MODE_FRAME_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_INPUT_MODE_SLICE_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_INPUT_MODE_NON_VCL_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH265OutputModeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_OUTPUT_MODE_FRAME_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_OUTPUT_MODE_SLICE_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_OUTPUT_MODE_NON_VCL_BIT_EXT"/>
+    </enums>
+    <enums name="VkVideoEncodeH265CtbSizeFlagBitsEXT" type="bitmask">
+        <enum bitpos="0"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_8_BIT_EXT"/>
+        <enum bitpos="1"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT"/>
+        <enum bitpos="2"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT"/>
+        <enum bitpos="3"      name="VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT"/>
+    </enums>
+    <enums name="VkRenderingFlagBitsKHR" type="bitmask">
+        <enum bitpos="0"    name="VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR"/>
+        <enum bitpos="1"    name="VK_RENDERING_SUSPENDING_BIT_KHR"/>
+        <enum bitpos="2"    name="VK_RENDERING_RESUMING_BIT_KHR"/>
+    </enums>
+
+    <commands comment="Vulkan command definitions">
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_LAYER_NOT_PRESENT,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INCOMPATIBLE_DRIVER">
+            <proto><type>VkResult</type> <name>vkCreateInstance</name></proto>
+            <param>const <type>VkInstanceCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkInstance</type>* <name>pInstance</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyInstance</name></proto>
+            <param optional="true" externsync="true"><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <implicitexternsyncparams>
+                <param>all sname:VkPhysicalDevice objects enumerated from pname:instance</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDevices</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceCount</name></param>
+            <param optional="true" len="pPhysicalDeviceCount"><type>VkPhysicalDevice</type>* <name>pPhysicalDevices</name></param>
+        </command>
+        <command>
+            <proto><type>PFN_vkVoidFunction</type> <name>vkGetDeviceProcAddr</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
+        </command>
+        <command>
+            <proto><type>PFN_vkVoidFunction</type> <name>vkGetInstanceProcAddr</name></proto>
+            <param optional="true"><type>VkInstance</type> <name>instance</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pName</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
+            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties</type>* <name>pQueueFamilyProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceMemoryProperties</type>* <name>pMemoryProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceFeatures</type>* <name>pFeatures</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkFormatProperties</type>* <name>pFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageType</type> <name>type</name></param>
+            <param><type>VkImageTiling</type> <name>tiling</name></param>
+            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
+            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
+            <param><type>VkImageFormatProperties</type>* <name>pImageFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkCreateDevice</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkDeviceCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDevice</type>* <name>pDevice</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDevice</name></proto>
+            <param optional="true" externsync="true"><type>VkDevice</type> <name>device</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <implicitexternsyncparams>
+                <param>all sname:VkQueue objects created from pname:device</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkEnumerateInstanceVersion</name></proto>
+            <param><type>uint32_t</type>* <name>pApiVersion</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkEnumerateInstanceLayerProperties</name></proto>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
+            <proto><type>VkResult</type> <name>vkEnumerateInstanceExtensionProperties</name></proto>
+            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkEnumerateDeviceLayerProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkLayerProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_LAYER_NOT_PRESENT">
+            <proto><type>VkResult</type> <name>vkEnumerateDeviceExtensionProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="true" len="null-terminated">const <type>char</type>* <name>pLayerName</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkExtensionProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceQueue</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>uint32_t</type> <name>queueIndex</name></param>
+            <param><type>VkQueue</type>* <name>pQueue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueSubmit</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+            <param optional="true"><type>uint32_t</type> <name>submitCount</name></param>
+            <param len="submitCount">const <type>VkSubmitInfo</type>* <name>pSubmits</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueWaitIdle</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkDeviceWaitIdle</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <implicitexternsyncparams>
+                <param>all sname:VkQueue objects created from pname:device</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkAllocateMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryAllocateInfo</type>* <name>pAllocateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDeviceMemory</type>* <name>pMemory</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkFreeMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_MEMORY_MAP_FAILED">
+            <proto><type>VkResult</type> <name>vkMapMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkDeviceSize</type> <name>size</name></param>
+            <param optional="true"><type>VkMemoryMapFlags</type> <name>flags</name></param>
+            <param optional="false,true"><type>void</type>** <name>ppData</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkUnmapMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDeviceMemory</type> <name>memory</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkFlushMappedMemoryRanges</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
+            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkInvalidateMappedMemoryRanges</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>memoryRangeCount</name></param>
+            <param len="memoryRangeCount">const <type>VkMappedMemoryRange</type>* <name>pMemoryRanges</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceMemoryCommitment</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type>* <name>pCommittedMemoryInBytes</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetBufferMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkBindBufferMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetImageMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkMemoryRequirements</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBindImageMemory</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkImage</type> <name>image</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkDeviceSize</type> <name>memoryOffset</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
+            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements</type>* <name>pSparseMemoryRequirements</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageType</type> <name>type</name></param>
+            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
+            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
+            <param><type>VkImageTiling</type> <name>tiling</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties</type>* <name>pProperties</name></param>
+        </command>
+        <command queues="sparse_binding" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueBindSparse</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+            <param optional="true"><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount" externsync="pBindInfo[].pBufferBinds[].buffer,pBindInfo[].pImageOpaqueBinds[].image,pBindInfo[].pImageBinds[].image">const <type>VkBindSparseInfo</type>* <name>pBindInfo</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateFence</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFence</type>* <name>pFence</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyFence</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetFences</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>fenceCount</name></param>
+            <param len="fenceCount" externsync="true">const <type>VkFence</type>* <name>pFences</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetFenceStatus</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkWaitForFences</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>fenceCount</name></param>
+            <param len="fenceCount">const <type>VkFence</type>* <name>pFences</name></param>
+            <param><type>VkBool32</type> <name>waitAll</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateSemaphore</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSemaphore</type>* <name>pSemaphore</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySemaphore</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkEventCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkEvent</type>* <name>pEvent</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkEvent</type> <name>event</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_EVENT_SET,VK_EVENT_RESET" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetEventStatus</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkEvent</type> <name>event</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetEvent</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkEvent</type> <name>event</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateQueryPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkQueryPoolCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkQueryPool</type>* <name>pQueryPool</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyQueryPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_NOT_READY" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetQueryPoolResults</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+            <param><type>VkDeviceSize</type> <name>stride</name></param>
+            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkResetQueryPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+        </command>
+        <command name="vkResetQueryPoolEXT"                        alias="vkResetQueryPool"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateBuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkBuffer</type>* <name>pBuffer</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyBuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkBuffer</type> <name>buffer</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateBufferView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferViewCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkBufferView</type>* <name>pView</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyBufferView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkBufferView</type> <name>bufferView</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateImage</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkImage</type>* <name>pImage</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyImage</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkImage</type> <name>image</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetImageSubresourceLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param>const <type>VkImageSubresource</type>* <name>pSubresource</name></param>
+            <param><type>VkSubresourceLayout</type>* <name>pLayout</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateImageView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageViewCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkImageView</type>* <name>pView</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyImageView</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkImageView</type> <name>imageView</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateShaderModule</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkShaderModuleCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkShaderModule</type>* <name>pShaderModule</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyShaderModule</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkShaderModule</type> <name>shaderModule</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreatePipelineCache</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPipelineCacheCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkPipelineCache</type>* <name>pPipelineCache</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPipelineCache</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineCacheData</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
+            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkMergePipelineCaches</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkPipelineCache</type> <name>dstCache</name></param>
+            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
+            <param len="srcCacheCount">const <type>VkPipelineCache</type>* <name>pSrcCaches</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateGraphicsPipelines</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkGraphicsPipelineCreateInfo</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateComputePipelines</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkComputePipelineCreateInfo</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkRenderPass</type> <name>renderpass</name></param>
+            <param><type>VkExtent2D</type>* <name>pMaxWorkgroupSize</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPipeline</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPipeline</type> <name>pipeline</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreatePipelineLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPipelineLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkPipelineLayout</type>* <name>pPipelineLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPipelineLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPipelineLayout</type> <name>pipelineLayout</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateSampler</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSamplerCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSampler</type>* <name>pSampler</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySampler</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSampler</type> <name>sampler</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDescriptorSetLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDescriptorSetLayout</type>* <name>pSetLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDescriptorSetLayout</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDescriptorSetLayout</type> <name>descriptorSetLayout</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTATION_EXT">
+            <proto><type>VkResult</type> <name>vkCreateDescriptorPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorPoolCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDescriptorPool</type>* <name>pDescriptorPool</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDescriptorPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkResetDescriptorPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
+            <param optional="true"><type>VkDescriptorPoolResetFlags</type> <name>flags</name></param>
+            <implicitexternsyncparams>
+                <param>any sname:VkDescriptorSet objects allocated from pname:descriptorPool</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FRAGMENTED_POOL,VK_ERROR_OUT_OF_POOL_MEMORY">
+            <proto><type>VkResult</type> <name>vkAllocateDescriptorSets</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pAllocateInfo-&gt;descriptorPool">const <type>VkDescriptorSetAllocateInfo</type>* <name>pAllocateInfo</name></param>
+            <param len="pAllocateInfo-&gt;descriptorSetCount"><type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkFreeDescriptorSets</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDescriptorPool</type> <name>descriptorPool</name></param>
+            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
+            <param noautovalidity="true" externsync="true" len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkUpdateDescriptorSets</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>uint32_t</type> <name>descriptorWriteCount</name></param>
+            <param len="descriptorWriteCount" externsync="pDescriptorWrites[].dstSet">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
+            <param optional="true"><type>uint32_t</type> <name>descriptorCopyCount</name></param>
+            <param len="descriptorCopyCount" externsync="pDescriptorCopies[].dstSet">const <type>VkCopyDescriptorSet</type>* <name>pDescriptorCopies</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateFramebuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFramebufferCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFramebuffer</type>* <name>pFramebuffer</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyFramebuffer</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkFramebuffer</type> <name>framebuffer</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateRenderPass</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkRenderPassCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyRenderPass</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkRenderPass</type> <name>renderPass</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetRenderAreaGranularity</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkRenderPass</type> <name>renderPass</name></param>
+            <param><type>VkExtent2D</type>* <name>pGranularity</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCommandPoolCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCommandPool</type>* <name>pCommandPool</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param optional="true"><type>VkCommandPoolResetFlags</type> <name>flags</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkAllocateCommandBuffers</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pAllocateInfo-&gt;commandPool">const <type>VkCommandBufferAllocateInfo</type>* <name>pAllocateInfo</name></param>
+            <param len="pAllocateInfo-&gt;commandBufferCount"><type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkFreeCommandBuffers</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
+            <param noautovalidity="true" externsync="true" len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBeginCommandBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCommandBufferBeginInfo</type>* <name>pBeginInfo</name></param>
+            <implicitexternsyncparams>
+                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkEndCommandBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <implicitexternsyncparams>
+                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
+            </implicitexternsyncparams>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkResetCommandBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkCommandBufferResetFlags</type> <name>flags</name></param>
+            <implicitexternsyncparams>
+                <param>the sname:VkCommandPool that pname:commandBuffer was allocated from</param>
+            </implicitexternsyncparams>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindPipeline</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetViewport</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstViewport</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetScissor</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstScissor</name></param>
+            <param><type>uint32_t</type> <name>scissorCount</name></param>
+            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetLineWidth</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>float</type> <name>lineWidth</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDepthBias</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>float</type> <name>depthBiasConstantFactor</name></param>
+            <param><type>float</type> <name>depthBiasClamp</name></param>
+            <param><type>float</type> <name>depthBiasSlopeFactor</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetBlendConstants</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>float</type> <name>blendConstants</name>[4]</param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDepthBounds</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>float</type> <name>minDepthBounds</name></param>
+            <param><type>float</type> <name>maxDepthBounds</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetStencilCompareMask</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>uint32_t</type> <name>compareMask</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetStencilWriteMask</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>uint32_t</type> <name>writeMask</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetStencilReference</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>uint32_t</type> <name>reference</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindDescriptorSets</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>firstSet</name></param>
+            <param><type>uint32_t</type> <name>descriptorSetCount</name></param>
+            <param len="descriptorSetCount">const <type>VkDescriptorSet</type>* <name>pDescriptorSets</name></param>
+            <param optional="true"><type>uint32_t</type> <name>dynamicOffsetCount</name></param>
+            <param len="dynamicOffsetCount">const <type>uint32_t</type>* <name>pDynamicOffsets</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindIndexBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkIndexType</type> <name>indexType</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindVertexBuffers</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstBinding</name></param>
+            <param><type>uint32_t</type> <name>bindingCount</name></param>
+            <param len="bindingCount" optional="false,true">const <type>VkBuffer</type>* <name>pBuffers</name></param>
+            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDraw</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>vertexCount</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstVertex</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawIndexed</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>indexCount</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstIndex</name></param>
+            <param><type>int32_t</type> <name>vertexOffset</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawMultiEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>drawCount</name></param>
+            <param noautovalidity="true" len="drawCount">const <type>VkMultiDrawInfoEXT</type>* <name>pVertexInfo</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawMultiIndexedEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>drawCount</name></param>
+            <param noautovalidity="true" len="drawCount">const <type>VkMultiDrawIndexedInfoEXT</type>* <name>pIndexInfo</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+            <param optional="true">const <type>int32_t</type>* <name>pVertexOffset</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawIndirect</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>drawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawIndexedIndirect</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>drawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDispatch</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>groupCountX</name></param>
+            <param><type>uint32_t</type> <name>groupCountY</name></param>
+            <param><type>uint32_t</type> <name>groupCountZ</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDispatchIndirect</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSubpassShadingHUAWEI</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkBufferCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkImageCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBlitImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkImageBlit</type>* <name>pRegions</name></param>
+            <param><type>VkFilter</type> <name>filter</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyBufferToImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>srcBuffer</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyImageToBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkBufferImageCopy</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdUpdateBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>dataSize</name></param>
+            <param len="dataSize">const <type>void</type>* <name>pData</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary" comment="transfer support is only available when VK_KHR_maintenance1 is enabled, as documented in valid usage language in the specification">
+            <proto><type>void</type> <name>vkCmdFillBuffer</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>size</name></param>
+            <param><type>uint32_t</type> <name>data</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdClearColorImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+            <param noautovalidity="true">const <type>VkClearColorValue</type>* <name>pColor</name></param>
+            <param><type>uint32_t</type> <name>rangeCount</name></param>
+            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdClearDepthStencilImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+            <param>const <type>VkClearDepthStencilValue</type>* <name>pDepthStencil</name></param>
+            <param><type>uint32_t</type> <name>rangeCount</name></param>
+            <param len="rangeCount">const <type>VkImageSubresourceRange</type>* <name>pRanges</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdClearAttachments</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>attachmentCount</name></param>
+            <param len="attachmentCount">const <type>VkClearAttachment</type>* <name>pAttachments</name></param>
+            <param><type>uint32_t</type> <name>rectCount</name></param>
+            <param len="rectCount">const <type>VkClearRect</type>* <name>pRects</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdResolveImage</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkImage</type> <name>srcImage</name></param>
+            <param><type>VkImageLayout</type> <name>srcImageLayout</name></param>
+            <param><type>VkImage</type> <name>dstImage</name></param>
+            <param><type>VkImageLayout</type> <name>dstImageLayout</name></param>
+            <param><type>uint32_t</type> <name>regionCount</name></param>
+            <param len="regionCount">const <type>VkImageResolve</type>* <name>pRegions</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetEvent</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkEvent</type> <name>event</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdResetEvent</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkEvent</type> <name>event</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>stageMask</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWaitEvents</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>eventCount</name></param>
+            <param len="eventCount">const <type>VkEvent</type>* <name>pEvents</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
+            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
+            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
+            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
+            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdPipelineBarrier</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>srcStageMask</name></param>
+            <param optional="true"><type>VkPipelineStageFlags</type> <name>dstStageMask</name></param>
+            <param optional="true"><type>VkDependencyFlags</type> <name>dependencyFlags</name></param>
+            <param optional="true"><type>uint32_t</type> <name>memoryBarrierCount</name></param>
+            <param len="memoryBarrierCount">const <type>VkMemoryBarrier</type>* <name>pMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>bufferMemoryBarrierCount</name></param>
+            <param len="bufferMemoryBarrierCount">const <type>VkBufferMemoryBarrier</type>* <name>pBufferMemoryBarriers</name></param>
+            <param optional="true"><type>uint32_t</type> <name>imageMemoryBarrierCount</name></param>
+            <param len="imageMemoryBarrierCount">const <type>VkImageMemoryBarrier</type>* <name>pImageMemoryBarriers</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBeginQuery</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdEndQuery</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBeginConditionalRenderingEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkConditionalRenderingBeginInfoEXT</type>* <name>pConditionalRenderingBegin</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdEndConditionalRenderingEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdResetQueryPool</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWriteTimestamp</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyQueryPoolResults</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+            <param><type>uint32_t</type> <name>queryCount</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>stride</name></param>
+            <param optional="true"><type>VkQueryResultFlags</type> <name>flags</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdPushConstants</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>VkShaderStageFlags</type> <name>stageFlags</name></param>
+            <param><type>uint32_t</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>size</name></param>
+            <param len="size">const <type>void</type>* <name>pValues</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdBeginRenderPass</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkRenderPassBeginInfo</type>* <name>pRenderPassBegin</name></param>
+            <param><type>VkSubpassContents</type> <name>contents</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdNextSubpass</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkSubpassContents</type> <name>contents</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdEndRenderPass</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdExecuteCommands</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>commandBufferCount</name></param>
+            <param len="commandBufferCount">const <type>VkCommandBuffer</type>* <name>pCommandBuffers</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateAndroidSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkAndroidSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayPropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlanePropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayPlanePropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayPlaneSupportedDisplaysKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>planeIndex</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pDisplayCount</name></param>
+            <param optional="true" len="pDisplayCount"><type>VkDisplayKHR</type>* <name>pDisplays</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayModePropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayModePropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateDisplayModeKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param externsync="true"><type>VkDisplayKHR</type> <name>display</name></param>
+            <param>const <type>VkDisplayModeCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDisplayModeKHR</type>* <name>pMode</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilitiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param externsync="true"><type>VkDisplayModeKHR</type> <name>mode</name></param>
+            <param><type>uint32_t</type> <name>planeIndex</name></param>
+            <param><type>VkDisplayPlaneCapabilitiesKHR</type>* <name>pCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDisplayPlaneSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDisplaySurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INCOMPATIBLE_DISPLAY_KHR,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkCreateSharedSwapchainsKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>swapchainCount</name></param>
+            <param len="swapchainCount" externsync="pCreateInfos[].surface,pCreateInfos[].oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="swapchainCount"><type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true" externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param><type>VkBool32</type>* <name>pSupported</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilitiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param><type>VkSurfaceCapabilitiesKHR</type>* <name>pSurfaceCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormatsKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
+            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormatKHR</type>* <name>pSurfaceFormats</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
+            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateSwapchainKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pCreateInfo-&gt;surface,pCreateInfo-&gt;oldSwapchain">const <type>VkSwapchainCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSwapchainKHR</type>* <name>pSwapchain</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroySwapchainKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSwapchainImagesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSwapchainImageCount</name></param>
+            <param optional="true" len="pSwapchainImageCount"><type>VkImage</type>* <name>pSwapchainImages</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkAcquireNextImageKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+            <param optional="true" externsync="true"><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type> <name>fence</name></param>
+            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkQueuePresentKHR</name></proto>
+            <param externsync="true"><type>VkQueue</type> <name>queue</name></param>
+            <param externsync="pPresentInfo-&gt;pWaitSemaphores[],pPresentInfo-&gt;pSwapchains[]">const <type>VkPresentInfoKHR</type>* <name>pPresentInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateViSurfaceNN</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkViSurfaceCreateInfoNN</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateWaylandSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkWaylandSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWaylandPresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param>struct <type>wl_display</type>* <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateWin32SurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkWin32SurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceWin32PresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateXlibSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkXlibSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXlibPresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>Display</type>* <name>dpy</name></param>
+            <param><type>VisualID</type> <name>visualID</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateXcbSurfaceKHR</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkXcbSurfaceCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceXcbPresentationSupportKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>xcb_connection_t</type>* <name>connection</name></param>
+            <param><type>xcb_visualid_t</type> <name>visual_id</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDirectFBSurfaceEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDirectFBSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceDirectFBPresentationSupportEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param><type>IDirectFB</type>* <name>dfb</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateImagePipeSurfaceFUCHSIA</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkImagePipeSurfaceCreateInfoFUCHSIA</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateStreamDescriptorSurfaceGGP</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkStreamDescriptorSurfaceCreateInfoGGP</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateScreenSurfaceQNX</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkScreenSurfaceCreateInfoQNX</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command>
+            <proto><type>VkBool32</type> <name>vkGetPhysicalDeviceScreenPresentationSupportQNX</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param>struct <type>_screen_window</type>* <name>window</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDebugReportCallbackEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDebugReportCallbackCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDebugReportCallbackEXT</type>* <name>pCallback</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDebugReportCallbackEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true" externsync="true"><type>VkDebugReportCallbackEXT</type> <name>callback</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDebugReportMessageEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param><type>VkDebugReportFlagsEXT</type> <name>flags</name></param>
+            <param><type>VkDebugReportObjectTypeEXT</type> <name>objectType</name></param>
+            <param objecttype="objectType"><type>uint64_t</type> <name>object</name></param>
+            <param><type>size_t</type> <name>location</name></param>
+            <param><type>int32_t</type> <name>messageCode</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pLayerPrefix</name></param>
+            <param len="null-terminated">const <type>char</type>* <name>pMessage</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectNameEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pNameInfo-&gt;object">const <type>VkDebugMarkerObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkDebugMarkerSetObjectTagEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pTagInfo-&gt;object">const <type>VkDebugMarkerObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDebugMarkerBeginEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDebugMarkerEndEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDebugMarkerInsertEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugMarkerMarkerInfoEXT</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceExternalImageFormatPropertiesNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageType</type> <name>type</name></param>
+            <param><type>VkImageTiling</type> <name>tiling</name></param>
+            <param><type>VkImageUsageFlags</type> <name>usage</name></param>
+            <param optional="true"><type>VkImageCreateFlags</type> <name>flags</name></param>
+            <param optional="true"><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>externalHandleType</name></param>
+            <param><type>VkExternalImageFormatPropertiesNV</type>* <name>pExternalImageFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagsNV</type> <name>handleType</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdExecuteGeneratedCommandsNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>isPreprocessed</name></param>
+            <param>const <type>VkGeneratedCommandsInfoNV</type>* <name>pGeneratedCommandsInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdPreprocessGeneratedCommandsNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkGeneratedCommandsInfoNV</type>* <name>pGeneratedCommandsInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindPipelineShaderGroupNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>groupIndex</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetGeneratedCommandsMemoryRequirementsNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkGeneratedCommandsMemoryRequirementsInfoNV</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateIndirectCommandsLayoutNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkIndirectCommandsLayoutCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkIndirectCommandsLayoutNV</type>* <name>pIndirectCommandsLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyIndirectCommandsLayoutNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkIndirectCommandsLayoutNV</type> <name>indirectCommandsLayout</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFeatures2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceFeatures2</type>* <name>pFeatures</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceFeatures2KHR"                        alias="vkGetPhysicalDeviceFeatures2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceProperties2</type>* <name>pProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceProperties2KHR"                      alias="vkGetPhysicalDeviceProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceFormatProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkFormatProperties2</type>* <name>pFormatProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceFormatProperties2KHR"                alias="vkGetPhysicalDeviceFormatProperties2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceImageFormatProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceImageFormatInfo2</type>* <name>pImageFormatInfo</name></param>
+            <param><type>VkImageFormatProperties2</type>* <name>pImageFormatProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"           alias="vkGetPhysicalDeviceImageFormatProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pQueueFamilyPropertyCount</name></param>
+            <param optional="true" len="pQueueFamilyPropertyCount"><type>VkQueueFamilyProperties2</type>* <name>pQueueFamilyProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"           alias="vkGetPhysicalDeviceQueueFamilyProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceMemoryProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkPhysicalDeviceMemoryProperties2</type>* <name>pMemoryProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceMemoryProperties2KHR"                alias="vkGetPhysicalDeviceMemoryProperties2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceSparseImageFormatProperties2</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSparseImageFormatInfo2</type>* <name>pFormatInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkSparseImageFormatProperties2</type>* <name>pProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"     alias="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdPushDescriptorSetKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineBindPoint</type> <name>pipelineBindPoint</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>set</name></param>
+            <param><type>uint32_t</type> <name>descriptorWriteCount</name></param>
+            <param len="descriptorWriteCount">const <type>VkWriteDescriptorSet</type>* <name>pDescriptorWrites</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkTrimCommandPool</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkCommandPool</type> <name>commandPool</name></param>
+            <param optional="true"><type>VkCommandPoolTrimFlags</type> <name>flags</name></param>
+        </command>
+        <command name="vkTrimCommandPoolKHR"                                   alias="vkTrimCommandPool"/>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalBufferProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceExternalBufferInfo</type>* <name>pExternalBufferInfo</name></param>
+            <param><type>VkExternalBufferProperties</type>* <name>pExternalBufferProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"         alias="vkGetPhysicalDeviceExternalBufferProperties"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryWin32HandlePropertiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>HANDLE</type> <name>handle</name></param>
+            <param><type>VkMemoryWin32HandlePropertiesKHR</type>* <name>pMemoryWin32HandleProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
+            <param><type>int</type>* <name>pFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryFdPropertiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>int</type> <name>fd</name></param>
+            <param><type>VkMemoryFdPropertiesKHR</type>* <name>pMemoryFdProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryZirconHandleFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetZirconHandleInfoFUCHSIA</type>* <name>pGetZirconHandleInfo</name></param>
+            <param><type>zx_handle_t</type>* <name>pZirconHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryZirconHandlePropertiesFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param><type>zx_handle_t</type> <name>zirconHandle</name></param>
+            <param><type>VkMemoryZirconHandlePropertiesFUCHSIA</type>* <name>pMemoryZirconHandleProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryRemoteAddressNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetRemoteAddressInfoNV</type>* <name>pMemoryGetRemoteAddressInfo</name></param>
+            <param><type>VkRemoteAddressNV</type>* <name>pAddress</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalSemaphoreProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceExternalSemaphoreInfo</type>* <name>pExternalSemaphoreInfo</name></param>
+            <param><type>VkExternalSemaphoreProperties</type>* <name>pExternalSemaphoreProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"      alias="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportSemaphoreWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportSemaphoreWin32HandleInfoKHR</type>* <name>pImportSemaphoreWin32HandleInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
+            <param><type>int</type>* <name>pFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportSemaphoreFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportSemaphoreFdInfoKHR</type>* <name>pImportSemaphoreFdInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreZirconHandleFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreGetZirconHandleInfoFUCHSIA</type>* <name>pGetZirconHandleInfo</name></param>
+            <param><type>zx_handle_t</type>* <name>pZirconHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportSemaphoreZirconHandleFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportSemaphoreZirconHandleInfoFUCHSIA</type>* <name>pImportSemaphoreZirconHandleInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceExternalFenceProperties</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceExternalFenceInfo</type>* <name>pExternalFenceInfo</name></param>
+            <param><type>VkExternalFenceProperties</type>* <name>pExternalFenceProperties</name></param>
+        </command>
+        <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"          alias="vkGetPhysicalDeviceExternalFenceProperties"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetFenceWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceGetWin32HandleInfoKHR</type>* <name>pGetWin32HandleInfo</name></param>
+            <param><type>HANDLE</type>* <name>pHandle</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportFenceWin32HandleKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportFenceWin32HandleInfoKHR</type>* <name>pImportFenceWin32HandleInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetFenceFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkFenceGetFdInfoKHR</type>* <name>pGetFdInfo</name></param>
+            <param><type>int</type>* <name>pFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkImportFenceFdKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImportFenceFdInfoKHR</type>* <name>pImportFenceFdInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS">
+            <proto><type>VkResult</type> <name>vkReleaseDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkAcquireXlibDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>Display</type>* <name>dpy</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetRandROutputDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>Display</type>* <name>dpy</name></param>
+            <param><type>RROutput</type> <name>rrOutput</name></param>
+            <param><type>VkDisplayKHR</type>* <name>pDisplay</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkAcquireWinrtDisplayNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetWinrtDisplayNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>deviceRelativeId</name></param>
+            <param><type>VkDisplayKHR</type>* <name>pDisplay</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkDisplayPowerControlEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param>const <type>VkDisplayPowerInfoEXT</type>* <name>pDisplayPowerInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkRegisterDeviceEventEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceEventInfoEXT</type>* <name>pDeviceEventInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFence</type>* <name>pFence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkRegisterDisplayEventEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param>const <type>VkDisplayEventInfoEXT</type>* <name>pDisplayEventInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkFence</type>* <name>pFence</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR">
+            <proto><type>VkResult</type> <name>vkGetSwapchainCounterEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>VkSurfaceCounterFlagBitsEXT</type> <name>counter</name></param>
+            <param><type>uint64_t</type>* <name>pCounterValue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2EXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param><type>VkSurfaceCapabilities2EXT</type>* <name>pSurfaceCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceGroups</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPhysicalDeviceGroupCount</name></param>
+            <param optional="true" len="pPhysicalDeviceGroupCount"><type>VkPhysicalDeviceGroupProperties</type>* <name>pPhysicalDeviceGroupProperties</name></param>
+        </command>
+        <command name="vkEnumeratePhysicalDeviceGroupsKHR"                     alias="vkEnumeratePhysicalDeviceGroups"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceGroupPeerMemoryFeatures</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>heapIndex</name></param>
+            <param><type>uint32_t</type> <name>localDeviceIndex</name></param>
+            <param><type>uint32_t</type> <name>remoteDeviceIndex</name></param>
+            <param><type>VkPeerMemoryFeatureFlags</type>* <name>pPeerMemoryFeatures</name></param>
+        </command>
+        <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"                  alias="vkGetDeviceGroupPeerMemoryFeatures"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkBindBufferMemory2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount">const <type>VkBindBufferMemoryInfo</type>* <name>pBindInfos</name></param>
+        </command>
+        <command name="vkBindBufferMemory2KHR"                                 alias="vkBindBufferMemory2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBindImageMemory2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount">const <type>VkBindImageMemoryInfo</type>* <name>pBindInfos</name></param>
+        </command>
+        <command name="vkBindImageMemory2KHR"                                  alias="vkBindImageMemory2"/>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDeviceMask</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>deviceMask</name></param>
+        </command>
+        <command name="vkCmdSetDeviceMaskKHR"                                  alias="vkCmdSetDeviceMask"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDeviceGroupPresentCapabilitiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceGroupPresentCapabilitiesKHR</type>* <name>pDeviceGroupPresentCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT,VK_NOT_READY,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkAcquireNextImage2KHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAcquireNextImageInfoKHR</type>* <name>pAcquireInfo</name></param>
+            <param><type>uint32_t</type>* <name>pImageIndex</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDispatchBase</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>baseGroupX</name></param>
+            <param><type>uint32_t</type> <name>baseGroupY</name></param>
+            <param><type>uint32_t</type> <name>baseGroupZ</name></param>
+            <param><type>uint32_t</type> <name>groupCountX</name></param>
+            <param><type>uint32_t</type> <name>groupCountY</name></param>
+            <param><type>uint32_t</type> <name>groupCountZ</name></param>
+        </command>
+        <command name="vkCmdDispatchBaseKHR"                                   alias="vkCmdDispatchBase"/>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDevicePresentRectanglesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param externsync="true"><type>VkSurfaceKHR</type> <name>surface</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pRectCount</name></param>
+            <param optional="true" len="pRectCount"><type>VkRect2D</type>* <name>pRects</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDescriptorUpdateTemplate</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorUpdateTemplateCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDescriptorUpdateTemplate</type>* <name>pDescriptorUpdateTemplate</name></param>
+        </command>
+        <command name="vkCreateDescriptorUpdateTemplateKHR"                    alias="vkCreateDescriptorUpdateTemplate"/>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDescriptorUpdateTemplate</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command name="vkDestroyDescriptorUpdateTemplateKHR"                   alias="vkDestroyDescriptorUpdateTemplate"/>
+        <command>
+            <proto><type>void</type> <name>vkUpdateDescriptorSetWithTemplate</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkDescriptorSet</type> <name>descriptorSet</name></param>
+            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
+            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
+        </command>
+        <command name="vkUpdateDescriptorSetWithTemplateKHR"                   alias="vkUpdateDescriptorSetWithTemplate"/>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdPushDescriptorSetWithTemplateKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkDescriptorUpdateTemplate</type> <name>descriptorUpdateTemplate</name></param>
+            <param><type>VkPipelineLayout</type> <name>layout</name></param>
+            <param><type>uint32_t</type> <name>set</name></param>
+            <param noautovalidity="true">const <type>void</type>* <name>pData</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSetHdrMetadataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>swapchainCount</name></param>
+            <param len="swapchainCount">const <type>VkSwapchainKHR</type>* <name>pSwapchains</name></param>
+            <param len="swapchainCount">const <type>VkHdrMetadataEXT</type>* <name>pMetadata</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_SUBOPTIMAL_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR,VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT">
+            <proto><type>VkResult</type> <name>vkGetSwapchainStatusKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetRefreshCycleDurationGOOGLE</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>VkRefreshCycleDurationGOOGLE</type>* <name>pDisplayTimingProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_DEVICE_LOST,VK_ERROR_OUT_OF_DATE_KHR,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPastPresentationTimingGOOGLE</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPresentationTimingCount</name></param>
+            <param optional="true" len="pPresentationTimingCount"><type>VkPastPresentationTimingGOOGLE</type>* <name>pPresentationTimings</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateIOSSurfaceMVK</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkIOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateMacOSSurfaceMVK</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkMacOSSurfaceCreateInfoMVK</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_NATIVE_WINDOW_IN_USE_KHR">
+            <proto><type>VkResult</type> <name>vkCreateMetalSurfaceEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkMetalSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetViewportWScalingNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstViewport</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkViewportWScalingNV</type>* <name>pViewportWScalings</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDiscardRectangleEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstDiscardRectangle</name></param>
+            <param><type>uint32_t</type> <name>discardRectangleCount</name></param>
+            <param len="discardRectangleCount">const <type>VkRect2D</type>* <name>pDiscardRectangles</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetSampleLocationsEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkSampleLocationsInfoEXT</type>* <name>pSampleLocationsInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceMultisamplePropertiesEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkSampleCountFlagBits</type> <name>samples</name></param>
+            <param><type>VkMultisamplePropertiesEXT</type>* <name>pMultisampleProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceCapabilities2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param><type>VkSurfaceCapabilities2KHR</type>* <name>pSurfaceCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfaceFormats2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSurfaceFormatCount</name></param>
+            <param optional="true" len="pSurfaceFormatCount"><type>VkSurfaceFormat2KHR</type>* <name>pSurfaceFormats</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayProperties2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayProperties2KHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceDisplayPlaneProperties2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayPlaneProperties2KHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayModeProperties2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkDisplayModeProperties2KHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDisplayPlaneCapabilities2KHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkDisplayPlaneInfo2KHR</type>* <name>pDisplayPlaneInfo</name></param>
+            <param><type>VkDisplayPlaneCapabilities2KHR</type>* <name>pCapabilities</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetBufferMemoryRequirements2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetBufferMemoryRequirements2KHR"                      alias="vkGetBufferMemoryRequirements2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetImageMemoryRequirements2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetImageMemoryRequirements2KHR"                       alias="vkGetImageMemoryRequirements2"/>
+        <command>
+            <proto><type>void</type> <name>vkGetImageSparseMemoryRequirements2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageSparseMemoryRequirementsInfo2</type>* <name>pInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
+            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements2</type>* <name>pSparseMemoryRequirements</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceBufferMemoryRequirementsKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceBufferMemoryRequirementsKHR</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceImageMemoryRequirementsKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceImageMemoryRequirementsKHR</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceImageSparseMemoryRequirementsKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceImageMemoryRequirementsKHR</type>* <name>pInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pSparseMemoryRequirementCount</name></param>
+            <param optional="true" len="pSparseMemoryRequirementCount"><type>VkSparseImageMemoryRequirements2</type>* <name>pSparseMemoryRequirements</name></param>
+        </command>
+        <command name="vkGetImageSparseMemoryRequirements2KHR"                 alias="vkGetImageSparseMemoryRequirements2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateSamplerYcbcrConversion</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSamplerYcbcrConversionCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSamplerYcbcrConversion</type>* <name>pYcbcrConversion</name></param>
+        </command>
+        <command name="vkCreateSamplerYcbcrConversionKHR"                      alias="vkCreateSamplerYcbcrConversion"/>
+        <command>
+            <proto><type>void</type> <name>vkDestroySamplerYcbcrConversion</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkSamplerYcbcrConversion</type> <name>ycbcrConversion</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command name="vkDestroySamplerYcbcrConversionKHR"                     alias="vkDestroySamplerYcbcrConversion"/>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceQueue2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceQueueInfo2</type>* <name>pQueueInfo</name></param>
+            <param><type>VkQueue</type>* <name>pQueue</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateValidationCacheEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkValidationCacheCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkValidationCacheEXT</type>* <name>pValidationCache</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyValidationCacheEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetValidationCacheDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkValidationCacheEXT</type> <name>validationCache</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pDataSize</name></param>
+            <param optional="true" len="pDataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkMergeValidationCachesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkValidationCacheEXT</type> <name>dstCache</name></param>
+            <param><type>uint32_t</type> <name>srcCacheCount</name></param>
+            <param len="srcCacheCount">const <type>VkValidationCacheEXT</type>* <name>pSrcCaches</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDescriptorSetLayoutSupport</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDescriptorSetLayoutCreateInfo</type>* <name>pCreateInfo</name></param>
+            <param><type>VkDescriptorSetLayoutSupport</type>* <name>pSupport</name></param>
+        </command>
+        <command name="vkGetDescriptorSetLayoutSupportKHR"                     alias="vkGetDescriptorSetLayoutSupport"/>
+        <command>
+            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsageANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
+            <param><type>int</type>* <name>grallocUsage</name></param>
+        </command>
+        <command>
+            <proto><type>VkResult</type> <name>vkGetSwapchainGrallocUsage2ANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkFormat</type> <name>format</name></param>
+            <param><type>VkImageUsageFlags</type> <name>imageUsage</name></param>
+            <param><type>VkSwapchainImageUsageFlagsANDROID</type> <name>swapchainImageUsage</name></param>
+            <param><type>uint64_t</type>* <name>grallocConsumerUsage</name></param>
+            <param><type>uint64_t</type>* <name>grallocProducerUsage</name></param>
+        </command>
+        <command>
+            <proto><type>VkResult</type> <name>vkAcquireImageANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>int</type> <name>nativeFenceFd</name></param>
+            <param><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param><type>VkFence</type> <name>fence</name></param>
+        </command>
+        <command>
+            <proto><type>VkResult</type> <name>vkQueueSignalReleaseImageANDROID</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param><type>uint32_t</type> <name>waitSemaphoreCount</name></param>
+            <param len="waitSemaphoreCount">const <type>VkSemaphore</type>* <name>pWaitSemaphores</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>int</type>* <name>pNativeFenceFd</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetShaderInfoAMD</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>VkShaderStageFlagBits</type> <name>shaderStage</name></param>
+            <param><type>VkShaderInfoTypeAMD</type> <name>infoType</name></param>
+            <param optional="false,true"><type>size_t</type>* <name>pInfoSize</name></param>
+            <param optional="true" len="pInfoSize"><type>void</type>* <name>pInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSetLocalDimmingAMD</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapChain</name></param>
+            <param><type>VkBool32</type> <name>localDimmingEnable</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCalibrateableTimeDomainsEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pTimeDomainCount</name></param>
+            <param optional="true" len="pTimeDomainCount"><type>VkTimeDomainEXT</type>* <name>pTimeDomains</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetCalibratedTimestampsEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>timestampCount</name></param>
+            <param len="timestampCount">const <type>VkCalibratedTimestampInfoEXT</type>* <name>pTimestampInfos</name></param>
+            <param len="timestampCount"><type>uint64_t</type>* <name>pTimestamps</name></param>
+            <param><type>uint64_t</type>* <name>pMaxDeviation</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectNameEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pNameInfo-&gt;objectHandle">const <type>VkDebugUtilsObjectNameInfoEXT</type>* <name>pNameInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetDebugUtilsObjectTagEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="pTagInfo-&gt;objectHandle">const <type>VkDebugUtilsObjectTagInfoEXT</type>* <name>pTagInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkQueueBeginDebugUtilsLabelEXT</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkQueueEndDebugUtilsLabelEXT</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkQueueInsertDebugUtilsLabelEXT</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBeginDebugUtilsLabelEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdEndDebugUtilsLabelEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdInsertDebugUtilsLabelEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkDebugUtilsLabelEXT</type>* <name>pLabelInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDebugUtilsMessengerEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkDebugUtilsMessengerCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDebugUtilsMessengerEXT</type>* <name>pMessenger</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDebugUtilsMessengerEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param optional="true" externsync="true"><type>VkDebugUtilsMessengerEXT</type> <name>messenger</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSubmitDebugUtilsMessageEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param><type>VkDebugUtilsMessageSeverityFlagBitsEXT</type> <name>messageSeverity</name></param>
+            <param><type>VkDebugUtilsMessageTypeFlagsEXT</type> <name>messageTypes</name></param>
+            <param>const <type>VkDebugUtilsMessengerCallbackDataEXT</type>* <name>pCallbackData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE">
+            <proto><type>VkResult</type> <name>vkGetMemoryHostPointerPropertiesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkExternalMemoryHandleTypeFlagBits</type> <name>handleType</name></param>
+            <param optional="false">const <type>void</type>* <name>pHostPointer</name></param>
+            <param><type>VkMemoryHostPointerPropertiesEXT</type>* <name>pMemoryHostPointerProperties</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWriteBufferMarkerAMD</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPipelineStageFlagBits</type> <name>pipelineStage</name></param>
+            <param><type>VkBuffer</type> <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>dstOffset</name></param>
+            <param><type>uint32_t</type> <name>marker</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateRenderPass2</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkRenderPassCreateInfo2</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkRenderPass</type>* <name>pRenderPass</name></param>
+        </command>
+        <command name="vkCreateRenderPass2KHR"                                 alias="vkCreateRenderPass2"/>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdBeginRenderPass2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkRenderPassBeginInfo</type>*      <name>pRenderPassBegin</name></param>
+            <param>const <type>VkSubpassBeginInfo</type>*      <name>pSubpassBeginInfo</name></param>
+        </command>
+        <command name="vkCmdBeginRenderPass2KHR"                               alias="vkCmdBeginRenderPass2"/>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdNextSubpass2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkSubpassBeginInfo</type>*      <name>pSubpassBeginInfo</name></param>
+            <param>const <type>VkSubpassEndInfo</type>*        <name>pSubpassEndInfo</name></param>
+        </command>
+        <command name="vkCmdNextSubpass2KHR"                                   alias="vkCmdNextSubpass2"/>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdEndRenderPass2</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkSubpassEndInfo</type>*        <name>pSubpassEndInfo</name></param>
+        </command>
+        <command name="vkCmdEndRenderPass2KHR"                                 alias="vkCmdEndRenderPass2"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkGetSemaphoreCounterValue</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSemaphore</type> <name>semaphore</name></param>
+            <param><type>uint64_t</type>* <name>pValue</name></param>
+        </command>
+        <command name="vkGetSemaphoreCounterValueKHR"              alias="vkGetSemaphoreCounterValue"/>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkWaitSemaphores</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreWaitInfo</type>* <name>pWaitInfo</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+        </command>
+        <command name="vkWaitSemaphoresKHR"                        alias="vkWaitSemaphores"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkSignalSemaphore</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkSemaphoreSignalInfo</type>* <name>pSignalInfo</name></param>
+        </command>
+        <command name="vkSignalSemaphoreKHR"                       alias="vkSignalSemaphore"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR">
+            <proto><type>VkResult</type> <name>vkGetAndroidHardwareBufferPropertiesANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const struct <type>AHardwareBuffer</type>* <name>buffer</name></param>
+            <param><type>VkAndroidHardwareBufferPropertiesANDROID</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetMemoryAndroidHardwareBufferANDROID</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkMemoryGetAndroidHardwareBufferInfoANDROID</type>* <name>pInfo</name></param>
+            <param>struct <type>AHardwareBuffer</type>** <name>pBuffer</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawIndirectCount</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkBuffer</type> <name>countBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command name="vkCmdDrawIndirectCountKHR"                              alias="vkCmdDrawIndirectCount"/>
+        <command name="vkCmdDrawIndirectCountAMD"                              alias="vkCmdDrawIndirectCount"/>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawIndexedIndirectCount</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkBuffer</type> <name>countBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command name="vkCmdDrawIndexedIndirectCountKHR"                       alias="vkCmdDrawIndexedIndirectCount"/>
+        <command name="vkCmdDrawIndexedIndirectCountAMD"                       alias="vkCmdDrawIndexedIndirectCount"/>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetCheckpointNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param noautovalidity="true">const <type>void</type>* <name>pCheckpointMarker</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetQueueCheckpointDataNV</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCheckpointDataCount</name></param>
+            <param optional="true" len="pCheckpointDataCount"><type>VkCheckpointDataNV</type>* <name>pCheckpointData</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindTransformFeedbackBuffersEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstBinding</name></param>
+            <param><type>uint32_t</type> <name>bindingCount</name></param>
+            <param len="bindingCount">const <type>VkBuffer</type>* <name>pBuffers</name></param>
+            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
+            <param optional="true" len="bindingCount" noautovalidity="true">const <type>VkDeviceSize</type>* <name>pSizes</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBeginTransformFeedbackEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
+            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
+            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdEndTransformFeedbackEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstCounterBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>counterBufferCount</name></param>
+            <param noautovalidity="true" len="counterBufferCount">const <type>VkBuffer</type>* <name>pCounterBuffers</name></param>
+            <param optional="true" len="counterBufferCount">const <type>VkDeviceSize</type>* <name>pCounterBufferOffsets</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBeginQueryIndexedEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+            <param optional="true"><type>VkQueryControlFlags</type> <name>flags</name></param>
+            <param><type>uint32_t</type> <name>index</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdEndQueryIndexedEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>query</name></param>
+            <param><type>uint32_t</type> <name>index</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawIndirectByteCountEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>instanceCount</name></param>
+            <param><type>uint32_t</type> <name>firstInstance</name></param>
+            <param><type>VkBuffer</type> <name>counterBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>counterBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>counterOffset</name></param>
+            <param><type>uint32_t</type> <name>vertexStride</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetExclusiveScissorNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstExclusiveScissor</name></param>
+            <param><type>uint32_t</type> <name>exclusiveScissorCount</name></param>
+            <param len="exclusiveScissorCount">const <type>VkRect2D</type>* <name>pExclusiveScissors</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindShadingRateImageNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkImageView</type> <name>imageView</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetViewportShadingRatePaletteNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstViewport</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkShadingRatePaletteNV</type>* <name>pShadingRatePalettes</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetCoarseSampleOrderNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkCoarseSampleOrderTypeNV</type> <name>sampleOrderType</name></param>
+            <param optional="true"><type>uint32_t</type> <name>customSampleOrderCount</name></param>
+            <param len="customSampleOrderCount">const <type>VkCoarseSampleOrderCustomNV</type>* <name>pCustomSampleOrders</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>taskCount</name></param>
+            <param><type>uint32_t</type> <name>firstTask</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>uint32_t</type> <name>drawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdDrawMeshTasksIndirectCountNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>buffer</name></param>
+            <param><type>VkDeviceSize</type> <name>offset</name></param>
+            <param><type>VkBuffer</type> <name>countBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>countBufferOffset</name></param>
+            <param><type>uint32_t</type> <name>maxDrawCount</name></param>
+            <param><type>uint32_t</type> <name>stride</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCompileDeferredNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>shader</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateAccelerationStructureNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureCreateInfoNV</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkAccelerationStructureNV</type>* <name>pAccelerationStructure</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindInvocationMaskHUAWEI</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkImageView</type> <name>imageView</name></param>
+            <param><type>VkImageLayout</type> <name>imageLayout</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkAccelerationStructureKHR</type> <name>accelerationStructure</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyAccelerationStructureNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetAccelerationStructureMemoryRequirementsNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureMemoryRequirementsInfoNV</type>* <name>pInfo</name></param>
+            <param><type>VkMemoryRequirements2KHR</type>* <name>pMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBindAccelerationStructureMemoryNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>bindInfoCount</name></param>
+            <param len="bindInfoCount">const <type>VkBindAccelerationStructureMemoryInfoNV</type>* <name>pBindInfos</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>src</name></param>
+            <param><type>VkCopyAccelerationStructureModeKHR</type> <name>mode</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyAccelerationStructureToMemoryKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyAccelerationStructureToMemoryInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyAccelerationStructureToMemoryKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyAccelerationStructureToMemoryInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyMemoryToAccelerationStructureKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyMemoryToAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCopyMemoryToAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param>const <type>VkCopyMemoryToAccelerationStructureInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWriteAccelerationStructuresPropertiesKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
+            <param len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></param>
+            <param><type>VkQueryType</type> <name>queryType</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWriteAccelerationStructuresPropertiesNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
+            <param len="accelerationStructureCount">const <type>VkAccelerationStructureNV</type>* <name>pAccelerationStructures</name></param>
+            <param><type>VkQueryType</type> <name>queryType</name></param>
+            <param><type>VkQueryPool</type> <name>queryPool</name></param>
+            <param><type>uint32_t</type> <name>firstQuery</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBuildAccelerationStructureNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkAccelerationStructureInfoNV</type>* <name>pInfo</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>instanceData</name></param>
+            <param><type>VkDeviceSize</type> <name>instanceOffset</name></param>
+            <param><type>VkBool32</type> <name>update</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>dst</name></param>
+            <param optional="true"><type>VkAccelerationStructureNV</type> <name>src</name></param>
+            <param><type>VkBuffer</type> <name>scratch</name></param>
+            <param><type>VkDeviceSize</type> <name>scratchOffset</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkWriteAccelerationStructuresPropertiesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>uint32_t</type> <name>accelerationStructureCount</name></param>
+            <param len="accelerationStructureCount">const <type>VkAccelerationStructureKHR</type>* <name>pAccelerationStructures</name></param>
+            <param><type>VkQueryType</type>  <name>queryType</name></param>
+            <param><type>size_t</type>       <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+            <param><type>size_t</type> <name>stride</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdTraceRaysKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pRaygenShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pMissShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pHitShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pCallableShaderBindingTable</name></param>
+            <param><type>uint32_t</type> <name>width</name></param>
+            <param><type>uint32_t</type> <name>height</name></param>
+            <param><type>uint32_t</type> <name>depth</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdTraceRaysNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBuffer</type> <name>raygenShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>raygenShaderBindingOffset</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>missShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>missShaderBindingOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>missShaderBindingStride</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>hitShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>hitShaderBindingOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>hitShaderBindingStride</name></param>
+            <param optional="true"><type>VkBuffer</type> <name>callableShaderBindingTableBuffer</name></param>
+            <param><type>VkDeviceSize</type> <name>callableShaderBindingOffset</name></param>
+            <param><type>VkDeviceSize</type> <name>callableShaderBindingStride</name></param>
+            <param><type>uint32_t</type> <name>width</name></param>
+            <param><type>uint32_t</type> <name>height</name></param>
+            <param><type>uint32_t</type> <name>depth</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetRayTracingShaderGroupHandlesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>firstGroup</name></param>
+            <param><type>uint32_t</type> <name>groupCount</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command name="vkGetRayTracingShaderGroupHandlesNV"                 alias="vkGetRayTracingShaderGroupHandlesKHR"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetRayTracingCaptureReplayShaderGroupHandlesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>firstGroup</name></param>
+            <param><type>uint32_t</type> <name>groupCount</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetAccelerationStructureHandleNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkAccelerationStructureNV</type> <name>accelerationStructure</name></param>
+            <param><type>size_t</type> <name>dataSize</name></param>
+            <param len="dataSize"><type>void</type>* <name>pData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_SHADER_NV">
+            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesNV</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoNV</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR,VK_PIPELINE_COMPILE_REQUIRED_EXT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS">
+            <proto><type>VkResult</type> <name>vkCreateRayTracingPipelinesKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param optional="true"><type>VkPipelineCache</type> <name>pipelineCache</name></param>
+            <param><type>uint32_t</type> <name>createInfoCount</name></param>
+            <param len="createInfoCount">const <type>VkRayTracingPipelineCreateInfoKHR</type>* <name>pCreateInfos</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param len="createInfoCount"><type>VkPipeline</type>* <name>pPipelines</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceCooperativeMatrixPropertiesNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPropertyCount</name></param>
+            <param optional="true" len="pPropertyCount"><type>VkCooperativeMatrixPropertiesNV</type>* <name>pProperties</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdTraceRaysIndirectKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pRaygenShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pMissShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pHitShaderBindingTable</name></param>
+            <param>const <type>VkStridedDeviceAddressRegionKHR</type>* <name>pCallableShaderBindingTable</name></param>
+            <param><type>VkDeviceAddress</type> <name>indirectDeviceAddress</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetDeviceAccelerationStructureCompatibilityKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureVersionInfoKHR</type>* <name>pVersionInfo</name></param>
+            <param><type>VkAccelerationStructureCompatibilityKHR</type>* <name>pCompatibility</name></param>
+        </command>
+        <command>
+            <proto><type>VkDeviceSize</type> <name>vkGetRayTracingShaderGroupStackSizeKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPipeline</type> <name>pipeline</name></param>
+            <param><type>uint32_t</type> <name>group</name></param>
+            <param><type>VkShaderGroupShaderKHR</type> <name>groupShader</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetRayTracingPipelineStackSizeKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>pipelineStackSize</name></param>
+        </command>
+        <command>
+            <proto><type>uint32_t</type> <name>vkGetImageViewHandleNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkImageViewHandleInfoNVX</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>vkGetImageViewAddressNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImageView</type> <name>imageView</name></param>
+            <param><type>VkImageViewAddressPropertiesNVX</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSurfacePresentModes2EXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pPresentModeCount</name></param>
+            <param optional="true" len="pPresentModeCount"><type>VkPresentModeKHR</type>* <name>pPresentModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkGetDeviceGroupSurfacePresentModes2EXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPhysicalDeviceSurfaceInfo2KHR</type>* <name>pSurfaceInfo</name></param>
+            <param optional="false,true"><type>VkDeviceGroupPresentModeFlagsKHR</type>* <name>pModes</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkAcquireFullScreenExclusiveModeEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_SURFACE_LOST_KHR">
+            <proto><type>VkResult</type> <name>vkReleaseFullScreenExclusiveModeEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>uint32_t</type> <name>queueFamilyIndex</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCounterCount</name></param>
+            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterKHR</type>* <name>pCounters</name></param>
+            <param optional="true" len="pCounterCount"><type>VkPerformanceCounterDescriptionKHR</type>* <name>pCounterDescriptions</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkQueryPoolPerformanceCreateInfoKHR</type>* <name>pPerformanceQueryCreateInfo</name></param>
+            <param><type>uint32_t</type>* <name>pNumPasses</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_TIMEOUT">
+            <proto><type>VkResult</type> <name>vkAcquireProfilingLockKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAcquireProfilingLockInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkReleaseProfilingLockKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetImageDrmFormatModifierPropertiesEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkImage</type> <name>image</name></param>
+            <param><type>VkImageDrmFormatModifierPropertiesEXT</type>* <name>pProperties</name></param>
+        </command>
+        <command>
+            <proto><type>uint64_t</type> <name>vkGetBufferOpaqueCaptureAddress</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferDeviceAddressInfo</type>* <name>pInfo</name></param>
+        </command>
+        <command name="vkGetBufferOpaqueCaptureAddressKHR" alias="vkGetBufferOpaqueCaptureAddress"/>
+        <command>
+            <proto><type>VkDeviceAddress</type> <name>vkGetBufferDeviceAddress</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferDeviceAddressInfo</type>* <name>pInfo</name></param>
+        </command>
+        <command name="vkGetBufferDeviceAddressKHR"        alias="vkGetBufferDeviceAddress"/>
+        <command name="vkGetBufferDeviceAddressEXT"        alias="vkGetBufferDeviceAddress"/>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateHeadlessSurfaceEXT</name></proto>
+            <param><type>VkInstance</type> <name>instance</name></param>
+            <param>const <type>VkHeadlessSurfaceCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkSurfaceKHR</type>* <name>pSurface</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCombinationCount</name></param>
+            <param optional="true" len="pCombinationCount"><type>VkFramebufferMixedSamplesCombinationNV</type>* <name>pCombinations</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkInitializePerformanceApiINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkInitializePerformanceApiInfoINTEL</type>* <name>pInitializeInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkUninitializePerformanceApiINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+        </command>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCmdSetPerformanceMarkerINTEL</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkPerformanceMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCmdSetPerformanceStreamMarkerINTEL</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkPerformanceStreamMarkerInfoINTEL</type>* <name>pMarkerInfo</name></param>
+        </command>
+        <command queues="graphics,compute,transfer" renderpass="both" cmdbufferlevel="primary,secondary" successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCmdSetPerformanceOverrideINTEL</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkPerformanceOverrideInfoINTEL</type>* <name>pOverrideInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkAcquirePerformanceConfigurationINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPerformanceConfigurationAcquireInfoINTEL</type>* <name>pAcquireInfo</name></param>
+            <param><type>VkPerformanceConfigurationINTEL</type>* <name>pConfiguration</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkReleasePerformanceConfigurationINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkQueueSetPerformanceConfigurationINTEL</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param><type>VkPerformanceConfigurationINTEL</type> <name>configuration</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_TOO_MANY_OBJECTS,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPerformanceParameterINTEL</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkPerformanceParameterTypeINTEL</type> <name>parameter</name></param>
+            <param><type>VkPerformanceValueINTEL</type>* <name>pValue</name></param>
+        </command>
+        <command>
+            <proto><type>uint64_t</type> <name>vkGetDeviceMemoryOpaqueCaptureAddress</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkDeviceMemoryOpaqueCaptureAddressInfo</type>* <name>pInfo</name></param>
+        </command>
+        <command name="vkGetDeviceMemoryOpaqueCaptureAddressKHR"        alias="vkGetDeviceMemoryOpaqueCaptureAddress"/>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineExecutablePropertiesKHR</name></proto>
+            <param><type>VkDevice</type>                        <name>device</name></param>
+            <param>const <type>VkPipelineInfoKHR</type>*        <name>pPipelineInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pExecutableCount</name></param>
+            <param optional="true" len="pExecutableCount"><type>VkPipelineExecutablePropertiesKHR</type>* <name>pProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineExecutableStatisticsKHR</name></proto>
+            <param><type>VkDevice</type>                        <name>device</name></param>
+            <param>const <type>VkPipelineExecutableInfoKHR</type>*  <name>pExecutableInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pStatisticCount</name></param>
+            <param optional="true" len="pStatisticCount"><type>VkPipelineExecutableStatisticKHR</type>* <name>pStatistics</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPipelineExecutableInternalRepresentationsKHR</name></proto>
+            <param><type>VkDevice</type>                        <name>device</name></param>
+            <param>const <type>VkPipelineExecutableInfoKHR</type>*  <name>pExecutableInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pInternalRepresentationCount</name></param>
+            <param optional="true" len="pInternalRepresentationCount"><type>VkPipelineExecutableInternalRepresentationKHR</type>* <name>pInternalRepresentations</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetLineStippleEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>lineStippleFactor</name></param>
+            <param><type>uint16_t</type> <name>lineStipplePattern</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceToolPropertiesEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pToolCount</name></param>
+            <param optional="true" len="pToolCount"><type>VkPhysicalDeviceToolPropertiesEXT</type>* <name>pToolProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR">
+            <proto><type>VkResult</type> <name>vkCreateAccelerationStructureKHR</name></proto>
+            <param><type>VkDevice</type>                                           <name>device</name></param>
+            <param>const <type>VkAccelerationStructureCreateInfoKHR</type>*        <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>*       <name>pAllocator</name></param>
+            <param><type>VkAccelerationStructureKHR</type>*                        <name>pAccelerationStructure</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBuildAccelerationStructuresKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                                    <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildRangeInfoKHR</type>* const* <name>ppBuildRangeInfos</name></param>
+        </command>
+        <command queues="compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBuildAccelerationStructuresIndirectKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                  <name>commandBuffer</name></param>
+            <param><type>uint32_t</type>                                           <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
+            <param len="infoCount">const <type>VkDeviceAddress</type>*             <name>pIndirectDeviceAddresses</name></param>
+            <param len="infoCount">const <type>uint32_t</type>*                    <name>pIndirectStrides</name></param>
+            <param len="infoCount">const <type>uint32_t</type>* const*             <name>ppMaxPrimitiveCounts</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_OPERATION_DEFERRED_KHR,VK_OPERATION_NOT_DEFERRED_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkBuildAccelerationStructuresKHR</name></proto>
+            <param><type>VkDevice</type>                                           <name>device</name></param>
+            <param optional="true"><type>VkDeferredOperationKHR</type> <name>deferredOperation</name></param>
+            <param><type>uint32_t</type> <name>infoCount</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>* <name>pInfos</name></param>
+            <param len="infoCount">const <type>VkAccelerationStructureBuildRangeInfoKHR</type>* const* <name>ppBuildRangeInfos</name></param>
+        </command>
+        <command>
+            <proto><type>VkDeviceAddress</type> <name>vkGetAccelerationStructureDeviceAddressKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkAccelerationStructureDeviceAddressInfoKHR</type>* <name>pInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreateDeferredOperationKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkDeferredOperationKHR</type>* <name>pDeferredOperation</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyDeferredOperationKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>uint32_t</type> <name>vkGetDeferredOperationMaxConcurrencyKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_NOT_READY">
+            <proto><type>VkResult</type> <name>vkGetDeferredOperationResultKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_THREAD_DONE_KHR,VK_THREAD_IDLE_KHR" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY">
+            <proto><type>VkResult</type> <name>vkDeferredOperationJoinKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeferredOperationKHR</type> <name>operation</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetCullModeEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>VkCullModeFlags</type> <name>cullMode</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetFrontFaceEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkFrontFace</type> <name>frontFace</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetPrimitiveTopologyEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkPrimitiveTopology</type> <name>primitiveTopology</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetViewportWithCountEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>viewportCount</name></param>
+            <param len="viewportCount">const <type>VkViewport</type>* <name>pViewports</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetScissorWithCountEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>scissorCount</name></param>
+            <param len="scissorCount">const <type>VkRect2D</type>* <name>pScissors</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBindVertexBuffers2EXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>firstBinding</name></param>
+            <param><type>uint32_t</type> <name>bindingCount</name></param>
+            <param len="bindingCount" optional="false,true">const <type>VkBuffer</type>* <name>pBuffers</name></param>
+            <param len="bindingCount">const <type>VkDeviceSize</type>* <name>pOffsets</name></param>
+            <param optional="true" len="bindingCount">const <type>VkDeviceSize</type>* <name>pSizes</name></param>
+            <param optional="true" len="bindingCount">const <type>VkDeviceSize</type>* <name>pStrides</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDepthTestEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthTestEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDepthWriteEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthWriteEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDepthCompareOpEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkCompareOp</type> <name>depthCompareOp</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDepthBoundsTestEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthBoundsTestEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetStencilTestEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>stencilTestEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetStencilOpEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkStencilFaceFlags</type> <name>faceMask</name></param>
+            <param><type>VkStencilOp</type> <name>failOp</name></param>
+            <param><type>VkStencilOp</type> <name>passOp</name></param>
+            <param><type>VkStencilOp</type> <name>depthFailOp</name></param>
+            <param><type>VkCompareOp</type> <name>compareOp</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetPatchControlPointsEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>uint32_t</type> <name>patchControlPoints</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetRasterizerDiscardEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>rasterizerDiscardEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetDepthBiasEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>depthBiasEnable</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetLogicOpEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkLogicOp</type> <name>logicOp</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetPrimitiveRestartEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param><type>VkBool32</type> <name>primitiveRestartEnable</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkCreatePrivateDataSlotEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkPrivateDataSlotCreateInfoEXT</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkPrivateDataSlotEXT</type>* <name>pPrivateDataSlot</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyPrivateDataSlotEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param optional="true" externsync="true"><type>VkPrivateDataSlotEXT</type> <name>privateDataSlot</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkSetPrivateDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkObjectType</type> <name>objectType</name></param>
+            <param objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></param>
+            <param><type>VkPrivateDataSlotEXT</type> <name>privateDataSlot</name></param>
+            <param><type>uint64_t</type> <name>data</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetPrivateDataEXT</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkObjectType</type> <name>objectType</name></param>
+            <param objecttype="objectType"><type>uint64_t</type> <name>objectHandle</name></param>
+            <param><type>VkPrivateDataSlotEXT</type> <name>privateDataSlot</name></param>
+            <param><type>uint64_t</type>* <name>pData</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyBuffer2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyBufferInfo2KHR</type>* <name>pCopyBufferInfo</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyImage2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyImageInfo2KHR</type>* <name>pCopyImageInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBlitImage2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkBlitImageInfo2KHR</type>* <name>pBlitImageInfo</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyBufferToImage2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyBufferToImageInfo2KHR</type>* <name>pCopyBufferToImageInfo</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCopyImageToBuffer2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCopyImageToBufferInfo2KHR</type>* <name>pCopyImageToBufferInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdResolveImage2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkResolveImageInfo2KHR</type>* <name>pResolveImageInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetFragmentShadingRateKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>           <name>commandBuffer</name></param>
+            <param>const <type>VkExtent2D</type>*                           <name>pFragmentSize</name></param>
+            <param>const <type>VkFragmentShadingRateCombinerOpKHR</type>    <name>combinerOps</name>[2]</param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceFragmentShadingRatesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pFragmentShadingRateCount</name></param>
+            <param optional="true" len="pFragmentShadingRateCount"><type>VkPhysicalDeviceFragmentShadingRateKHR</type>* <name>pFragmentShadingRates</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetFragmentShadingRateEnumNV</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>           <name>commandBuffer</name></param>
+            <param><type>VkFragmentShadingRateNV</type>                     <name>shadingRate</name></param>
+            <param>const <type>VkFragmentShadingRateCombinerOpKHR</type>    <name>combinerOps</name>[2]</param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetAccelerationStructureBuildSizesKHR</name></proto>
+            <param><type>VkDevice</type>                                            <name>device</name></param>
+            <param><type>VkAccelerationStructureBuildTypeKHR</type>                 <name>buildType</name></param>
+            <param>const <type>VkAccelerationStructureBuildGeometryInfoKHR</type>*  <name>pBuildInfo</name></param>
+            <param optional="true" len="pBuildInfo-&gt;geometryCount">const <type>uint32_t</type>*  <name>pMaxPrimitiveCounts</name></param>
+            <param><type>VkAccelerationStructureBuildSizesInfoKHR</type>*           <name>pSizeInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetVertexInputEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param optional="true"><type>uint32_t</type> <name>vertexBindingDescriptionCount</name></param>
+            <param len="vertexBindingDescriptionCount">const <type>VkVertexInputBindingDescription2EXT</type>* <name>pVertexBindingDescriptions</name></param>
+            <param optional="true"><type>uint32_t</type> <name>vertexAttributeDescriptionCount</name></param>
+            <param len="vertexAttributeDescriptionCount">const <type>VkVertexInputAttributeDescription2EXT</type>* <name>pVertexAttributeDescriptions</name></param>
+        </command>
+        <command queues="graphics" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type>                                    <name>vkCmdSetColorWriteEnableEXT</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>       <name>commandBuffer</name></param>
+            <param><type>uint32_t</type>                                <name>attachmentCount</name></param>
+            <param len="attachmentCount">const <type>VkBool32</type>*   <name>pColorWriteEnables</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdSetEvent2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>VkEvent</type>                                             <name>event</name></param>
+            <param>const <type>VkDependencyInfoKHR</type>*                          <name>pDependencyInfo</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdResetEvent2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>VkEvent</type>                                             <name>event</name></param>
+            <param><type>VkPipelineStageFlags2KHR</type>                            <name>stageMask</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWaitEvents2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>uint32_t</type>                                            <name>eventCount</name></param>
+            <param len="eventCount">const <type>VkEvent</type>*                     <name>pEvents</name></param>
+            <param len="eventCount">const <type>VkDependencyInfoKHR</type>*         <name>pDependencyInfos</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdPipelineBarrier2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param>const <type>VkDependencyInfoKHR</type>*                                <name>pDependencyInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkQueueSubmit2KHR</name></proto>
+            <param externsync="true"><type>VkQueue</type>                           <name>queue</name></param>
+            <param optional="true"><type>uint32_t</type>                            <name>submitCount</name></param>
+            <param len="submitCount">const <type>VkSubmitInfo2KHR</type>*           <name>pSubmits</name></param>
+            <param optional="true" externsync="true"><type>VkFence</type>           <name>fence</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWriteTimestamp2KHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>VkPipelineStageFlags2KHR</type>                            <name>stage</name></param>
+            <param><type>VkQueryPool</type>                                         <name>queryPool</name></param>
+            <param><type>uint32_t</type>                                            <name>query</name></param>
+        </command>
+        <command queues="transfer,graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdWriteBufferMarker2AMD</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param><type>VkPipelineStageFlags2KHR</type>                            <name>stage</name></param>
+            <param><type>VkBuffer</type>                                            <name>dstBuffer</name></param>
+            <param><type>VkDeviceSize</type>                                        <name>dstOffset</name></param>
+            <param><type>uint32_t</type>                                            <name>marker</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkGetQueueCheckpointData2NV</name></proto>
+            <param><type>VkQueue</type> <name>queue</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pCheckpointDataCount</name></param>
+            <param optional="true" len="pCheckpointDataCount"><type>VkCheckpointData2NV</type>* <name>pCheckpointData</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_FEATURE_NOT_PRESENT,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoCapabilitiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkVideoProfileKHR</type>* <name>pVideoProfile</name></param>
+            <param><type>VkVideoCapabilitiesKHR</type>* <name>pCapabilities</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_EXTENSION_NOT_PRESENT,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkGetPhysicalDeviceVideoFormatPropertiesKHR</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param>const <type>VkPhysicalDeviceVideoFormatInfoKHR</type>* <name>pVideoFormatInfo</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pVideoFormatPropertyCount</name></param>
+            <param optional="true" len="pVideoFormatPropertyCount"><type>VkVideoFormatPropertiesKHR</type>* <name>pVideoFormatProperties</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_INCOMPATIBLE_DRIVER,VK_ERROR_FEATURE_NOT_PRESENT">
+            <proto><type>VkResult</type> <name>vkCreateVideoSessionKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkVideoSessionCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkVideoSessionKHR</type>* <name>pVideoSession</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyVideoSessionKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_TOO_MANY_OBJECTS">
+            <proto><type>VkResult</type> <name>vkCreateVideoSessionParametersKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkVideoSessionParametersCreateInfoKHR</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkVideoSessionParametersKHR</type>* <name>pVideoSessionParameters</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_TOO_MANY_OBJECTS">
+            <proto><type>VkResult</type> <name>vkUpdateVideoSessionParametersKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkVideoSessionParametersKHR</type> <name>videoSessionParameters</name></param>
+            <param>const <type>VkVideoSessionParametersUpdateInfoKHR</type>* <name>pUpdateInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyVideoSessionParametersKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkVideoSessionParametersKHR</type> <name>videoSessionParameters</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_INCOMPLETE" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetVideoSessionMemoryRequirementsKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
+            <param optional="false,true"><type>uint32_t</type>* <name>pVideoSessionMemoryRequirementsCount</name></param>
+            <param optional="true" len="pVideoSessionMemoryRequirementsCount"><type>VkVideoGetMemoryPropertiesKHR</type>* <name>pVideoSessionMemoryRequirements</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkBindVideoSessionMemoryKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkVideoSessionKHR</type> <name>videoSession</name></param>
+            <param><type>uint32_t</type> <name>videoSessionBindMemoryCount</name></param>
+            <param len="videoSessionBindMemoryCount">const <type>VkVideoBindMemoryKHR</type>* <name>pVideoSessionBindMemories</name></param>
+        </command>
+        <command queues="decode" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdDecodeVideoKHR</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoDecodeInfoKHR</type>* <name>pFrameInfo</name></param>
+        </command>
+        <command queues="decode,encode" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdBeginVideoCodingKHR</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoBeginCodingInfoKHR</type>* <name>pBeginInfo</name></param>
+        </command>
+        <command queues="decode,encode" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdControlVideoCodingKHR</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoCodingControlInfoKHR</type>* <name>pCodingControlInfo</name></param>
+        </command>
+        <command queues="decode,encode" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdEndVideoCodingKHR</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoEndCodingInfoKHR</type>* <name>pEndCodingInfo</name></param>
+        </command>
+        <command queues="encode" renderpass="outside" cmdbufferlevel="primary">
+            <proto><type>void</type> <name>vkCmdEncodeVideoKHR</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkVideoEncodeInfoKHR</type>* <name>pEncodeInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateCuModuleNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCuModuleCreateInfoNVX</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCuModuleNVX</type>* <name>pModule</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateCuFunctionNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkCuFunctionCreateInfoNVX</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkCuFunctionNVX</type>* <name>pFunction</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCuModuleNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkCuModuleNVX</type> <name>module</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyCuFunctionNVX</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkCuFunctionNVX</type> <name>function</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command queues="graphics,compute" renderpass="both" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdCuLaunchKernelNVX</name></proto>
+            <param><type>VkCommandBuffer</type> <name>commandBuffer</name></param>
+            <param>const <type>VkCuLaunchInfoNVX</type>* <name>pLaunchInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkSetDeviceMemoryPriorityEXT</name></proto>
+            <param><type>VkDevice</type>       <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>float</type>          <name>priority</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkAcquireDrmDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>int32_t</type> <name>drmFd</name></param>
+            <param><type>VkDisplayKHR</type> <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY">
+            <proto><type>VkResult</type> <name>vkGetDrmDisplayEXT</name></proto>
+            <param><type>VkPhysicalDevice</type> <name>physicalDevice</name></param>
+            <param><type>int32_t</type> <name>drmFd</name></param>
+            <param><type>uint32_t</type> <name>connectorId</name></param>
+            <param><type>VkDisplayKHR</type>* <name>display</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_OUT_OF_DEVICE_MEMORY,VK_ERROR_DEVICE_LOST">
+            <proto><type>VkResult</type> <name>vkWaitForPresentKHR</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param externsync="true"><type>VkSwapchainKHR</type> <name>swapchain</name></param>
+            <param><type>uint64_t</type> <name>presentId</name></param>
+            <param><type>uint64_t</type> <name>timeout</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INVALID_EXTERNAL_HANDLE,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkCreateBufferCollectionFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param>const <type>VkBufferCollectionCreateInfoFUCHSIA</type>* <name>pCreateInfo</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type>* <name>pCollection</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkSetBufferCollectionBufferConstraintsFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param>const <type>VkBufferConstraintsInfoFUCHSIA</type>* <name>pBufferConstraintsInfo</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_INITIALIZATION_FAILED,VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_FORMAT_NOT_SUPPORTED">
+            <proto><type>VkResult</type> <name>vkSetBufferCollectionImageConstraintsFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param>const <type>VkImageConstraintsInfoFUCHSIA</type>* <name>pImageConstraintsInfo</name></param>
+        </command>
+        <command>
+            <proto><type>void</type> <name>vkDestroyBufferCollectionFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param optional="true">const <type>VkAllocationCallbacks</type>* <name>pAllocator</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_OUT_OF_HOST_MEMORY,VK_ERROR_INITIALIZATION_FAILED">
+            <proto><type>VkResult</type> <name>vkGetBufferCollectionPropertiesFUCHSIA</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkBufferCollectionFUCHSIA</type> <name>collection</name></param>
+            <param><type>VkBufferCollectionPropertiesFUCHSIA</type>* <name>pProperties</name></param>
+        </command>
+        <command queues="graphics" renderpass="outside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdBeginRenderingKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+            <param>const <type>VkRenderingInfoKHR</type>*                           <name>pRenderingInfo</name></param>
+        </command>
+        <command queues="graphics" renderpass="inside" cmdbufferlevel="primary,secondary">
+            <proto><type>void</type> <name>vkCmdEndRenderingKHR</name></proto>
+            <param externsync="true"><type>VkCommandBuffer</type>                   <name>commandBuffer</name></param>
+        </command>
+    </commands>
+
+    <feature api="vulkan" name="VK_VERSION_1_0" number="1.0" comment="Vulkan core API interface definitions">
+        <require comment="Header boilerplate">
+            <type name="vk_platform"/>
+            <type name="VK_DEFINE_HANDLE"/>
+            <type name="VK_USE_64_BIT_PTR_DEFINES"/>
+            <type name="VK_DEFINE_NON_DISPATCHABLE_HANDLE"/>
+            <type name="VK_NULL_HANDLE"/>
+        </require>
+        <require comment="Fundamental types used by many commands and structures">
+            <type name="VkBool32"/>
+            <type name="VkDeviceAddress"/>
+            <type name="VkDeviceSize"/>
+            <type name="VkExtent2D"/>
+            <type name="VkExtent3D"/>
+            <type name="VkFlags"/>
+            <type name="VkOffset2D"/>
+            <type name="VkOffset3D"/>
+            <type name="VkRect2D"/>
+            <type name="VkResult"/>
+            <type name="VkStructureType"/>
+        </require>
+        <require comment="These types are part of the API, though not directly used in API commands or data structures">
+            <type name="VkBaseInStructure"/>
+            <type name="VkBaseOutStructure"/>
+            <type name="VkBufferMemoryBarrier"/>
+            <type name="VkDispatchIndirectCommand"/>
+            <type name="VkDrawIndexedIndirectCommand"/>
+            <type name="VkDrawIndirectCommand"/>
+            <type name="VkImageMemoryBarrier"/>
+            <type name="VkMemoryBarrier"/>
+            <type name="VkObjectType"/>
+            <type name="VkPipelineCacheHeaderVersionOne"/>
+            <type name="VkVendorId"/>
+        </require>
+        <require comment="API version macros">
+            <type name="VK_API_VERSION"/>
+            <type name="VK_API_VERSION_1_0"/>
+            <type name="VK_HEADER_VERSION"/>
+            <type name="VK_HEADER_VERSION_COMPLETE"/>
+            <type name="VK_MAKE_VERSION"/>
+            <type name="VK_VERSION_MAJOR"/>
+            <type name="VK_VERSION_MINOR"/>
+            <type name="VK_VERSION_PATCH"/>
+            <type name="VK_MAKE_API_VERSION"/>
+            <type name="VK_API_VERSION_VARIANT"/>
+            <type name="VK_API_VERSION_MAJOR"/>
+            <type name="VK_API_VERSION_MINOR"/>
+            <type name="VK_API_VERSION_PATCH"/>
+        </require>
+        <require comment="API constants">
+            <enum name="VK_ATTACHMENT_UNUSED"/>
+            <enum name="VK_FALSE"/>
+            <enum name="VK_LOD_CLAMP_NONE"/>
+            <enum name="VK_QUEUE_FAMILY_IGNORED"/>
+            <enum name="VK_REMAINING_ARRAY_LAYERS"/>
+            <enum name="VK_REMAINING_MIP_LEVELS"/>
+            <enum name="VK_SUBPASS_EXTERNAL"/>
+            <enum name="VK_TRUE"/>
+            <enum name="VK_WHOLE_SIZE"/>
+            <type name="VkPipelineCacheHeaderVersion"/>
+        </require>
+        <require comment="Device initialization">
+            <type name="PFN_vkAllocationFunction"/>
+            <type name="PFN_vkFreeFunction"/>
+            <type name="PFN_vkInternalAllocationNotification"/>
+            <type name="PFN_vkInternalFreeNotification"/>
+            <type name="PFN_vkReallocationFunction"/>
+            <type name="PFN_vkVoidFunction"/>
+            <type name="VkAllocationCallbacks"/>
+            <type name="VkApplicationInfo"/>
+            <type name="VkFormat"/>
+            <type name="VkFormatFeatureFlagBits"/>
+            <type name="VkFormatFeatureFlags"/>
+            <type name="VkFormatProperties"/>
+            <type name="VkImageCreateFlagBits"/>
+            <type name="VkImageCreateFlags"/>
+            <type name="VkImageFormatProperties"/>
+            <type name="VkImageTiling"/>
+            <type name="VkImageType"/>
+            <type name="VkImageUsageFlagBits"/>
+            <type name="VkImageUsageFlags"/>
+            <type name="VkInstance"/>
+            <type name="VkInstanceCreateFlags" comment="Will add VkInstanceCreateFlagBits when bits are defined in the future"/>
+            <type name="VkInstanceCreateInfo"/>
+            <type name="VkInternalAllocationType"/>
+            <type name="VkMemoryHeap"/>
+            <type name="VkMemoryHeapFlagBits"/>
+            <type name="VkMemoryHeapFlags"/>
+            <type name="VkMemoryPropertyFlagBits"/>
+            <type name="VkMemoryPropertyFlags"/>
+            <type name="VkMemoryType"/>
+            <type name="VkPhysicalDevice"/>
+            <type name="VkPhysicalDeviceFeatures"/>
+            <type name="VkPhysicalDeviceLimits"/>
+            <type name="VkPhysicalDeviceMemoryProperties"/>
+            <type name="VkPhysicalDeviceProperties"/>
+            <type name="VkPhysicalDeviceSparseProperties"/>
+            <type name="VkPhysicalDeviceType"/>
+            <type name="VkQueueFamilyProperties"/>
+            <type name="VkQueueFlagBits"/>
+            <type name="VkQueueFlags"/>
+            <type name="VkSampleCountFlagBits"/>
+            <type name="VkSampleCountFlags"/>
+            <type name="VkSystemAllocationScope"/>
+            <command name="vkCreateInstance"/>
+            <command name="vkDestroyInstance"/>
+            <command name="vkEnumeratePhysicalDevices"/>
+            <command name="vkGetPhysicalDeviceFeatures"/>
+            <command name="vkGetPhysicalDeviceFormatProperties"/>
+            <command name="vkGetPhysicalDeviceImageFormatProperties"/>
+            <command name="vkGetPhysicalDeviceProperties"/>
+            <command name="vkGetPhysicalDeviceQueueFamilyProperties"/>
+            <command name="vkGetPhysicalDeviceMemoryProperties"/>
+            <command name="vkGetInstanceProcAddr"/>
+            <command name="vkGetDeviceProcAddr"/>
+        </require>
+        <require comment="Device commands">
+            <type name="VkDevice"/>
+            <type name="VkDeviceCreateFlags" comment="Will add VkDeviceCreateFlagBits when bits are defined in the future"/>
+            <type name="VkDeviceCreateInfo"/>
+            <type name="VkDeviceQueueCreateFlags" comment="VkDeviceQueueCreateFlagBits was added later"/>
+            <type name="VkDeviceQueueCreateInfo"/>
+            <command name="vkCreateDevice"/>
+            <command name="vkDestroyDevice"/>
+        </require>
+        <require comment="Extension discovery commands">
+            <type name="VkExtensionProperties"/>
+            <command name="vkEnumerateInstanceExtensionProperties"/>
+            <command name="vkEnumerateDeviceExtensionProperties"/>
+        </require>
+        <require comment="Layer discovery commands">
+            <type name="VkLayerProperties"/>
+            <command name="vkEnumerateInstanceLayerProperties"/>
+            <command name="vkEnumerateDeviceLayerProperties"/>
+        </require>
+        <require comment="Queue commands">
+            <type name="VkPipelineStageFlagBits"/>
+            <type name="VkPipelineStageFlags"/>
+            <type name="VkQueue"/>
+            <type name="VkSubmitInfo"/>
+            <command name="vkGetDeviceQueue"/>
+            <command name="vkQueueSubmit"/>
+            <command name="vkQueueWaitIdle"/>
+            <command name="vkDeviceWaitIdle"/>
+        </require>
+        <require comment="Memory commands">
+            <type name="VkMappedMemoryRange"/>
+            <type name="VkMemoryAllocateInfo"/>
+            <type name="VkMemoryMapFlags"/>
+            <command name="vkAllocateMemory"/>
+            <command name="vkFreeMemory"/>
+            <command name="vkMapMemory"/>
+            <command name="vkUnmapMemory"/>
+            <command name="vkFlushMappedMemoryRanges"/>
+            <command name="vkInvalidateMappedMemoryRanges"/>
+            <command name="vkGetDeviceMemoryCommitment"/>
+        </require>
+        <require comment="Memory management API commands">
+            <type name="VkDeviceMemory"/>
+            <type name="VkMemoryRequirements"/>
+            <command name="vkBindBufferMemory"/>
+            <command name="vkBindImageMemory"/>
+            <command name="vkGetBufferMemoryRequirements"/>
+            <command name="vkGetImageMemoryRequirements"/>
+        </require>
+        <require comment="Sparse resource memory management API commands">
+            <type name="VkBindSparseInfo"/>
+            <type name="VkImageAspectFlagBits"/>
+            <type name="VkImageAspectFlags"/>
+            <type name="VkImageSubresource"/>
+            <type name="VkSparseBufferMemoryBindInfo"/>
+            <type name="VkSparseImageFormatFlagBits"/>
+            <type name="VkSparseImageFormatFlags"/>
+            <type name="VkSparseImageFormatProperties"/>
+            <type name="VkSparseImageMemoryBind"/>
+            <type name="VkSparseImageMemoryBindInfo"/>
+            <type name="VkSparseImageMemoryRequirements"/>
+            <type name="VkSparseImageOpaqueMemoryBindInfo"/>
+            <type name="VkSparseMemoryBind"/>
+            <type name="VkSparseMemoryBindFlagBits"/>
+            <type name="VkSparseMemoryBindFlags"/>
+            <command name="vkGetImageSparseMemoryRequirements"/>
+            <command name="vkGetPhysicalDeviceSparseImageFormatProperties"/>
+            <command name="vkQueueBindSparse"/>
+        </require>
+        <require comment="Fence commands">
+            <type name="VkFence"/>
+            <type name="VkFenceCreateFlagBits"/>
+            <type name="VkFenceCreateFlags"/>
+            <type name="VkFenceCreateInfo"/>
+            <command name="vkCreateFence"/>
+            <command name="vkDestroyFence"/>
+            <command name="vkResetFences"/>
+            <command name="vkGetFenceStatus"/>
+            <command name="vkWaitForFences"/>
+        </require>
+        <require comment="Queue semaphore commands">
+            <type name="VkSemaphore"/>
+            <type name="VkSemaphoreCreateFlags" comment="Will add VkSemaphoreCreateFlagBits when bits are defined in the future"/>
+            <type name="VkSemaphoreCreateInfo"/>
+            <command name="vkCreateSemaphore"/>
+            <command name="vkDestroySemaphore"/>
+        </require>
+        <require comment="Event commands">
+            <type name="VkEvent"/>
+            <type name="VkEventCreateFlags"/>
+            <type name="VkEventCreateFlagBits"/>
+            <type name="VkEventCreateInfo"/>
+            <command name="vkCreateEvent"/>
+            <command name="vkDestroyEvent"/>
+            <command name="vkGetEventStatus"/>
+            <command name="vkSetEvent"/>
+            <command name="vkResetEvent"/>
+        </require>
+        <require comment="Query commands">
+            <type name="VkQueryPipelineStatisticFlagBits"/>
+            <type name="VkQueryPipelineStatisticFlags"/>
+            <type name="VkQueryPool"/>
+            <type name="VkQueryPoolCreateFlags" comment="Will add VkQueryPoolCreateFlagBits when bits are defined in the future"/>
+            <type name="VkQueryPoolCreateInfo"/>
+            <type name="VkQueryResultFlagBits"/>
+            <type name="VkQueryResultFlags"/>
+            <type name="VkQueryType"/>
+            <command name="vkCreateQueryPool"/>
+            <command name="vkDestroyQueryPool"/>
+            <command name="vkGetQueryPoolResults"/>
+        </require>
+        <require comment="Buffer commands">
+            <type name="VkBuffer"/>
+            <type name="VkBufferCreateFlagBits"/>
+            <type name="VkBufferCreateFlags"/>
+            <type name="VkBufferCreateInfo"/>
+            <type name="VkBufferUsageFlagBits"/>
+            <type name="VkBufferUsageFlags"/>
+            <type name="VkSharingMode"/>
+            <command name="vkCreateBuffer"/>
+            <command name="vkDestroyBuffer"/>
+        </require>
+        <require comment="Buffer view commands">
+            <type name="VkBufferView"/>
+            <type name="VkBufferViewCreateFlags" comment="Will add VkBufferViewFlagBits when bits are defined in the future"/>
+            <type name="VkBufferViewCreateInfo"/>
+            <command name="vkCreateBufferView"/>
+            <command name="vkDestroyBufferView"/>
+        </require>
+        <require comment="Image commands">
+            <type name="VkImage"/>
+            <type name="VkImageCreateInfo"/>
+            <type name="VkImageLayout"/>
+            <type name="VkSubresourceLayout"/>
+            <command name="vkCreateImage"/>
+            <command name="vkDestroyImage"/>
+            <command name="vkGetImageSubresourceLayout"/>
+        </require>
+        <require comment="Image view commands">
+            <type name="VkComponentMapping"/>
+            <type name="VkComponentSwizzle"/>
+            <type name="VkImageSubresourceRange"/>
+            <type name="VkImageView"/>
+            <type name="VkImageViewCreateFlagBits"/>
+            <type name="VkImageViewCreateFlags"/>
+            <type name="VkImageViewCreateInfo"/>
+            <type name="VkImageViewType"/>
+            <command name="vkCreateImageView"/>
+            <command name="vkDestroyImageView"/>
+        </require>
+        <require comment="Shader commands">
+            <type name="VkShaderModule"/>
+            <type name="VkShaderModuleCreateFlags"/>
+            <type name="VkShaderModuleCreateInfo"/>
+            <command name="vkCreateShaderModule"/>
+            <command name="vkDestroyShaderModule"/>
+        </require>
+        <require comment="Pipeline Cache commands">
+            <type name="VkPipelineCache"/>
+            <type name="VkPipelineCacheCreateFlags" comment="VkPipelineCacheCreateFlagBits was added later"/>
+            <type name="VkPipelineCacheCreateInfo"/>
+            <command name="vkCreatePipelineCache"/>
+            <command name="vkDestroyPipelineCache"/>
+            <command name="vkGetPipelineCacheData"/>
+            <command name="vkMergePipelineCaches"/>
+        </require>
+        <require comment="Pipeline commands">
+            <type name="VkBlendFactor"/>
+            <type name="VkBlendOp"/>
+            <type name="VkColorComponentFlagBits"/>
+            <type name="VkColorComponentFlags"/>
+            <type name="VkCompareOp"/>
+            <type name="VkComputePipelineCreateInfo"/>
+            <type name="VkCullModeFlagBits"/>
+            <type name="VkCullModeFlags"/>
+            <type name="VkDynamicState"/>
+            <type name="VkFrontFace"/>
+            <type name="VkGraphicsPipelineCreateInfo"/>
+            <type name="VkLogicOp"/>
+            <type name="VkPipeline"/>
+            <type name="VkPipelineColorBlendAttachmentState"/>
+            <type name="VkPipelineColorBlendStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineColorBlendStateCreateInfo"/>
+            <type name="VkPipelineCreateFlagBits"/>
+            <type name="VkPipelineCreateFlags"/>
+            <type name="VkPipelineDepthStencilStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineDepthStencilStateCreateInfo"/>
+            <type name="VkPipelineDynamicStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineDynamicStateCreateInfo"/>
+            <type name="VkPipelineInputAssemblyStateCreateFlags" comment="Will add VkPipeline*StateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineInputAssemblyStateCreateInfo"/>
+            <type name="VkPipelineLayoutCreateFlags" comment="Will add VkPipelineLayoutCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineMultisampleStateCreateFlags" comment="Will add VkPipelineMultisampleStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineMultisampleStateCreateInfo"/>
+            <type name="VkPipelineRasterizationStateCreateFlags" comment="Will add VkPipelineRasterizationStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineRasterizationStateCreateInfo"/>
+            <type name="VkPipelineShaderStageCreateFlagBits"/>
+            <type name="VkPipelineShaderStageCreateFlags"/>
+            <type name="VkPipelineShaderStageCreateInfo"/>
+            <type name="VkPipelineTessellationStateCreateFlags" comment="Will add VkPipelineTessellationStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineTessellationStateCreateInfo"/>
+            <type name="VkPipelineVertexInputStateCreateFlags" comment="Will add VkPipelineVertexInputStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineVertexInputStateCreateInfo"/>
+            <type name="VkPipelineViewportStateCreateFlags" comment="Will add VkPipelineViewportStateCreateFlagBits when bits are defined in the future"/>
+            <type name="VkPipelineViewportStateCreateInfo"/>
+            <type name="VkPolygonMode"/>
+            <type name="VkPrimitiveTopology"/>
+            <type name="VkSampleMask"/>
+            <type name="VkShaderStageFlagBits"/>
+            <type name="VkShaderStageFlags"/>
+            <type name="VkSpecializationInfo"/>
+            <type name="VkSpecializationMapEntry"/>
+            <type name="VkStencilOp"/>
+            <type name="VkStencilOpState"/>
+            <type name="VkVertexInputAttributeDescription"/>
+            <type name="VkVertexInputBindingDescription"/>
+            <type name="VkVertexInputRate"/>
+            <type name="VkViewport"/>
+            <command name="vkCreateGraphicsPipelines"/>
+            <command name="vkCreateComputePipelines"/>
+            <command name="vkDestroyPipeline"/>
+        </require>
+        <require comment="Pipeline layout commands">
+            <type name="VkPipelineLayout"/>
+            <type name="VkPipelineLayoutCreateInfo"/>
+            <type name="VkPushConstantRange"/>
+            <command name="vkCreatePipelineLayout"/>
+            <command name="vkDestroyPipelineLayout"/>
+        </require>
+        <require comment="Sampler commands">
+            <type name="VkBorderColor"/>
+            <type name="VkFilter"/>
+            <type name="VkSampler"/>
+            <type name="VkSamplerAddressMode"/>
+            <type name="VkSamplerCreateFlagBits"/>
+            <type name="VkSamplerCreateFlags"/>
+            <type name="VkSamplerCreateInfo"/>
+            <type name="VkSamplerMipmapMode"/>
+            <command name="vkCreateSampler"/>
+            <command name="vkDestroySampler"/>
+        </require>
+        <require comment="Descriptor set commands">
+            <type name="VkCopyDescriptorSet"/>
+            <type name="VkDescriptorBufferInfo"/>
+            <type name="VkDescriptorImageInfo"/>
+            <type name="VkDescriptorPool"/>
+            <type name="VkDescriptorPoolCreateFlagBits"/>
+            <type name="VkDescriptorPoolCreateFlags"/>
+            <type name="VkDescriptorPoolCreateInfo"/>
+            <type name="VkDescriptorPoolResetFlags"/>
+            <type name="VkDescriptorPoolSize"/>
+            <type name="VkDescriptorSet"/>
+            <type name="VkDescriptorSetAllocateInfo"/>
+            <type name="VkDescriptorSetLayout"/>
+            <type name="VkDescriptorSetLayoutBinding"/>
+            <type name="VkDescriptorSetLayoutCreateFlagBits"/>
+            <type name="VkDescriptorSetLayoutCreateFlags"/>
+            <type name="VkDescriptorSetLayoutCreateInfo"/>
+            <type name="VkDescriptorType"/>
+            <type name="VkWriteDescriptorSet"/>
+            <command name="vkCreateDescriptorSetLayout"/>
+            <command name="vkDestroyDescriptorSetLayout"/>
+            <command name="vkCreateDescriptorPool"/>
+            <command name="vkDestroyDescriptorPool"/>
+            <command name="vkResetDescriptorPool"/>
+            <command name="vkAllocateDescriptorSets"/>
+            <command name="vkFreeDescriptorSets"/>
+            <command name="vkUpdateDescriptorSets"/>
+        </require>
+        <require comment="Pass commands">
+            <type name="VkAccessFlagBits"/>
+            <type name="VkAccessFlags"/>
+            <type name="VkAttachmentDescription"/>
+            <type name="VkAttachmentDescriptionFlagBits"/>
+            <type name="VkAttachmentDescriptionFlags"/>
+            <type name="VkAttachmentLoadOp"/>
+            <type name="VkAttachmentReference"/>
+            <type name="VkAttachmentStoreOp"/>
+            <type name="VkDependencyFlagBits"/>
+            <type name="VkDependencyFlags"/>
+            <type name="VkFramebuffer"/>
+            <type name="VkFramebufferCreateFlagBits"/>
+            <type name="VkFramebufferCreateFlags"/>
+            <type name="VkFramebufferCreateInfo"/>
+            <type name="VkPipelineBindPoint"/>
+            <type name="VkRenderPass"/>
+            <type name="VkRenderPassCreateFlagBits"/>
+            <type name="VkRenderPassCreateFlags"/>
+            <type name="VkRenderPassCreateInfo"/>
+            <type name="VkSubpassDependency"/>
+            <type name="VkSubpassDescription"/>
+            <type name="VkSubpassDescriptionFlagBits"/>
+            <type name="VkSubpassDescriptionFlags"/>
+            <command name="vkCreateFramebuffer"/>
+            <command name="vkDestroyFramebuffer"/>
+            <command name="vkCreateRenderPass"/>
+            <command name="vkDestroyRenderPass"/>
+            <command name="vkGetRenderAreaGranularity"/>
+        </require>
+        <require comment="Command pool commands">
+            <type name="VkCommandPool"/>
+            <type name="VkCommandPoolCreateFlagBits"/>
+            <type name="VkCommandPoolCreateFlags"/>
+            <type name="VkCommandPoolCreateInfo"/>
+            <type name="VkCommandPoolResetFlagBits"/>
+            <type name="VkCommandPoolResetFlags"/>
+            <command name="vkCreateCommandPool"/>
+            <command name="vkDestroyCommandPool"/>
+            <command name="vkResetCommandPool"/>
+        </require>
+        <require comment="Command buffer commands">
+            <type name="VkCommandBuffer"/>
+            <type name="VkCommandBufferAllocateInfo"/>
+            <type name="VkCommandBufferBeginInfo"/>
+            <type name="VkCommandBufferInheritanceInfo"/>
+            <type name="VkCommandBufferLevel"/>
+            <type name="VkCommandBufferResetFlagBits"/>
+            <type name="VkCommandBufferResetFlags"/>
+            <type name="VkCommandBufferUsageFlagBits"/>
+            <type name="VkCommandBufferUsageFlags"/>
+            <type name="VkQueryControlFlagBits"/>
+            <type name="VkQueryControlFlags"/>
+            <command name="vkAllocateCommandBuffers"/>
+            <command name="vkFreeCommandBuffers"/>
+            <command name="vkBeginCommandBuffer"/>
+            <command name="vkEndCommandBuffer"/>
+            <command name="vkResetCommandBuffer"/>
+        </require>
+        <require comment="Command buffer building commands">
+            <type name="VkBufferCopy"/>
+            <type name="VkBufferImageCopy"/>
+            <type name="VkClearAttachment"/>
+            <type name="VkClearColorValue"/>
+            <type name="VkClearDepthStencilValue"/>
+            <type name="VkClearRect"/>
+            <type name="VkClearValue"/>
+            <type name="VkImageBlit"/>
+            <type name="VkImageCopy"/>
+            <type name="VkImageResolve"/>
+            <type name="VkImageSubresourceLayers"/>
+            <type name="VkIndexType"/>
+            <type name="VkRenderPassBeginInfo"/>
+            <type name="VkStencilFaceFlagBits"/>
+            <type name="VkStencilFaceFlags"/>
+            <type name="VkSubpassContents"/>
+            <command name="vkCmdBindPipeline"/>
+            <command name="vkCmdSetViewport"/>
+            <command name="vkCmdSetScissor"/>
+            <command name="vkCmdSetLineWidth"/>
+            <command name="vkCmdSetDepthBias"/>
+            <command name="vkCmdSetBlendConstants"/>
+            <command name="vkCmdSetDepthBounds"/>
+            <command name="vkCmdSetStencilCompareMask"/>
+            <command name="vkCmdSetStencilWriteMask"/>
+            <command name="vkCmdSetStencilReference"/>
+            <command name="vkCmdBindDescriptorSets"/>
+            <command name="vkCmdBindIndexBuffer"/>
+            <command name="vkCmdBindVertexBuffers"/>
+            <command name="vkCmdDraw"/>
+            <command name="vkCmdDrawIndexed"/>
+            <command name="vkCmdDrawIndirect"/>
+            <command name="vkCmdDrawIndexedIndirect"/>
+            <command name="vkCmdDispatch"/>
+            <command name="vkCmdDispatchIndirect"/>
+            <command name="vkCmdCopyBuffer"/>
+            <command name="vkCmdCopyImage"/>
+            <command name="vkCmdBlitImage"/>
+            <command name="vkCmdCopyBufferToImage"/>
+            <command name="vkCmdCopyImageToBuffer"/>
+            <command name="vkCmdUpdateBuffer"/>
+            <command name="vkCmdFillBuffer"/>
+            <command name="vkCmdClearColorImage"/>
+            <command name="vkCmdClearDepthStencilImage"/>
+            <command name="vkCmdClearAttachments"/>
+            <command name="vkCmdResolveImage"/>
+            <command name="vkCmdSetEvent"/>
+            <command name="vkCmdResetEvent"/>
+            <command name="vkCmdWaitEvents"/>
+            <command name="vkCmdPipelineBarrier"/>
+            <command name="vkCmdBeginQuery"/>
+            <command name="vkCmdEndQuery"/>
+            <command name="vkCmdResetQueryPool"/>
+            <command name="vkCmdWriteTimestamp"/>
+            <command name="vkCmdCopyQueryPoolResults"/>
+            <command name="vkCmdPushConstants"/>
+            <command name="vkCmdBeginRenderPass"/>
+            <command name="vkCmdNextSubpass"/>
+            <command name="vkCmdEndRenderPass"/>
+            <command name="vkCmdExecuteCommands"/>
+        </require>
+    </feature>
+    <feature api="vulkan" name="VK_VERSION_1_1" number="1.1" comment="Vulkan 1.1 core API interface definitions.">
+        <require>
+            <type name="VK_API_VERSION_1_1"/>
+        </require>
+        <require comment="Device Initialization">
+            <command name="vkEnumerateInstanceVersion"/>
+        </require>
+        <require comment="Promoted from VK_KHR_relaxed_block_layout, which has no API"/>
+        <require comment="Promoted from VK_KHR_storage_buffer_storage_class, which has no API"/>
+        <require comment="Originally based on VK_KHR_subgroup (extension 94), but the actual enum block used was, incorrectly, that of extension 95">
+            <enum extends="VkStructureType" extnumber="95"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"/>
+            <type                                       name="VkPhysicalDeviceSubgroupProperties"/>
+            <type                                       name="VkSubgroupFeatureFlags"/>
+            <type                                       name="VkSubgroupFeatureFlagBits"/>
+        </require>
+        <require comment="Promoted from VK_KHR_bind_memory2">
+            <command name="vkBindBufferMemory2"/>
+            <command name="vkBindImageMemory2"/>
+            <enum extends="VkStructureType" extnumber="158" offset="0"          name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
+            <enum extends="VkStructureType" extnumber="158" offset="1"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
+            <enum bitpos="10" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_ALIAS_BIT"/>
+            <type name="VkBindBufferMemoryInfo"/>
+            <type name="VkBindImageMemoryInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_16bit_storage">
+            <enum extends="VkStructureType" extnumber="84"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
+            <type name="VkPhysicalDevice16BitStorageFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_dedicated_allocation">
+            <enum extends="VkStructureType" extnumber="128" offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
+            <enum extends="VkStructureType" extnumber="128" offset="1"          name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
+            <type name="VkMemoryDedicatedRequirements"/>
+            <type name="VkMemoryDedicatedAllocateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_device_group">
+            <enum extends="VkStructureType" extnumber="61"  offset="0"          name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
+            <comment>offset 1 reserved for the old VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX enum</comment>
+            <comment>offset 2 reserved for the old VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX enum</comment>
+            <enum extends="VkStructureType" extnumber="61"  offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="4"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="5"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="6"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
+            <type name="VkPeerMemoryFeatureFlags"/>
+            <type name="VkPeerMemoryFeatureFlagBits"/>
+            <type name="VkMemoryAllocateFlags"/>
+            <type name="VkMemoryAllocateFlagBits"/>
+            <type name="VkMemoryAllocateFlagsInfo"/>
+            <type name="VkDeviceGroupRenderPassBeginInfo"/>
+            <type name="VkDeviceGroupCommandBufferBeginInfo"/>
+            <type name="VkDeviceGroupSubmitInfo"/>
+            <type name="VkDeviceGroupBindSparseInfo"/>
+            <command name="vkGetDeviceGroupPeerMemoryFeatures"/>
+            <command name="vkCmdSetDeviceMask"/>
+            <command name="vkCmdDispatchBase"/>
+            <enum bitpos="3"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
+            <enum bitpos="4"  extends="VkPipelineCreateFlagBits"                name="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"/>
+            <enum extends="VkPipelineCreateFlagBits"                            name="VK_PIPELINE_CREATE_DISPATCH_BASE" alias="VK_PIPELINE_CREATE_DISPATCH_BASE_BIT"/>
+            <enum bitpos="2"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_DEVICE_GROUP_BIT" comment="Dependency is across devices"/>
+        </require>
+        <require comment="Promoted from VK_KHR_device_group + VK_KHR_bind_memory2">
+            <enum extends="VkStructureType" extnumber="61"  offset="13"         name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
+            <enum extends="VkStructureType" extnumber="61"  offset="14"         name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
+            <type name="VkBindBufferMemoryDeviceGroupInfo"/>
+            <type name="VkBindImageMemoryDeviceGroupInfo"/>
+            <enum bitpos="6"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT" comment="Allows using VkBindImageMemoryDeviceGroupInfo::pSplitInstanceBindRegions when binding memory to the image"/>
+        </require>
+        <require comment="Promoted from VK_KHR_device_group_creation">
+            <enum extends="VkStructureType" extnumber="71"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="71"  offset="1"          name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
+            <enum name="VK_MAX_DEVICE_GROUP_SIZE"/>
+            <type name="VkPhysicalDeviceGroupProperties"/>
+            <type name="VkDeviceGroupDeviceCreateInfo"/>
+            <command name="vkEnumeratePhysicalDeviceGroups"/>
+            <enum bitpos="1"  extends="VkMemoryHeapFlagBits"                    name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT" comment="If set, heap allocations allocate multiple instances by default"/>
+        </require>
+        <require comment="Promoted from VK_KHR_get_memory_requirements2">
+            <enum extends="VkStructureType" extnumber="147" offset="0"          name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="1"          name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="3"          name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
+            <enum extends="VkStructureType" extnumber="147" offset="4"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
+            <type name="VkBufferMemoryRequirementsInfo2"/>
+            <type name="VkImageMemoryRequirementsInfo2"/>
+            <type name="VkImageSparseMemoryRequirementsInfo2"/>
+            <type name="VkMemoryRequirements2"/>
+            <type name="VkSparseImageMemoryRequirements2"/>
+            <command name="vkGetImageMemoryRequirements2"/>
+            <command name="vkGetBufferMemoryRequirements2"/>
+            <command name="vkGetImageSparseMemoryRequirements2"/>
+        </require>
+        <require comment="Promoted from VK_KHR_get_physical_device_properties2">
+            <enum extends="VkStructureType" extnumber="60"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="2"          name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="5"          name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="6"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="7"          name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
+            <enum extends="VkStructureType" extnumber="60"  offset="8"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
+            <type name="VkPhysicalDeviceFeatures2"/>
+            <type name="VkPhysicalDeviceProperties2"/>
+            <type name="VkFormatProperties2"/>
+            <type name="VkImageFormatProperties2"/>
+            <type name="VkPhysicalDeviceImageFormatInfo2"/>
+            <type name="VkQueueFamilyProperties2"/>
+            <type name="VkPhysicalDeviceMemoryProperties2"/>
+            <type name="VkSparseImageFormatProperties2"/>
+            <type name="VkPhysicalDeviceSparseImageFormatInfo2"/>
+            <command name="vkGetPhysicalDeviceFeatures2"/>
+            <command name="vkGetPhysicalDeviceProperties2"/>
+            <command name="vkGetPhysicalDeviceFormatProperties2"/>
+            <command name="vkGetPhysicalDeviceImageFormatProperties2"/>
+            <command name="vkGetPhysicalDeviceQueueFamilyProperties2"/>
+            <command name="vkGetPhysicalDeviceMemoryProperties2"/>
+            <command name="vkGetPhysicalDeviceSparseImageFormatProperties2"/>
+        </require>
+        <require comment="Promoted from VK_KHR_maintenance1">
+            <enum extends="VkResult"        extnumber="70"  offset="0"  dir="-" name="VK_ERROR_OUT_OF_POOL_MEMORY"/>
+            <enum bitpos="14" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT" comment="Format can be used as the source image of image transfer commands"/>
+            <enum bitpos="15" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT" comment="Format can be used as the destination image of image transfer commands"/>
+            <enum bitpos="5"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT" comment="The 3D image can be viewed as a 2D or 2D array image"/>
+            <command name="vkTrimCommandPool"/>
+            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
+            <type name="VkCommandPoolTrimFlags"/>
+        </require>
+        <require comment="Promoted from VK_KHR_maintenance2">
+            <enum bitpos="7"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
+            <enum bitpos="8"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
+            <enum extends="VkStructureType" extnumber="118" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="118" offset="1"          name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="118" offset="2"          name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="118" offset="3"          name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
+            <enum extends="VkImageLayout"   extnumber="118" offset="0"          name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
+            <enum extends="VkImageLayout"   extnumber="118" offset="1"          name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
+            <type name="VkPhysicalDevicePointClippingProperties"/>
+            <type name="VkPointClippingBehavior"/>
+            <type name="VkRenderPassInputAttachmentAspectCreateInfo"/>
+            <type name="VkInputAttachmentAspectReference"/>
+            <type name="VkImageViewUsageCreateInfo"/>
+            <type name="VkTessellationDomainOrigin"/>
+            <type name="VkPipelineTessellationDomainOriginStateCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_multiview">
+            <enum extends="VkStructureType" extnumber="54"  offset="0"          name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="54"  offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
+            <enum extends="VkStructureType" extnumber="54"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
+            <enum bitpos="1"  extends="VkDependencyFlagBits"                    name="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
+            <type name="VkRenderPassMultiviewCreateInfo"/>
+            <type name="VkPhysicalDeviceMultiviewFeatures"/>
+            <type name="VkPhysicalDeviceMultiviewProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_variable_pointers">
+            <enum extends="VkStructureType" extnumber="121" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
+            <enum extends="VkStructureType"                                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
+            <type name="VkPhysicalDeviceVariablePointerFeatures"/>
+            <type name="VkPhysicalDeviceVariablePointersFeatures"/>
+        </require>
+        <require comment="Originally based on VK_KHR_protected_memory (extension 146), which was never published; thus the mystifying large value= numbers below. These are not aliased since they weren't actually promoted from an extension.">
+            <enum extends="VkStructureType" extnumber="146" offset="0"          name="VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO"/>
+            <enum extends="VkStructureType" extnumber="146" offset="1"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"/>
+            <enum extends="VkStructureType" extnumber="146" offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="146" offset="3"          name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2"/>
+            <enum bitpos="4"  extends="VkQueueFlagBits"                         name="VK_QUEUE_PROTECTED_BIT" comment="Queues may support protected operations"/>
+            <enum bitpos="0"  extends="VkDeviceQueueCreateFlagBits"             name="VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT" comment="Queue is a protected-capable device queue"/>
+            <type name="VkDeviceQueueCreateFlagBits" comment="This is a temporary workaround for processors not recognizing that VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT above also requires this type"/>
+            <enum bitpos="5"  extends="VkMemoryPropertyFlagBits"                name="VK_MEMORY_PROPERTY_PROTECTED_BIT" comment="Memory is protected"/>
+            <enum bitpos="3"  extends="VkBufferCreateFlagBits"                  name="VK_BUFFER_CREATE_PROTECTED_BIT" comment="Buffer requires protected memory"/>
+            <enum bitpos="11" extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_PROTECTED_BIT" comment="Image requires protected memory"/>
+            <enum bitpos="2"  extends="VkCommandPoolCreateFlagBits"             name="VK_COMMAND_POOL_CREATE_PROTECTED_BIT" comment="Command buffers allocated from pool are protected command buffers"/>
+            <type name="VkPhysicalDeviceProtectedMemoryFeatures"/>
+            <type name="VkPhysicalDeviceProtectedMemoryProperties"/>
+            <type name="VkDeviceQueueInfo2"/>
+            <type name="VkProtectedSubmitInfo"/>
+            <command name="vkGetDeviceQueue2"/>
+        </require>
+        <require comment="Promoted from VK_KHR_sampler_ycbcr_conversion">
+            <enum extends="VkStructureType" extnumber="157" offset="0"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="1"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="2"          name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="3"          name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
+            <enum extends="VkStructureType" extnumber="157" offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
+            <enum extends="VkStructureType" extnumber="157" offset="5"          name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
+            <enum extends="VkObjectType"    extnumber="157" offset="0"          name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
+            <enum extends="VkFormat"        extnumber="157" offset="0"          name="VK_FORMAT_G8B8G8R8_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="1"          name="VK_FORMAT_B8G8R8G8_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="2"          name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="3"          name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="4"          name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="5"          name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="6"          name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="7"          name="VK_FORMAT_R10X6_UNORM_PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="8"          name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="9"          name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="10"         name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="11"         name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="12"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="13"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="14"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="15"         name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="16"         name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="17"         name="VK_FORMAT_R12X4_UNORM_PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="18"         name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="19"         name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="20"         name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="21"         name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="22"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="23"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="24"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="25"         name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="26"         name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
+            <enum extends="VkFormat"        extnumber="157" offset="27"         name="VK_FORMAT_G16B16G16R16_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="28"         name="VK_FORMAT_B16G16R16G16_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="29"         name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="30"         name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="31"         name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="32"         name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
+            <enum extends="VkFormat"        extnumber="157" offset="33"         name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
+            <enum bitpos="4"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
+            <enum bitpos="5"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
+            <enum bitpos="6"  extends="VkImageAspectFlagBits"                   name="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
+            <enum bitpos="9"  extends="VkImageCreateFlagBits"                   name="VK_IMAGE_CREATE_DISJOINT_BIT"/>
+            <enum bitpos="17" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT" comment="Format can have midpoint rather than cosited chroma samples"/>
+            <enum bitpos="18" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT" comment="Format can be used with linear filtering whilst color conversion is enabled"/>
+            <enum bitpos="19" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT" comment="Format can have different chroma, min and mag filters"/>
+            <enum bitpos="20" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
+            <enum bitpos="21" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
+            <enum bitpos="22" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_DISJOINT_BIT" comment="Format supports disjoint planes"/>
+            <enum bitpos="23" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT" comment="Format can have cosited rather than midpoint chroma samples"/>
+            <type name="VkSamplerYcbcrConversionCreateInfo"/>
+            <type name="VkSamplerYcbcrConversionInfo"/>
+            <type name="VkBindImagePlaneMemoryInfo"/>
+            <type name="VkImagePlaneMemoryRequirementsInfo"/>
+            <type name="VkPhysicalDeviceSamplerYcbcrConversionFeatures"/>
+            <type name="VkSamplerYcbcrConversionImageFormatProperties"/>
+            <command name="vkCreateSamplerYcbcrConversion"/>
+            <command name="vkDestroySamplerYcbcrConversion"/>
+            <comment>Additional dependent types / tokens extending enumerants, not explicitly mentioned</comment>
+            <type name="VkSamplerYcbcrConversion"/>
+            <type name="VkSamplerYcbcrModelConversion"/>
+            <type name="VkSamplerYcbcrRange"/>
+            <type name="VkChromaLocation"/>
+        </require>
+        <require comment="Promoted from VK_KHR_descriptor_update_template">
+            <enum extends="VkStructureType" extnumber="86"  offset="0"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
+            <enum extends="VkObjectType"    extnumber="86"  offset="0"          name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
+            <command name="vkCreateDescriptorUpdateTemplate"/>
+            <command name="vkDestroyDescriptorUpdateTemplate"/>
+            <command name="vkUpdateDescriptorSetWithTemplate"/>
+            <type name="VkDescriptorUpdateTemplate"/>
+            <type name="VkDescriptorUpdateTemplateCreateFlags"/>
+            <type name="VkDescriptorUpdateTemplateType"/>
+            <type name="VkDescriptorUpdateTemplateEntry"/>
+            <type name="VkDescriptorUpdateTemplateCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_memory_capabilities">
+            <enum extends="VkStructureType" extnumber="72"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="2"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="3"          name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="72"  offset="4"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+            <enum name="VK_LUID_SIZE"/>
+            <type name="VkExternalMemoryHandleTypeFlags"/>
+            <type name="VkExternalMemoryHandleTypeFlagBits"/>
+            <type name="VkExternalMemoryFeatureFlags"/>
+            <type name="VkExternalMemoryFeatureFlagBits"/>
+            <type name="VkExternalMemoryProperties"/>
+            <type name="VkPhysicalDeviceExternalImageFormatInfo"/>
+            <type name="VkExternalImageFormatProperties"/>
+            <type name="VkPhysicalDeviceExternalBufferInfo"/>
+            <type name="VkExternalBufferProperties"/>
+            <type name="VkPhysicalDeviceIDProperties"/>
+            <command name="vkGetPhysicalDeviceExternalBufferProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_memory">
+            <enum extends="VkStructureType" extnumber="73"  offset="0"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="73"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
+            <enum extends="VkStructureType" extnumber="73"  offset="2"          name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
+            <enum extends="VkResult"        extnumber="73"  offset="3"  dir="-" name="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
+            <enum name="VK_QUEUE_FAMILY_EXTERNAL"/>
+            <type name="VkExternalMemoryImageCreateInfo"/>
+            <type name="VkExternalMemoryBufferCreateInfo"/>
+            <type name="VkExportMemoryAllocateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_fence_capabilities">
+            <enum extends="VkStructureType" extnumber="113" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
+            <enum extends="VkStructureType" extnumber="113" offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
+            <type name="VkExternalFenceHandleTypeFlags"/>
+            <type name="VkExternalFenceHandleTypeFlagBits"/>
+            <type name="VkExternalFenceFeatureFlags"/>
+            <type name="VkExternalFenceFeatureFlagBits"/>
+            <type name="VkPhysicalDeviceExternalFenceInfo"/>
+            <type name="VkExternalFenceProperties"/>
+            <command name="vkGetPhysicalDeviceExternalFenceProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_fence">
+            <enum extends="VkStructureType" extnumber="114" offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
+            <type name="VkFenceImportFlags"/>
+            <type name="VkFenceImportFlagBits"/>
+            <type name="VkExportFenceCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_semaphore">
+            <enum extends="VkStructureType" extnumber="78"  offset="0"          name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
+            <type name="VkSemaphoreImportFlags"/>
+            <type name="VkSemaphoreImportFlagBits"/>
+            <type name="VkExportSemaphoreCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_external_semaphore_capabilities">
+            <enum extends="VkStructureType" extnumber="77"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
+            <enum extends="VkStructureType" extnumber="77"  offset="1"          name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
+            <type name="VkExternalSemaphoreHandleTypeFlags"/>
+            <type name="VkExternalSemaphoreHandleTypeFlagBits"/>
+            <type name="VkExternalSemaphoreFeatureFlags"/>
+            <type name="VkExternalSemaphoreFeatureFlagBits"/>
+            <type name="VkPhysicalDeviceExternalSemaphoreInfo"/>
+            <type name="VkExternalSemaphoreProperties"/>
+            <command name="vkGetPhysicalDeviceExternalSemaphoreProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_maintenance3">
+            <enum extends="VkStructureType" extnumber="169" offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
+            <enum extends="VkStructureType" extnumber="169" offset="1"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
+            <type name="VkPhysicalDeviceMaintenance3Properties"/>
+            <type name="VkDescriptorSetLayoutSupport"/>
+            <command name="vkGetDescriptorSetLayoutSupport"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_draw_parameters, with a feature support query added">
+            <enum extends="VkStructureType" extnumber="64"  offset="0"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
+            <enum extends="VkStructureType"                                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderDrawParameterFeatures"/>
+            <type name="VkPhysicalDeviceShaderDrawParametersFeatures"/>
+        </require>
+    </feature>
+    <feature api="vulkan" name="VK_VERSION_1_2" number="1.2" comment="Vulkan 1.2 core API interface definitions.">
+        <require>
+            <type name="VK_API_VERSION_1_2"/>
+        </require>
+        <require>
+            <enum extends="VkStructureType" value="49" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"/>
+            <enum extends="VkStructureType" value="50" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"/>
+            <enum extends="VkStructureType" value="51" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"/>
+            <enum extends="VkStructureType" value="52" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"/>
+            <type name="VkPhysicalDeviceVulkan11Features"/>
+            <type name="VkPhysicalDeviceVulkan11Properties"/>
+            <type name="VkPhysicalDeviceVulkan12Features"/>
+            <type name="VkPhysicalDeviceVulkan12Properties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_image_format_list (extension 148)">
+            <enum offset="0" extends="VkStructureType"  extnumber="148"         name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"/>
+            <type name="VkImageFormatListCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_sampler_mirror_clamp_to_edge (extension 15)">
+            <enum value="4" extends="VkSamplerAddressMode"                      name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="No need to add an extnumber attribute, since this uses a core enum value"/>
+        </require>
+        <require comment="Promoted from VK_KHR_draw_indirect_count (extension 170)">
+            <command name="vkCmdDrawIndirectCount"/>
+            <command name="vkCmdDrawIndexedIndirectCount"/>
+        </require>
+        <require comment="Promoted from VK_KHR_create_renderpass2 (extension 110)">
+            <enum offset="0" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"/>
+            <enum offset="1" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"/>
+            <enum offset="2" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"/>
+            <enum offset="3" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"/>
+            <enum offset="4" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"/>
+            <enum offset="5" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"/>
+            <enum offset="6" extends="VkStructureType" extnumber="110"          name="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"/>
+            <command name="vkCreateRenderPass2"/>
+            <command name="vkCmdBeginRenderPass2"/>
+            <command name="vkCmdNextSubpass2"/>
+            <command name="vkCmdEndRenderPass2"/>
+            <type name="VkRenderPassCreateInfo2"/>
+            <type name="VkAttachmentDescription2"/>
+            <type name="VkAttachmentReference2"/>
+            <type name="VkSubpassDescription2"/>
+            <type name="VkSubpassDependency2"/>
+            <type name="VkSubpassBeginInfo"/>
+            <type name="VkSubpassEndInfo"/>
+        </require>
+        <require comment="Promoted from VK_KHR_8bit_storage (extension 178)">
+            <enum offset="0" extends="VkStructureType" extnumber="178"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"/>
+            <type name="VkPhysicalDevice8BitStorageFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_driver_properties (extension 197)">
+            <enum offset="0" extends="VkStructureType" extnumber="197"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"/>
+            <enum name="VK_MAX_DRIVER_NAME_SIZE"/>
+            <enum name="VK_MAX_DRIVER_INFO_SIZE"/>
+            <type name="VkDriverId"/>
+            <type name="VkConformanceVersion"/>
+            <type name="VkPhysicalDeviceDriverProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_atomic_int64 (extension 181)">
+            <enum offset="0" extends="VkStructureType" extnumber="181"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderAtomicInt64Features"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_float16_int8 (extension 83)">
+            <enum offset="0" extends="VkStructureType" extnumber="83"           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderFloat16Int8Features"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_float_controls (extension 198)">
+            <enum offset="0" extends="VkStructureType" extnumber="198"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"/>
+            <type name="VkPhysicalDeviceFloatControlsProperties"/>
+            <type name="VkShaderFloatControlsIndependence"/>
+        </require>
+        <require comment="Promoted from VK_EXT_descriptor_indexing (extension 162)">
+            <enum offset="0" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"/>
+            <enum offset="1" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"/>
+            <enum offset="2" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"/>
+            <enum offset="3" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"/>
+            <enum offset="4" extends="VkStructureType" extnumber="162"          name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"/>
+            <enum bitpos="1" extends="VkDescriptorPoolCreateFlagBits"           name="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"/>
+            <enum bitpos="1" extends="VkDescriptorSetLayoutCreateFlagBits"      name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"/>
+            <enum offset="0" dir="-" extends="VkResult" extnumber="162"         name="VK_ERROR_FRAGMENTATION"/>
+            <type name="VkDescriptorSetLayoutBindingFlagsCreateInfo"/>
+            <type name="VkPhysicalDeviceDescriptorIndexingFeatures"/>
+            <type name="VkPhysicalDeviceDescriptorIndexingProperties"/>
+            <type name="VkDescriptorSetVariableDescriptorCountAllocateInfo"/>
+            <type name="VkDescriptorSetVariableDescriptorCountLayoutSupport"/>
+            <type name="VkDescriptorBindingFlagBits"/>
+            <type name="VkDescriptorBindingFlags"/>
+        </require>
+        <require comment="Promoted from VK_KHR_depth_stencil_resolve (extension 200)">
+            <enum offset="0" extends="VkStructureType" extnumber="200"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="200"          name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"/>
+            <type name="VkSubpassDescriptionDepthStencilResolve"/>
+            <type name="VkPhysicalDeviceDepthStencilResolveProperties"/>
+            <type name="VkResolveModeFlagBits"/>
+            <type name="VkResolveModeFlags"/>
+        </require>
+        <require comment="Promoted from VK_EXT_scalar_block_layout (extension 222))">
+            <type                                                               name="VkPhysicalDeviceScalarBlockLayoutFeatures"/>
+            <enum offset="0" extends="VkStructureType" extnumber="222"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"/>
+        </require>
+        <require comment="Promoted from VK_EXT_shader_viewport_index_layer, which has no API (extension 163)"/>
+        <require comment="Promoted from VK_EXT_separate_stencil_usage (extension 247)">
+            <enum offset="0" extends="VkStructureType" extnumber="247"          name="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"/>
+            <type name="VkImageStencilUsageCreateInfo"/>
+        </require>
+        <require comment="Promoted from VK_EXT_sampler_filter_minmax (extension 131)">
+            <enum offset="0" extends="VkStructureType" extnumber="131"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="131"          name="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"/>
+            <enum bitpos="16" extends="VkFormatFeatureFlagBits"                 name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT" comment="Format can be used with min/max reduction filtering"/>
+            <type name="VkSamplerReductionMode"/>
+            <type name="VkSamplerReductionModeCreateInfo"/>
+            <type name="VkPhysicalDeviceSamplerFilterMinmaxProperties"/>
+        </require>
+        <require comment="Promoted from VK_KHR_vulkan_memory_model (extension 212)">
+            <enum offset="0" extends="VkStructureType" extnumber="212"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"/>
+            <type name="VkPhysicalDeviceVulkanMemoryModelFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_imageless_framebuffer (extension 109)">
+            <type name="VkPhysicalDeviceImagelessFramebufferFeatures"/>
+            <type name="VkFramebufferAttachmentsCreateInfo"/>
+            <type name="VkFramebufferAttachmentImageInfo"/>
+            <type name="VkRenderPassAttachmentBeginInfo"/>
+            <enum offset="0" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"/>
+            <enum offset="2" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"/>
+            <enum offset="3" extends="VkStructureType" extnumber="109"          name="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"/>
+            <enum bitpos="0" extends="VkFramebufferCreateFlagBits"              name="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"/>
+        </require>
+        <require comment="Promoted from VK_KHR_uniform_buffer_standard_layout (extension 254)">
+            <type name="VkPhysicalDeviceUniformBufferStandardLayoutFeatures"/>
+            <enum offset="0" extends="VkStructureType" extnumber="254"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"/>
+        </require>
+        <require comment="Promoted from VK_KHR_shader_subgroup_extended_types (extension 176)">
+            <enum offset="0" extends="VkStructureType" extnumber="176"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"/>
+            <type name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"/>
+        </require>
+        <require comment="Promoted from VK_KHR_spirv_1_4 (extension 237)">
+        </require>
+        <require comment="Promoted from VK_KHR_separate_depth_stencil_layouts (extension 242)">
+            <enum offset="0" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"/>
+            <enum offset="2" extends="VkStructureType" extnumber="242"          name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"/>
+            <enum offset="0" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"/>
+            <enum offset="1" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"/>
+            <enum offset="2" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"/>
+            <enum offset="3" extends="VkImageLayout"   extnumber="242"          name="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"/>
+            <type name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"/>
+            <type name="VkAttachmentReferenceStencilLayout"/>
+            <type name="VkAttachmentDescriptionStencilLayout"/>
+        </require>
+        <require comment="Promoted from VK_EXT_host_query_reset (extension 262)">
+            <enum offset="0" extends="VkStructureType" extnumber="262"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"/>
+            <type name="VkPhysicalDeviceHostQueryResetFeatures"/>
+            <command name="vkResetQueryPool"/>
+        </require>
+        <require comment="Promoted from VK_KHR_timeline_semaphore (extension 208)">
+            <enum offset="0" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"/>
+            <enum offset="2" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"/>
+            <enum offset="3" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"/>
+            <enum offset="4" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"/>
+            <enum offset="5" extends="VkStructureType" extnumber="208"          name="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"/>
+            <type name="VkSemaphoreType"/>
+            <type name="VkPhysicalDeviceTimelineSemaphoreFeatures"/>
+            <type name="VkPhysicalDeviceTimelineSemaphoreProperties"/>
+            <type name="VkSemaphoreTypeCreateInfo"/>
+            <type name="VkTimelineSemaphoreSubmitInfo"/>
+            <type name="VkSemaphoreWaitFlagBits"/>
+            <type name="VkSemaphoreWaitFlags"/>
+            <type name="VkSemaphoreWaitInfo"/>
+            <type name="VkSemaphoreSignalInfo"/>
+            <command name="vkGetSemaphoreCounterValue"/>
+            <command name="vkWaitSemaphores"/>
+            <command name="vkSignalSemaphore"/>
+        </require>
+        <require comment="Promoted from VK_KHR_buffer_device_address (extension 258)">
+            <enum offset="0" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"/>
+            <enum offset="1" extends="VkStructureType" extnumber="245"          name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
+            <enum offset="2" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"/>
+            <enum offset="3" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"/>
+            <enum offset="4" extends="VkStructureType" extnumber="258"          name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"/>
+            <enum bitpos="17" extends="VkBufferUsageFlagBits"                   name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
+            <enum bitpos="4"  extends="VkBufferCreateFlagBits"                  name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+            <enum bitpos="1" extends="VkMemoryAllocateFlagBits"                 name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"/>
+            <enum bitpos="2" extends="VkMemoryAllocateFlagBits"                 name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+            <enum offset="0" dir="-" extends="VkResult" extnumber="258"         name="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
+            <type name="VkPhysicalDeviceBufferDeviceAddressFeatures"/>
+            <type name="VkBufferDeviceAddressInfo"/>
+            <type name="VkBufferOpaqueCaptureAddressCreateInfo"/>
+            <type name="VkMemoryOpaqueCaptureAddressAllocateInfo"/>
+            <type name="VkDeviceMemoryOpaqueCaptureAddressInfo"/>
+            <command name="vkGetBufferDeviceAddress"/>
+            <command name="vkGetBufferOpaqueCaptureAddress"/>
+            <command name="vkGetDeviceMemoryOpaqueCaptureAddress"/>
+        </require>
+    </feature>
+
+    <extensions comment="Vulkan extension interface definitions">
+        <extension name="VK_KHR_surface" number="1" type="instance" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="25"                                                name="VK_KHR_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_surface&quot;"                        name="VK_KHR_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_SURFACE_LOST_KHR"/>
+                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_NATIVE_WINDOW_IN_USE_KHR"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SURFACE_KHR"/>
+                <type name="VkSurfaceKHR"/>
+                <type name="VkSurfaceTransformFlagBitsKHR"/>
+                <type name="VkPresentModeKHR"/>
+                <type name="VkColorSpaceKHR"/>
+                <type name="VkCompositeAlphaFlagBitsKHR"/>
+                <type name="VkCompositeAlphaFlagsKHR"/>
+                <type name="VkSurfaceCapabilitiesKHR"/>
+                <type name="VkSurfaceFormatKHR"/>
+                <command name="vkDestroySurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceSupportKHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceCapabilitiesKHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceFormatsKHR"/>
+                <command name="vkGetPhysicalDeviceSurfacePresentModesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_swapchain" number="2" type="device" requires="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="70"                                                name="VK_KHR_SWAPCHAIN_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_swapchain&quot;"                      name="VK_KHR_SWAPCHAIN_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_INFO_KHR"/>
+                <enum offset="2" extends="VkImageLayout"                        name="VK_IMAGE_LAYOUT_PRESENT_SRC_KHR"/>
+                <enum offset="3" extends="VkResult"                             name="VK_SUBOPTIMAL_KHR"/>
+                <enum offset="4" extends="VkResult" dir="-"                     name="VK_ERROR_OUT_OF_DATE_KHR"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_SWAPCHAIN_KHR"/>
+                <type name="VkSwapchainCreateFlagBitsKHR"/>
+                <type name="VkSwapchainCreateFlagsKHR"/>
+                <type name="VkSwapchainCreateInfoKHR"/>
+                <type name="VkSwapchainKHR"/>
+                <type name="VkPresentInfoKHR"/>
+                <command name="vkCreateSwapchainKHR"/>
+                <command name="vkDestroySwapchainKHR"/>
+                <command name="vkGetSwapchainImagesKHR"/>
+                <command name="vkAcquireNextImageKHR"/>
+                <command name="vkQueuePresentKHR"/>
+            </require>
+            <require feature="VK_VERSION_1_1">
+                <comment>This duplicates definitions in VK_KHR_device_group below</comment>
+                <enum extends="VkStructureType" extnumber="61"  offset="7"      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="8"      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="9"      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="10"     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="11"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
+                <enum extends="VkStructureType" extnumber="61"  offset="12"     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
+                <type name="VkImageSwapchainCreateInfoKHR"/>
+                <type name="VkBindImageMemorySwapchainInfoKHR"/>
+                <type name="VkAcquireNextImageInfoKHR"/>
+                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
+                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
+                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
+                <type name="VkDeviceGroupPresentInfoKHR"/>
+                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
+                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
+                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
+                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
+                <command name="vkAcquireNextImage2KHR"/>
+                <enum bitpos="1" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR"     comment="Swapchain is protected"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_display" number="3" type="instance" requires="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo,Norbert Nopper @FslNopper" supported="vulkan">
+            <require>
+                <enum value="23"                                                name="VK_KHR_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_display&quot;"                        name="VK_KHR_DISPLAY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_KHR"/>
+                <enum offset="1" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DISPLAY_MODE_KHR"/>
+                <type name="VkDisplayKHR"/>
+                <type name="VkDisplayModeCreateFlagsKHR"/>
+                <type name="VkDisplayModeCreateInfoKHR"/>
+                <type name="VkDisplayModeKHR"/>
+                <type name="VkDisplayModeParametersKHR"/>
+                <type name="VkDisplayModePropertiesKHR"/>
+                <type name="VkDisplayPlaneAlphaFlagBitsKHR"/>
+                <type name="VkDisplayPlaneAlphaFlagsKHR"/>
+                <type name="VkDisplayPlaneCapabilitiesKHR"/>
+                <type name="VkDisplayPlanePropertiesKHR"/>
+                <type name="VkDisplayPropertiesKHR"/>
+                <type name="VkDisplaySurfaceCreateFlagsKHR"/>
+                <type name="VkDisplaySurfaceCreateInfoKHR"/>
+                <type name="VkSurfaceTransformFlagsKHR"/>
+                <command name="vkGetPhysicalDeviceDisplayPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceDisplayPlanePropertiesKHR"/>
+                <command name="vkGetDisplayPlaneSupportedDisplaysKHR"/>
+                <command name="vkGetDisplayModePropertiesKHR"/>
+                <command name="vkCreateDisplayModeKHR"/>
+                <command name="vkGetDisplayPlaneCapabilitiesKHR"/>
+                <command name="vkCreateDisplayPlaneSurfaceKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_display_swapchain" number="4" type="device" requires="VK_KHR_swapchain,VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="10"                                                name="VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_display_swapchain&quot;"              name="VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR"/>
+                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_INCOMPATIBLE_DISPLAY_KHR"/>
+                <type name="VkDisplayPresentInfoKHR"/>
+                <command name="vkCreateSharedSwapchainsKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_xlib_surface" number="5" type="instance" requires="VK_KHR_surface" platform="xlib" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_XLIB_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_xlib_surface&quot;"                   name="VK_KHR_XLIB_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkXlibSurfaceCreateFlagsKHR"/>
+                <type name="VkXlibSurfaceCreateInfoKHR"/>
+                <command name="vkCreateXlibSurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceXlibPresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_xcb_surface" number="6" type="instance" requires="VK_KHR_surface" platform="xcb" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_XCB_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_xcb_surface&quot;"                    name="VK_KHR_XCB_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkXcbSurfaceCreateFlagsKHR"/>
+                <type name="VkXcbSurfaceCreateInfoKHR"/>
+                <command name="vkCreateXcbSurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceXcbPresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_wayland_surface" number="7" type="instance" requires="VK_KHR_surface" platform="wayland" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_WAYLAND_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_wayland_surface&quot;"                name="VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkWaylandSurfaceCreateFlagsKHR"/>
+                <type name="VkWaylandSurfaceCreateInfoKHR"/>
+                <command name="vkCreateWaylandSurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceWaylandPresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_mir_surface" number="8" type="instance" requires="VK_KHR_surface" author="KHR" supported="disabled" comment="Extension permanently disabled. Extension number should not be reused">
+            <require>
+                <enum value="4"                                                 name="VK_KHR_MIR_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_mir_surface&quot;"                    name="VK_KHR_MIR_SURFACE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_android_surface" number="9" type="instance" requires="VK_KHR_surface" platform="android" author="KHR" contact="Jesse Hall @critsec" supported="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_ANDROID_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_android_surface&quot;"                name="VK_KHR_ANDROID_SURFACE_EXTENSION_NAME"/>
+                <type name="ANativeWindow"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkAndroidSurfaceCreateFlagsKHR"/>
+                <type name="VkAndroidSurfaceCreateInfoKHR"/>
+                <command name="vkCreateAndroidSurfaceKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_win32_surface" number="10" type="instance" requires="VK_KHR_surface" platform="win32" author="KHR" contact="Jesse Hall @critsec,Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="6"                                                 name="VK_KHR_WIN32_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_win32_surface&quot;"                  name="VK_KHR_WIN32_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR"/>
+                <type name="VkWin32SurfaceCreateFlagsKHR"/>
+                <type name="VkWin32SurfaceCreateInfoKHR"/>
+                <command name="vkCreateWin32SurfaceKHR"/>
+                <command name="vkGetPhysicalDeviceWin32PresentationSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_ANDROID_native_buffer" number="11" type="device" author="ANDROID" platform="android" contact="Jesse Hall @critsec" supported="disabled">
+            <require>
+                <comment>VK_ANDROID_native_buffer is used between the Android Vulkan loader and drivers to implement the WSI extensions. It isn't exposed to applications and uses types that aren't part of Android's stable public API, so it is left disabled to keep it out of the standard Vulkan headers.</comment>
+                <enum value="8"                                                 name="VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION"/>
+                <enum value="11"                                                name="VK_ANDROID_NATIVE_BUFFER_NUMBER"/>
+                <enum value="&quot;VK_ANDROID_native_buffer&quot;"              name="VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME"/>
+                <enum                                                           name="VK_ANDROID_NATIVE_BUFFER_NAME" alias="VK_ANDROID_NATIVE_BUFFER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID"/>
+                <type name="VkNativeBufferANDROID"/>
+                <type name="VkSwapchainImageCreateInfoANDROID"/>
+                <type name="VkPhysicalDevicePresentationPropertiesANDROID"/>
+                <type name="VkNativeBufferUsage2ANDROID"/>
+                <type name="VkSwapchainImageUsageFlagBitsANDROID"/>
+                <type name="VkSwapchainImageUsageFlagsANDROID"/>
+                <command name="vkGetSwapchainGrallocUsageANDROID"/>
+                <command name="vkAcquireImageANDROID"/>
+                <command name="vkQueueSignalReleaseImageANDROID"/>
+                <command name="vkGetSwapchainGrallocUsage2ANDROID"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_debug_report" number="12" type="instance" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" specialuse="debugging" supported="vulkan" deprecatedby="VK_EXT_debug_utils">
+            <require>
+                <enum value="10"                                                name="VK_EXT_DEBUG_REPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_debug_report&quot;"                   name="VK_EXT_DEBUG_REPORT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT"/>
+                <enum alias="VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT" comment="Backwards-compatible alias containing a typo"/>
+                <enum offset="1" extends="VkResult" dir="-"                     name="VK_ERROR_VALIDATION_FAILED_EXT"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT"/>
+                <type name="VkDebugReportCallbackEXT"/>
+                <type name="PFN_vkDebugReportCallbackEXT"/>
+                <type name="VkDebugReportFlagBitsEXT"/>
+                <type name="VkDebugReportFlagsEXT"/>
+                <type name="VkDebugReportObjectTypeEXT"/>
+                <type name="VkDebugReportCallbackCreateInfoEXT"/>
+                <command name="vkCreateDebugReportCallbackEXT"/>
+                <command name="vkDestroyDebugReportCallbackEXT"/>
+                <command name="vkDebugReportMessageEXT"/>
+            </require>
+            <require feature="VK_VERSION_1_1">
+                <comment>This duplicates definitions in other extensions, below</comment>
+                <enum extends="VkDebugReportObjectTypeEXT" extnumber="157" offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
+                <enum extends="VkDebugReportObjectTypeEXT" extnumber="86"  offset="0"  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_glsl_shader" number="13" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan" deprecatedby="">
+            <require>
+                <enum value="1"                                                 name="VK_NV_GLSL_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_glsl_shader&quot;"                     name="VK_NV_GLSL_SHADER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkResult" dir="-"                     name="VK_ERROR_INVALID_SHADER_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_depth_range_unrestricted" type="device" number="14" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_depth_range_unrestricted&quot;"       name="VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_sampler_mirror_clamp_to_edge" type="device" number="15" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="3"                                                 name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_sampler_mirror_clamp_to_edge&quot;"   name="VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME"/>
+                <enum value="4" extends="VkSamplerAddressMode"                  name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Note that this defines what was previously a core enum, and so uses the 'value' attribute rather than 'offset', and does not have a suffix. This is a special case, and should not be repeated"/>
+                <enum           extends="VkSamplerAddressMode"                  name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR" alias="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Alias introduced for consistency with extension suffixing rules"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_filter_cubic" number="16" type="device" author="IMG" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_IMG_FILTER_CUBIC_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_filter_cubic&quot;"                   name="VK_IMG_FILTER_CUBIC_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkFilter"                             name="VK_FILTER_CUBIC_IMG"/>
+                <enum bitpos="13" extends="VkFormatFeatureFlagBits"             name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG" comment="Format can be filtered with VK_FILTER_CUBIC_IMG when being sampled"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_17" number="17" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_17_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_17&quot;"                   name="VK_AMD_EXTENSION_17_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_18" number="18" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_18_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_18&quot;"                   name="VK_AMD_EXTENSION_18_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_rasterization_order" number="19" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_rasterization_order&quot;"            name="VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD"/>
+                <type name="VkRasterizationOrderAMD"/>
+                <type name="VkPipelineRasterizationStateRasterizationOrderAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_20" number="20" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_20_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_20&quot;"                   name="VK_AMD_EXTENSION_20_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_trinary_minmax" number="21" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_trinary_minmax&quot;"          name="VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_explicit_vertex_parameter" number="22" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_explicit_vertex_parameter&quot;" name="VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_debug_marker" number="23" type="device" requires="VK_EXT_debug_report" author="Baldur Karlsson" contact="Baldur Karlsson @baldurk" specialuse="debugging" supported="vulkan" promotedto="VK_EXT_debug_utils">
+            <require>
+                <enum value="4"                                                 name="VK_EXT_DEBUG_MARKER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_debug_marker&quot;"                   name="VK_EXT_DEBUG_MARKER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT"/>
+                <type name="VkDebugReportObjectTypeEXT"/>
+                <type name="VkDebugMarkerObjectNameInfoEXT"/>
+                <type name="VkDebugMarkerObjectTagInfoEXT"/>
+                <type name="VkDebugMarkerMarkerInfoEXT"/>
+                <command name="vkDebugMarkerSetObjectTagEXT"/>
+                <command name="vkDebugMarkerSetObjectNameEXT"/>
+                <command name="vkCmdDebugMarkerBeginEXT"/>
+                <command name="vkCmdDebugMarkerEndEXT"/>
+                <command name="vkCmdDebugMarkerInsertEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_queue" number="24" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_sampler_ycbcr_conversion" author="KHR" contact="Tony Zlatinski @tzlatinski" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_KHR_VIDEO_QUEUE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_queue&quot;"            name="VK_KHR_VIDEO_QUEUE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_PROFILE_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_GET_MEMORY_PROPERTIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_BIND_MEMORY_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="10" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="11" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="12" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_QUEUE_FAMILY_PROPERTIES_2_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="13" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_PROFILES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="14" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="15" extends="VkStructureType"             name="VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <enum offset="0"  extends="VkObjectType"                name="VK_OBJECT_TYPE_VIDEO_SESSION_KHR"             comment="VkVideoSessionKHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1"  extends="VkObjectType"                name="VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR"  comment="VkVideoSessionParametersKHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="4" extends="VkQueryResultFlagBits"        name="VK_QUERY_RESULT_WITH_STATUS_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoSessionKHR"/>
+                <type name="VkVideoSessionParametersKHR"/>
+
+                <type name="VkVideoCodecOperationFlagBitsKHR"/>
+                <type name="VkVideoCodecOperationFlagsKHR"/>
+                <type name="VkVideoChromaSubsamplingFlagBitsKHR"/>
+                <type name="VkVideoChromaSubsamplingFlagsKHR"/>
+                <type name="VkVideoComponentBitDepthFlagBitsKHR"/>
+                <type name="VkVideoComponentBitDepthFlagsKHR"/>
+                <type name="VkVideoCapabilityFlagBitsKHR"/>
+                <type name="VkVideoCapabilityFlagsKHR"/>
+                <type name="VkVideoSessionCreateFlagBitsKHR"/>
+                <type name="VkVideoSessionCreateFlagsKHR"/>
+                <type name="VkVideoBeginCodingFlagsKHR"/>
+                <type name="VkVideoEndCodingFlagsKHR"/>
+                <type name="VkVideoCodingControlFlagBitsKHR"/>
+                <type name="VkVideoCodingControlFlagsKHR"/>
+                <type name="VkVideoCodingQualityPresetFlagBitsKHR"/>
+                <type name="VkVideoCodingQualityPresetFlagsKHR"/>
+
+                <type name="VkQueryResultStatusKHR"/>
+
+                <type name="VkVideoQueueFamilyProperties2KHR"/>
+                <type name="VkVideoProfileKHR"/>
+                <type name="VkVideoProfilesKHR"/>
+                <type name="VkVideoCapabilitiesKHR"/>
+                <type name="VkPhysicalDeviceVideoFormatInfoKHR"/>
+                <type name="VkVideoFormatPropertiesKHR"/>
+                <type name="VkVideoPictureResourceKHR"/>
+                <type name="VkVideoReferenceSlotKHR"/>
+                <type name="VkVideoGetMemoryPropertiesKHR"/>
+                <type name="VkVideoBindMemoryKHR"/>
+                <type name="VkVideoSessionCreateInfoKHR"/>
+                <type name="VkVideoSessionParametersCreateInfoKHR"/>
+                <type name="VkVideoSessionParametersUpdateInfoKHR"/>
+                <type name="VkVideoBeginCodingInfoKHR"/>
+                <type name="VkVideoEndCodingInfoKHR"/>
+                <type name="VkVideoCodingControlInfoKHR"/>
+
+                <command name="vkGetPhysicalDeviceVideoCapabilitiesKHR"/>
+                <command name="vkGetPhysicalDeviceVideoFormatPropertiesKHR"/>
+
+                <command name="vkCreateVideoSessionKHR"/>
+                <command name="vkDestroyVideoSessionKHR"/>
+                <command name="vkGetVideoSessionMemoryRequirementsKHR"/>
+                <command name="vkBindVideoSessionMemoryKHR"/>
+                <command name="vkCreateVideoSessionParametersKHR"/>
+                <command name="vkUpdateVideoSessionParametersKHR"/>
+                <command name="vkDestroyVideoSessionParametersKHR"/>
+                <command name="vkCmdBeginVideoCodingKHR"/>
+                <command name="vkCmdEndVideoCodingKHR"/>
+                <command name="vkCmdControlVideoCodingKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_decode_queue" number="25" type="device" requires="VK_KHR_video_queue,VK_KHR_synchronization2" author="KHR" contact="jake.beju@amd.com" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_decode_queue&quot;"     name="VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="5" extends="VkQueueFlagBits"              name="VK_QUEUE_VIDEO_DECODE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="26" extends="VkPipelineStageFlagBits2KHR" name="VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="35" extends="VkAccessFlagBits2KHR"        name="VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS" />
+                <enum bitpos="36" extends="VkAccessFlagBits2KHR"        name="VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="13" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="14" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="10" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="11" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="12" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="25" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="26" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoDecodeFlagBitsKHR"/>
+                <type name="VkVideoDecodeFlagsKHR"/>
+
+                <type name="VkVideoDecodeInfoKHR"/>
+                <command name="vkCmdDecodeVideoKHR"/>
+            </require>
+            <require extension="VK_KHR_format_feature_flags2">
+                <enum bitpos="25" extends="VkFormatFeatureFlagBits2KHR"     name="VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="26" extends="VkFormatFeatureFlagBits2KHR"     name="VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_gcn_shader" number="26" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_GCN_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_gcn_shader&quot;"                     name="VK_AMD_GCN_SHADER_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_dedicated_allocation" number="27" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" deprecatedby="VK_KHR_dedicated_allocation">
+            <require>
+                <enum value="1"                                                 name="VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_dedicated_allocation&quot;"            name="VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV"/>
+                <type name="VkDedicatedAllocationImageCreateInfoNV"/>
+                <type name="VkDedicatedAllocationBufferCreateInfoNV"/>
+                <type name="VkDedicatedAllocationMemoryAllocateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_28" number="28" author="NV" contact="Piers Daniell @pdaniell-nv" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_EXT_EXTENSION_28_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_28&quot;"                   name="VK_EXT_EXTENSION_28_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_transform_feedback" number="29" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" specialuse="glemulation,d3demulation,devtools" supported="vulkan" requires="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_transform_feedback&quot;"             name="VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME"/>
+                <command name="vkCmdBindTransformFeedbackBuffersEXT"/>
+                <command name="vkCmdBeginTransformFeedbackEXT"/>
+                <command name="vkCmdEndTransformFeedbackEXT"/>
+                <command name="vkCmdBeginQueryIndexedEXT"/>
+                <command name="vkCmdEndQueryIndexedEXT"/>
+                <command name="vkCmdDrawIndirectByteCountEXT"/>
+
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT"/>
+
+                <enum offset="4" extends="VkQueryType"                          name="VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT"/>
+
+                <enum bitpos="11" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT"/>
+                <enum bitpos="12" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT"/>
+
+                <enum bitpos="25" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"/>
+                <enum bitpos="26" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"/>
+                <enum bitpos="27" extends="VkAccessFlagBits"                    name="VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"/>
+
+                <enum bitpos="24" extends="VkPipelineStageFlagBits"             name="VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT"/>
+
+                <type name="VkPhysicalDeviceTransformFeedbackFeaturesEXT"/>
+                <type name="VkPhysicalDeviceTransformFeedbackPropertiesEXT"/>
+                <type name="VkPipelineRasterizationStateStreamCreateInfoEXT"/>
+
+                <type name="VkPipelineRasterizationStateStreamCreateFlagsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_binary_import" number="30" type="device" author="NVX" contact="Eric Werness @ewerness-nv,Liam Middlebrook @liam-middlebrook" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NVX_BINARY_IMPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_binary_import&quot;"                  name="VK_NVX_BINARY_IMPORT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX"/>
+                <enum offset="0" extends="VkObjectType"                         name="VK_OBJECT_TYPE_CU_MODULE_NVX"/>
+                <enum offset="1" extends="VkObjectType"                         name="VK_OBJECT_TYPE_CU_FUNCTION_NVX"/>
+                <enum offset="0" extends="VkDebugReportObjectTypeEXT"           name="VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT"/>
+                <enum offset="1" extends="VkDebugReportObjectTypeEXT"           name="VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT"/>
+                <type name="VkCuModuleNVX"/>
+                <type name="VkCuFunctionNVX"/>
+                <type name="VkCuModuleCreateInfoNVX"/>
+                <type name="VkCuFunctionCreateInfoNVX"/>
+                <type name="VkCuLaunchInfoNVX"/>
+                <command name="vkCreateCuModuleNVX"/>
+                <command name="vkCreateCuFunctionNVX"/>
+                <command name="vkDestroyCuModuleNVX"/>
+                <command name="vkDestroyCuFunctionNVX"/>
+                <command name="vkCmdCuLaunchKernelNVX"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_image_view_handle" number="31" type="device" author="NVX" contact="Eric Werness @ewerness-nv" supported="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_image_view_handle&quot;"              name="VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX"/>
+                <type name="VkImageViewHandleInfoNVX"/>
+                <type name="VkImageViewAddressPropertiesNVX"/>
+                <command name="vkGetImageViewHandleNVX"/>
+                <command name="vkGetImageViewAddressNVX"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_32" number="32" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_32_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_32&quot;"                   name="VK_AMD_EXTENSION_32_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_33" number="33" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_33_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_33&quot;"                   name="VK_AMD_EXTENSION_33_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_draw_indirect_count" number="34" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_KHR_draw_indirect_count">
+            <require>
+                <enum value="2"                                                 name="VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_draw_indirect_count&quot;"            name="VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
+                <command name="vkCmdDrawIndirectCountAMD"/>
+                <command name="vkCmdDrawIndexedIndirectCountAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_35" number="35" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_35_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_35&quot;"                   name="VK_AMD_EXTENSION_35_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_negative_viewport_height" number="36" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" obsoletedby="VK_KHR_maintenance1">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_negative_viewport_height&quot;"       name="VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_gpu_shader_half_float" number="37" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8">
+            <require>
+                <enum value="2"                                                 name="VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_gpu_shader_half_float&quot;"          name="VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_ballot" number="38" type="device" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_BALLOT_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_ballot&quot;"                  name="VK_AMD_SHADER_BALLOT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_video_encode_h264" number="39" type="device" requires="VK_KHR_video_encode_queue" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_EXT_VIDEO_ENCODE_H264_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_video_encode_h264&quot;"              name="VK_EXT_VIDEO_ENCODE_H264_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_VCL_FRAME_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_EMIT_PICTURE_PARAMETERS_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="16" extends="VkVideoCodecOperationFlagBitsKHR"    name="VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoEncodeH264CapabilityFlagBitsEXT"/>
+                <type name="VkVideoEncodeH264CapabilityFlagsEXT"/>
+                <type name="VkVideoEncodeH264InputModeFlagBitsEXT"/>
+                <type name="VkVideoEncodeH264InputModeFlagsEXT"/>
+                <type name="VkVideoEncodeH264OutputModeFlagBitsEXT"/>
+                <type name="VkVideoEncodeH264OutputModeFlagsEXT"/>
+                <type name="VkVideoEncodeH264CreateFlagBitsEXT"/>
+                <type name="VkVideoEncodeH264CreateFlagsEXT"/>
+                <type name="VkVideoEncodeH264CapabilitiesEXT"/>
+                <type name="VkVideoEncodeH264SessionCreateInfoEXT"/>
+                <type name="VkVideoEncodeH264SessionParametersCreateInfoEXT"/>
+                <type name="VkVideoEncodeH264SessionParametersAddInfoEXT"/>
+                <type name="VkVideoEncodeH264VclFrameInfoEXT"/>
+                <type name="VkVideoEncodeH264EmitPictureParametersEXT"/>
+                <type name="VkVideoEncodeH264DpbSlotInfoEXT"/>
+                <type name="VkVideoEncodeH264NaluSliceEXT"/>
+                <type name="VkVideoEncodeH264ProfileEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_video_encode_h265" number="40" type="device" requires="VK_KHR_video_encode_queue" author="KHR" contact="Ahmed Abdelkhalek @aabdelkh" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="2"                                              name="VK_EXT_VIDEO_ENCODE_H265_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_video_encode_h265&quot;"           name="VK_EXT_VIDEO_ENCODE_H265_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_VCL_FRAME_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="7" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_EMIT_PICTURE_PARAMETERS_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="8" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="9" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_REFERENCE_LISTS_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="17" extends="VkVideoCodecOperationFlagBitsKHR" name="VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoEncodeH265CapabilityFlagsEXT"/>
+                <type name="VkVideoEncodeH265InputModeFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265InputModeFlagsEXT"/>
+                <type name="VkVideoEncodeH265OutputModeFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265OutputModeFlagsEXT"/>
+                <type name="VkVideoEncodeH265CreateFlagsEXT" comment="Will add VkVideoEncodeH265CreateFlagBitsEXT when bits are defined in the future"/>
+
+                <type name="VkVideoEncodeH265CtbSizeFlagBitsEXT"/>
+                <type name="VkVideoEncodeH265CtbSizeFlagsEXT"/>
+                <type name="VkVideoEncodeH265CapabilitiesEXT"/>
+                <type name="VkVideoEncodeH265SessionCreateInfoEXT"/>
+                <type name="VkVideoEncodeH265SessionParametersCreateInfoEXT"/>
+                <type name="VkVideoEncodeH265SessionParametersAddInfoEXT"/>
+                <type name="VkVideoEncodeH265VclFrameInfoEXT"/>
+                <type name="VkVideoEncodeH265EmitPictureParametersEXT"/>
+                <type name="VkVideoEncodeH265DpbSlotInfoEXT"/>
+                <type name="VkVideoEncodeH265NaluSliceEXT"/>
+                <type name="VkVideoEncodeH265ProfileEXT"/>
+                <type name="VkVideoEncodeH265ReferenceListsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_video_decode_h264" number="41" type="device" requires="VK_KHR_video_decode_queue" author="KHR" contact="peter.fang@amd.com" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="3"                                              name="VK_EXT_VIDEO_DECODE_H264_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_video_decode_h264&quot;"           name="VK_EXT_VIDEO_DECODE_H264_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_MVC_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="7" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="0" extends="VkVideoCodecOperationFlagBitsKHR"  name="VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <type name="VkVideoDecodeH264PictureLayoutFlagBitsEXT"/>
+                <type name="VkVideoDecodeH264PictureLayoutFlagsEXT"/>
+                <type name="VkVideoDecodeH264CreateFlagsEXT"/>
+                <type name="VkVideoDecodeH264ProfileEXT"/>
+                <type name="VkVideoDecodeH264CapabilitiesEXT"/>
+                <type name="VkVideoDecodeH264SessionCreateInfoEXT"/>
+                <type name="VkVideoDecodeH264SessionParametersCreateInfoEXT"/>
+                <type name="VkVideoDecodeH264SessionParametersAddInfoEXT"/>
+                <type name="VkVideoDecodeH264PictureInfoEXT"/>
+                <type name="VkVideoDecodeH264MvcEXT"/>
+                <type name="VkVideoDecodeH264DpbSlotInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_texture_gather_bias_lod" number="42" author="AMD" contact="Rex Xu @amdrexu" supported="vulkan" type="device" requires="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_texture_gather_bias_lod&quot;"        name="VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD"/>
+                <type name="VkTextureLODGatherFormatPropertiesAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_info" number="43" author="AMD" contact="Jaakko Konttinen @jaakkoamd" supported="vulkan" specialuse="devtools" type="device">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_info&quot;"                    name="VK_AMD_SHADER_INFO_EXTENSION_NAME"/>
+                <type name="VkShaderInfoTypeAMD"/>
+                <type name="VkShaderResourceUsageAMD"/>
+                <type name="VkShaderStatisticsInfoAMD"/>
+                <command name="vkGetShaderInfoAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_44" number="44" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_44_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_44&quot;"                   name="VK_AMD_EXTENSION_44_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_dynamic_rendering" number="45" author="KHR" type="device" requires="VK_KHR_get_physical_device_properties2" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_dynamic_rendering&quot;"              name="VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME"/>
+                <command name="vkCmdBeginRenderingKHR"/>
+                <command name="vkCmdEndRenderingKHR"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_RENDERING_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR"/>
+                <enum offset="4" extends="VkStructureType" name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR"/>
+                <enum offset="0" extends="VkAttachmentStoreOp" extnumber="302" name="VK_ATTACHMENT_STORE_OP_NONE_KHR"/>
+                <type name="VkRenderingInfoKHR"/>
+                <type name="VkRenderingAttachmentInfoKHR"/>
+                <type name="VkPipelineRenderingCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceDynamicRenderingFeaturesKHR"/>
+                <type name="VkCommandBufferInheritanceRenderingInfoKHR"/>
+                <type name="VkRenderingFlagsKHR"/>
+                <type name="VkRenderingFlagBitsKHR"/>
+            </require>
+            <require extension="VK_KHR_fragment_shading_rate">
+                <enum bitpos="21" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum offset="6" extends="VkStructureType" name="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"/>
+                <type name="VkRenderingFragmentShadingRateAttachmentInfoKHR"/>
+            </require>
+            <require extension="VK_EXT_fragment_density_map">
+                <enum bitpos="22" extends="VkPipelineCreateFlagBits" name="VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT"/>
+                <enum offset="7" extends="VkStructureType" name="VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT"/>
+                <type name="VkRenderingFragmentDensityMapAttachmentInfoEXT"/>
+            </require>
+            <require extension="VK_AMD_mixed_attachment_samples">
+                <enum offset="8" extends="VkStructureType" name="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"/>
+                <type name="VkAttachmentSampleCountInfoAMD"/>
+            </require>
+            <require extension="VK_NV_framebuffer_mixed_samples">
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV" alias="VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD"/>
+                <type name="VkAttachmentSampleCountInfoNV"/>
+            </require>
+            <require extension="VK_NVX_multiview_per_view_attributes">
+                <enum offset="9" extends="VkStructureType" name="VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX"/>
+                <type name="VkMultiviewPerViewAttributesInfoNVX"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_46" number="46" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_AMD_EXTENSION_46_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_46&quot;"                   name="VK_AMD_EXTENSION_46_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_image_load_store_lod" number="47" author="AMD" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan" type="device">
+            <require>
+                <enum value="1"                                                 name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_image_load_store_lod&quot;"    name="VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_extension_48" number="48" author="NVX" contact="James Jones @cubanismo" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_NVX_EXTENSION_48_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_extension_48&quot;"                   name="VK_NVX_EXTENSION_48_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_49" number="49" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_GOOGLE_EXTENSION_49_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_49&quot;"                name="VK_GOOGLE_EXTENSION_49_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_stream_descriptor_surface" number="50" type="instance" requires="VK_KHR_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_stream_descriptor_surface&quot;"      name="VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP"/>
+                <type name="VkStreamDescriptorSurfaceCreateFlagsGGP"/>
+                <type name="VkStreamDescriptorSurfaceCreateInfoGGP"/>
+                <command name="vkCreateStreamDescriptorSurfaceGGP"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_corner_sampled_image" number="51" author="NV" type="device" requires="VK_KHR_get_physical_device_properties2" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_corner_sampled_image&quot;"            name="VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME"/>
+                <enum bitpos="13" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceCornerSampledImageFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_52" number="52" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_NV_EXTENSION_52_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_52&quot;"                    name="VK_NV_EXTENSION_52_EXTENSION_NAME"/>
+                <enum bitpos="0" extends="VkShaderModuleCreateFlagBits"         name="VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV"/>
+                <enum bitpos="2" extends="VkPipelineShaderStageCreateFlagBits"  name="VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_53" number="53" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_NV_EXTENSION_53_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_53&quot;"                    name="VK_NV_EXTENSION_53_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_multiview" number="54" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_MULTIVIEW_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_multiview&quot;"                      name="VK_KHR_MULTIVIEW_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"/>
+                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR" alias="VK_DEPENDENCY_VIEW_LOCAL_BIT"/>
+                <type name="VkRenderPassMultiviewCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceMultiviewFeaturesKHR"/>
+                <type name="VkPhysicalDeviceMultiviewPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_format_pvrtc" number="55" type="device" author="IMG" contact="Stuart Smith" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_IMG_FORMAT_PVRTC_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_format_pvrtc&quot;"                   name="VK_IMG_FORMAT_PVRTC_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="1" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="2" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="3" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG"/>
+                <enum offset="4" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG"/>
+                <enum offset="5" extends="VkFormat"                             name="VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG"/>
+                <enum offset="6" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG"/>
+                <enum offset="7" extends="VkFormat"                             name="VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory_capabilities" number="56" type="instance" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory_capabilities">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory_capabilities&quot;"    name="VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
+                <type name="VkExternalMemoryHandleTypeFlagsNV"/>
+                <type name="VkExternalMemoryHandleTypeFlagBitsNV"/>
+                <type name="VkExternalMemoryFeatureFlagsNV"/>
+                <type name="VkExternalMemoryFeatureFlagBitsNV"/>
+                <type name="VkExternalImageFormatPropertiesNV"/>
+                <command name="vkGetPhysicalDeviceExternalImageFormatPropertiesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory" number="57" type="device" requires="VK_NV_external_memory_capabilities" author="NV" contact="James Jones @cubanismo" supported="vulkan" deprecatedby="VK_KHR_external_memory">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory&quot;"                 name="VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV"/>
+                <type name="VkExternalMemoryImageCreateInfoNV"/>
+                <type name="VkExportMemoryAllocateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory_win32" number="58" type="device" requires="VK_NV_external_memory" author="NV" contact="James Jones @cubanismo" platform="win32" supported="vulkan" deprecatedby="VK_KHR_external_memory_win32">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory_win32&quot;"           name="VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV"/>
+                <type name="VkImportMemoryWin32HandleInfoNV"/>
+                <type name="VkExportMemoryWin32HandleInfoNV"/>
+                <command name="vkGetMemoryWin32HandleNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_win32_keyed_mutex" number="59" type="device" requires="VK_NV_external_memory_win32" author="NV" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan" promotedto="VK_KHR_win32_keyed_mutex">
+            <require>
+                <enum value="2"                                                 name="VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_win32_keyed_mutex&quot;"               name="VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV"/>
+                <type name="VkWin32KeyedMutexAcquireReleaseInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_physical_device_properties2" number="60" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="2"                                                 name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_physical_device_properties2&quot;" name="VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2"/>
+                <type name="VkPhysicalDeviceFeatures2KHR"/>
+                <type name="VkPhysicalDeviceProperties2KHR"/>
+                <type name="VkFormatProperties2KHR"/>
+                <type name="VkImageFormatProperties2KHR"/>
+                <type name="VkPhysicalDeviceImageFormatInfo2KHR"/>
+                <type name="VkQueueFamilyProperties2KHR"/>
+                <type name="VkPhysicalDeviceMemoryProperties2KHR"/>
+                <type name="VkSparseImageFormatProperties2KHR"/>
+                <type name="VkPhysicalDeviceSparseImageFormatInfo2KHR"/>
+                <command name="vkGetPhysicalDeviceFeatures2KHR"/>
+                <command name="vkGetPhysicalDeviceProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceFormatProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceImageFormatProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceQueueFamilyProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceMemoryProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceSparseImageFormatProperties2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_device_group" number="61" type="device" author="KHR" requires="VK_KHR_device_group_creation" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="4"                                                 name="VK_KHR_DEVICE_GROUP_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_device_group&quot;"                   name="VK_KHR_DEVICE_GROUP_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO"/>
+                <type name="VkPeerMemoryFeatureFlagsKHR"/>
+                <type name="VkPeerMemoryFeatureFlagBitsKHR"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_COPY_DST_BIT"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT"/>
+                <enum extends="VkPeerMemoryFeatureFlagBits"                     name="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR" alias="VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT"/>
+                <type name="VkMemoryAllocateFlagsKHR"/>
+                <type name="VkMemoryAllocateFlagBitsKHR"/>
+                <enum extends="VkMemoryAllocateFlagBits"                        name="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT"/>
+                <type name="VkMemoryAllocateFlagsInfoKHR"/>
+                <type name="VkDeviceGroupRenderPassBeginInfoKHR"/>
+                <type name="VkDeviceGroupCommandBufferBeginInfoKHR"/>
+                <type name="VkDeviceGroupSubmitInfoKHR"/>
+                <type name="VkDeviceGroupBindSparseInfoKHR"/>
+                <command name="vkGetDeviceGroupPeerMemoryFeaturesKHR"/>
+                <command name="vkCmdSetDeviceMaskKHR"/>
+                <command name="vkCmdDispatchBaseKHR"/>
+                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR" alias="VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT"/>
+                <enum extends="VkPipelineCreateFlagBits"                        name="VK_PIPELINE_CREATE_DISPATCH_BASE_KHR" alias="VK_PIPELINE_CREATE_DISPATCH_BASE"/>
+                <enum extends="VkDependencyFlagBits"                            name="VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR" alias="VK_DEPENDENCY_DEVICE_GROUP_BIT"/>
+            </require>
+            <require extension="VK_KHR_bind_memory2">
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO"/>
+                <type name="VkBindBufferMemoryDeviceGroupInfoKHR"/>
+                <type name="VkBindImageMemoryDeviceGroupInfoKHR"/>
+                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" alias="VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
+            </require>
+            <require extension="VK_KHR_surface">
+                <enum offset="7" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR"/>
+                <type name="VkDeviceGroupPresentModeFlagBitsKHR"/>
+                <type name="VkDeviceGroupPresentModeFlagsKHR"/>
+                <type name="VkDeviceGroupPresentCapabilitiesKHR"/>
+                <command name="vkGetDeviceGroupPresentCapabilitiesKHR"/>
+                <command name="vkGetDeviceGroupSurfacePresentModesKHR"/>
+                <command name="vkGetPhysicalDevicePresentRectanglesKHR"/>
+            </require>
+            <require extension="VK_KHR_swapchain">
+                <enum offset="8" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum offset="9" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR"/>
+                <enum offset="10" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR"/>
+                <enum offset="11" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR"/>
+                <enum offset="12" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR"/>
+                <enum bitpos="0" extends="VkSwapchainCreateFlagBitsKHR"         name="VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR" comment="Allow images with VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT"/>
+                <type name="VkImageSwapchainCreateInfoKHR"/>
+                <type name="VkBindImageMemorySwapchainInfoKHR"/>
+                <type name="VkAcquireNextImageInfoKHR"/>
+                <type name="VkDeviceGroupPresentInfoKHR"/>
+                <type name="VkDeviceGroupSwapchainCreateInfoKHR"/>
+                <command name="vkAcquireNextImage2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_validation_flags" number="62" type="instance" author="GOOGLE" contact="Tobin Ehlis @tobine" specialuse="debugging" supported="vulkan" deprecatedby="VK_EXT_validation_features">
+            <require>
+                <enum value="2"                                                 name="VK_EXT_VALIDATION_FLAGS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_validation_flags&quot;"               name="VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT"/>
+                <type name="VkValidationFlagsEXT"/>
+                <type name="VkValidationCheckEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NN_vi_surface" number="63" type="instance" author="NN" contact="Mathias Heyer gitlab:@mheyer" requires="VK_KHR_surface" platform="vi" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NN_VI_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NN_vi_surface&quot;"                      name="VK_NN_VI_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN"/>
+                <type name="VkViSurfaceCreateFlagsNN"/>
+                <type name="VkViSurfaceCreateInfoNN"/>
+                <command name="vkCreateViSurfaceNN"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_draw_parameters" number="64" type="device" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_draw_parameters&quot;"         name="VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_subgroup_ballot" number="65" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" deprecatedby="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_subgroup_ballot&quot;"         name="VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_subgroup_vote" number="66" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" deprecatedby="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_subgroup_vote&quot;"           name="VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_texture_compression_astc_hdr" number="67" type="device" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" requires="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_texture_compression_astc_hdr&quot;"   name="VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="0" name="VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="1" name="VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="2" name="VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="3" name="VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="4" name="VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="5" name="VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="6" name="VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="7" name="VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="8" name="VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="9" name="VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="10" name="VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="11" name="VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="12" name="VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="67" offset="13" name="VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_astc_decode_mode" number="68" type="device" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" requires="VK_KHR_get_physical_device_properties2" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_astc_decode_mode&quot;"               name="VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"/>
+                <type name="VkImageViewASTCDecodeModeEXT"/>
+                <type name="VkPhysicalDeviceASTCDecodeFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_extension_69" number="69" type="device" author="IMG" contact="Tobias Hector @tobski" supported="disabled">
+            <require>
+                <enum value="0"                                                 name="VK_IMG_EXTENSION_69_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_extension_69&quot;"                   name="VK_IMG_EXTENSION_69_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance1" number="70" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="2"                                                 name="VK_KHR_MAINTENANCE_1_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance1&quot;"                   name="VK_KHR_MAINTENANCE_1_EXTENSION_NAME"/>
+                <enum alias="VK_KHR_MAINTENANCE_1_SPEC_VERSION"                 name="VK_KHR_MAINTENANCE1_SPEC_VERSION" comment="Backwards-compatible alias containing a typo"/>
+                <enum alias="VK_KHR_MAINTENANCE_1_EXTENSION_NAME"               name="VK_KHR_MAINTENANCE1_EXTENSION_NAME" comment="Backwards-compatible alias containing a typo"/>
+                <enum extends="VkResult"                                        name="VK_ERROR_OUT_OF_POOL_MEMORY_KHR" alias="VK_ERROR_OUT_OF_POOL_MEMORY"/>
+                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_SRC_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                         name="VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR" alias="VK_FORMAT_FEATURE_TRANSFER_DST_BIT"/>
+                <enum extends="VkImageCreateFlagBits"                           name="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT"/>
+                <type name="VkCommandPoolTrimFlagsKHR"/>
+                <command name="vkTrimCommandPoolKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_device_group_creation" number="71" type="instance" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_device_group_creation&quot;"          name="VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO"/>
+                <enum name="VK_MAX_DEVICE_GROUP_SIZE_KHR"/>
+                <type name="VkPhysicalDeviceGroupPropertiesKHR"/>
+                <type name="VkDeviceGroupDeviceCreateInfoKHR"/>
+                <command name="vkEnumeratePhysicalDeviceGroupsKHR"/>
+                <enum extends="VkMemoryHeapFlagBits"                            name="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR" alias="VK_MEMORY_HEAP_MULTI_INSTANCE_BIT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory_capabilities" number="72" type="instance" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory_capabilities&quot;"   name="VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+                <enum name="VK_LUID_SIZE_KHR"/>
+                <type name="VkExternalMemoryHandleTypeFlagsKHR"/>
+                <type name="VkExternalMemoryHandleTypeFlagBitsKHR"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT"/>
+                <enum extends="VkExternalMemoryHandleTypeFlagBits"              name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT"/>
+                <type name="VkExternalMemoryFeatureFlagsKHR"/>
+                <type name="VkExternalMemoryFeatureFlagBitsKHR"/>
+                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT"/>
+                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT"/>
+                <enum extends="VkExternalMemoryFeatureFlagBits"                 name="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT"/>
+                <type name="VkExternalMemoryPropertiesKHR"/>
+                <type name="VkPhysicalDeviceExternalImageFormatInfoKHR"/>
+                <type name="VkExternalImageFormatPropertiesKHR"/>
+                <type name="VkPhysicalDeviceExternalBufferInfoKHR"/>
+                <type name="VkExternalBufferPropertiesKHR"/>
+                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceExternalBufferPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory" number="73" type="device" requires="VK_KHR_external_memory_capabilities" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory&quot;"                name="VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO"/>
+                <enum extends="VkResult"                                        name="VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR" alias="VK_ERROR_INVALID_EXTERNAL_HANDLE"/>
+                <enum name="VK_QUEUE_FAMILY_EXTERNAL_KHR"/>
+                <type name="VkExternalMemoryImageCreateInfoKHR"/>
+                <type name="VkExternalMemoryBufferCreateInfoKHR"/>
+                <type name="VkExportMemoryAllocateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory_win32" number="74" type="device" requires="VK_KHR_external_memory" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory_win32&quot;"          name="VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR"/>
+                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR"/>
+                <type name="VkImportMemoryWin32HandleInfoKHR"/>
+                <type name="VkExportMemoryWin32HandleInfoKHR"/>
+                <type name="VkMemoryWin32HandlePropertiesKHR"/>
+                <type name="VkMemoryGetWin32HandleInfoKHR"/>
+                <command name="vkGetMemoryWin32HandleKHR"/>
+                <command name="vkGetMemoryWin32HandlePropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_memory_fd" number="75" type="device" requires="VK_KHR_external_memory" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_memory_fd&quot;"             name="VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR"/>
+                <type name="VkImportMemoryFdInfoKHR"/>
+                <type name="VkMemoryFdPropertiesKHR"/>
+                <type name="VkMemoryGetFdInfoKHR"/>
+                <command name="vkGetMemoryFdKHR"/>
+                <command name="vkGetMemoryFdPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_win32_keyed_mutex" number="76" type="device" requires="VK_KHR_external_memory_win32" author="KHR" contact="Carsten Rohde @crohde" platform="win32" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_win32_keyed_mutex&quot;"              name="VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR"/>
+                <type name="VkWin32KeyedMutexAcquireReleaseInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore_capabilities" number="77" type="instance" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore_capabilities&quot;" name="VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO"/>
+                <enum extends="VkStructureType"                                 name="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+                <enum name="VK_LUID_SIZE_KHR"/>
+                <type name="VkExternalSemaphoreHandleTypeFlagsKHR"/>
+                <type name="VkExternalSemaphoreHandleTypeFlagBitsKHR"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT"/>
+                <enum extends="VkExternalSemaphoreHandleTypeFlagBits"       name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT"/>
+                <type name="VkExternalSemaphoreFeatureFlagsKHR"/>
+                <type name="VkExternalSemaphoreFeatureFlagBitsKHR"/>
+                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT"/>
+                <enum extends="VkExternalSemaphoreFeatureFlagBits"          name="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT"/>
+                <type name="VkPhysicalDeviceExternalSemaphoreInfoKHR"/>
+                <type name="VkExternalSemaphorePropertiesKHR"/>
+                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore" number="78" type="device" requires="VK_KHR_external_semaphore_capabilities" author="KHR" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore&quot;"         name="VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO"/>
+                <type name="VkSemaphoreImportFlagsKHR"/>
+                <type name="VkSemaphoreImportFlagBitsKHR"/>
+                <enum extends="VkSemaphoreImportFlagBits"                   name="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_SEMAPHORE_IMPORT_TEMPORARY_BIT"/>
+                <type name="VkExportSemaphoreCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore_win32" number="79" type="device" requires="VK_KHR_external_semaphore" author="KHR" contact="James Jones @cubanismo" platform="win32" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore_win32&quot;"   name="VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR"/>
+                <type name="VkImportSemaphoreWin32HandleInfoKHR"/>
+                <type name="VkExportSemaphoreWin32HandleInfoKHR"/>
+                <type name="VkD3D12FenceSubmitInfoKHR"/>
+                <type name="VkSemaphoreGetWin32HandleInfoKHR"/>
+                <command name="vkImportSemaphoreWin32HandleKHR"/>
+                <command name="vkGetSemaphoreWin32HandleKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_semaphore_fd" number="80" type="device" requires="VK_KHR_external_semaphore" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_semaphore_fd&quot;"      name="VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR"/>
+                <type name="VkImportSemaphoreFdInfoKHR"/>
+                <type name="VkSemaphoreGetFdInfoKHR"/>
+                <command name="vkImportSemaphoreFdKHR"/>
+                <command name="vkGetSemaphoreFdKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_push_descriptor" number="81" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_push_descriptor&quot;"            name="VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR"/>
+                <enum bitpos="0" extends="VkDescriptorSetLayoutCreateFlagBits"   name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR"  comment="Descriptors are pushed via flink:vkCmdPushDescriptorSetKHR"/>
+                <command name="vkCmdPushDescriptorSetKHR"/>
+                <type name="VkPhysicalDevicePushDescriptorPropertiesKHR"/>
+            </require>
+            <require feature="VK_VERSION_1_1">
+                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
+                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
+            </require>
+            <require extension="VK_KHR_descriptor_update_template">
+                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
+                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_conditional_rendering" number="82" type="device" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_conditional_rendering&quot;"      name="VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT"/>
+                <type name="VkConditionalRenderingFlagsEXT"/>
+                <type name="VkConditionalRenderingFlagBitsEXT"/>
+                <enum bitpos="20" extends="VkAccessFlagBits"                name="VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT"  comment="read access flag for reading conditional rendering predicate"/>
+                <enum bitpos="9"  extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT" comment="Specifies the buffer can be used as predicate in conditional rendering"/>
+                <enum bitpos="18" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT" comment="A pipeline stage for conditional rendering predicate fetch"/>
+                <command name="vkCmdBeginConditionalRenderingEXT"/>
+                <command name="vkCmdEndConditionalRenderingEXT"/>
+                <type name="VkConditionalRenderingBeginInfoEXT"/>
+                <type name="VkPhysicalDeviceConditionalRenderingFeaturesEXT"/>
+                <type name="VkCommandBufferInheritanceConditionalRenderingInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_float16_int8" number="83" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_float16_int8&quot;"        name="VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"/>
+                <type name="VkPhysicalDeviceFloat16Int8FeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_16bit_storage" number="84" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_storage_buffer_storage_class" author="KHR" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_16BIT_STORAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_16bit_storage&quot;"              name="VK_KHR_16BIT_STORAGE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"/>
+                <type name="VkPhysicalDevice16BitStorageFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_incremental_present" number="85" type="device" author="KHR" requires="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_incremental_present&quot;"        name="VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR"/>
+                <type name="VkPresentRegionsKHR"/>
+                <type name="VkPresentRegionKHR"/>
+                <type name="VkRectLayerKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_descriptor_update_template" number="86" type="device" author="KHR" contact="Markus Tavenrath @mtavenrath" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_descriptor_update_template&quot;" name="VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO"/>
+                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR" alias="VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE"/>
+                <command name="vkCreateDescriptorUpdateTemplateKHR"/>
+                <command name="vkDestroyDescriptorUpdateTemplateKHR"/>
+                <command name="vkUpdateDescriptorSetWithTemplateKHR"/>
+                <type name="VkDescriptorUpdateTemplateKHR"/>
+                <type name="VkDescriptorUpdateTemplateCreateFlagsKHR"/>
+                <type name="VkDescriptorUpdateTemplateTypeKHR"/>
+                <type name="VkDescriptorUpdateTemplateEntryKHR"/>
+                <type name="VkDescriptorUpdateTemplateCreateInfoKHR"/>
+                <enum extends="VkDescriptorUpdateTemplateType"              name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR" alias="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET"/>
+            </require>
+            <require extension="VK_KHR_push_descriptor">
+                <command name="vkCmdPushDescriptorSetWithTemplateKHR"/>
+                <enum value="1" extends="VkDescriptorUpdateTemplateType"    name="VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR" comment="Create descriptor update template for pushed descriptor updates"/>
+            </require>
+            <require extension="VK_EXT_debug_report">
+                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_device_generated_commands" number="87" type="device" author="NVX" contact="Christoph Kubisch @pixeljetstream" supported="disabled">
+            <require>
+                <enum value="3"                                             name="VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_device_generated_commands&quot;"  name="VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_clip_space_w_scaling" number="88" type="device" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_clip_space_w_scaling&quot;"        name="VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV"/>
+                <type name="VkViewportWScalingNV"/>
+                <type name="VkPipelineViewportWScalingStateCreateInfoNV"/>
+                <command name="vkCmdSetViewportWScalingNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_direct_mode_display" number="89" type="instance" requires="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_direct_mode_display&quot;"        name="VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkReleaseDisplayEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_acquire_xlib_display" number="90" type="instance" requires="VK_EXT_direct_mode_display" author="NV" contact="James Jones @cubanismo" platform="xlib_xrandr" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_acquire_xlib_display&quot;"       name="VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkAcquireXlibDisplayEXT"/>
+                <command name="vkGetRandROutputDisplayEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_display_surface_counter" number="91" type="instance" requires="VK_KHR_display" author="NV" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_display_surface_counter&quot;"    name="VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME"/>
+                <enum offset="0"                                           extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT"/>
+                <enum alias="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT" extends="VkStructureType" name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT" comment="Backwards-compatible alias containing a typo"/>
+                <type name="VkSurfaceCounterFlagsEXT"/>
+                <type name="VkSurfaceCounterFlagBitsEXT"/>
+                <type name="VkSurfaceCapabilities2EXT"/>
+                <command name="vkGetPhysicalDeviceSurfaceCapabilities2EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_display_control" number="92" type="device" requires="VK_EXT_display_surface_counter,VK_KHR_swapchain" author="NV" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DISPLAY_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_display_control&quot;"            name="VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT"/>
+                <type name="VkDisplayPowerStateEXT"/>
+                <type name="VkDeviceEventTypeEXT"/>
+                <type name="VkDisplayEventTypeEXT"/>
+                <type name="VkDisplayPowerInfoEXT"/>
+                <type name="VkDeviceEventInfoEXT"/>
+                <type name="VkDisplayEventInfoEXT"/>
+                <type name="VkSwapchainCounterCreateInfoEXT"/>
+                <command name="vkDisplayPowerControlEXT"/>
+                <command name="vkRegisterDeviceEventEXT"/>
+                <command name="vkRegisterDisplayEventEXT"/>
+                <command name="vkGetSwapchainCounterEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_display_timing" number="93" type="device" author="GOOGLE" requires="VK_KHR_swapchain" contact="Ian Elliott @ianelliottus" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_display_timing&quot;"          name="VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE"/>
+                <type name="VkRefreshCycleDurationGOOGLE"/>
+                <type name="VkPastPresentationTimingGOOGLE"/>
+                <type name="VkPresentTimesInfoGOOGLE"/>
+                <type name="VkPresentTimeGOOGLE"/>
+                <command name="vkGetRefreshCycleDurationGOOGLE"/>
+                <command name="vkGetPastPresentationTimingGOOGLE"/>
+            </require>
+        </extension>
+        <extension name="VK_RESERVED_do_not_use_94" number="94" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
+            <require>
+                <enum value="1"                                             name="VK_RESERVED_DO_NOT_USE_94_SPEC_VERSION"/>
+                <enum value="&quot;VK_RESERVED_do_not_use_94&quot;"         name="VK_RESERVED_DO_NOT_USE_94_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_sample_mask_override_coverage" number="95" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_sample_mask_override_coverage&quot;" name="VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME"/>
+                <comment>
+                    enum offset=0 was mistakenly used for the 1.1 core enum
+                    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES
+                    (value=1000094000). Fortunately, no conflict resulted.
+                </comment>
+            </require>
+        </extension>
+        <extension name="VK_NV_geometry_shader_passthrough" number="96" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_geometry_shader_passthrough&quot;" name="VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_viewport_array2" number="97" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_viewport_array2&quot;"             name="VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME"/>
+                <enum alias="VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION"           name="VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION" comment="Backwards-compatible alias containing a typo"/>
+                <enum alias="VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME"         name="VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME" comment="Backwards-compatible alias containing a typo"/>
+            </require>
+        </extension>
+        <extension name="VK_NVX_multiview_per_view_attributes" number="98" type="device" requires="VK_KHR_multiview" author="NVX" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NVX_multiview_per_view_attributes&quot;" name="VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"/>
+                <enum bitpos="0" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX"/>
+                <enum bitpos="1" extends="VkSubpassDescriptionFlagBits"     name="VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX"/>
+                <type name="VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_viewport_swizzle" number="99" type="device" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_viewport_swizzle&quot;"            name="VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV"/>
+                <type name="VkViewportSwizzleNV"/>
+                <type name="VkViewportCoordinateSwizzleNV"/>
+                <type name="VkPipelineViewportSwizzleStateCreateInfoNV"/>
+                <type name="VkPipelineViewportSwizzleStateCreateFlagsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_discard_rectangles" number="100" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_discard_rectangles&quot;"         name="VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT"/>
+                <type name="VkPhysicalDeviceDiscardRectanglePropertiesEXT"/>
+                <type name="VkPipelineDiscardRectangleStateCreateInfoEXT"/>
+                <type name="VkPipelineDiscardRectangleStateCreateFlagsEXT"/>
+                <type name="VkDiscardRectangleModeEXT"/>
+                <command name="vkCmdSetDiscardRectangleEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_101" number="101" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_101_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_101&quot;"               name="VK_NV_EXTENSION_101_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_conservative_rasterization" number="102" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_conservative_rasterization&quot;" name="VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceConservativeRasterizationPropertiesEXT"/>
+                <type name="VkPipelineRasterizationConservativeStateCreateInfoEXT"/>
+                <type name="VkPipelineRasterizationConservativeStateCreateFlagsEXT"/>
+                <type name="VkConservativeRasterizationModeEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_depth_clip_enable" number="103" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" specialuse="d3demulation" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_depth_clip_enable&quot;"          name="VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceDepthClipEnableFeaturesEXT"/>
+                <type name="VkPipelineRasterizationDepthClipStateCreateInfoEXT"/>
+                <type name="VkPipelineRasterizationDepthClipStateCreateFlagsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_104" number="104" author="NV" contact="Mathias Schott gitlab:@mschott" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_104_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_104&quot;"               name="VK_NV_EXTENSION_104_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_swapchain_colorspace" number="105" type="instance" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" requires="VK_KHR_surface" supported="vulkan">
+            <require>
+                <enum value="4"                                             name="VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_swapchain_colorspace&quot;"       name="VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME"/>
+                <enum offset="1" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT"/>
+                <enum offset="2" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT"/>
+                <enum offset="3" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT"/>
+                <enum offset="4" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT"/>
+                <enum offset="5" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_LINEAR_EXT"/>
+                <enum offset="6" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT709_NONLINEAR_EXT"/>
+                <enum offset="7" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_BT2020_LINEAR_EXT"/>
+                <enum offset="8" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_HDR10_ST2084_EXT"/>
+                <enum offset="9" extends="VkColorSpaceKHR"                  name="VK_COLOR_SPACE_DOLBYVISION_EXT"/>
+                <enum offset="10" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_HDR10_HLG_EXT"/>
+                <enum offset="11" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT"/>
+                <enum offset="12" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT"/>
+                <enum offset="13" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_PASS_THROUGH_EXT"/>
+                <enum offset="14" extends="VkColorSpaceKHR"                 name="VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT"/>
+                <enum extends="VkColorSpaceKHR"                             name="VK_COLOR_SPACE_DCI_P3_LINEAR_EXT" alias="VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT" comment="Deprecated name for backwards compatibility"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_hdr_metadata" number="106" type="device" requires="VK_KHR_swapchain" author="GOOGLE" contact="Courtney Goeltzenleuchter @courtney-g" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_HDR_METADATA_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_hdr_metadata&quot;"               name="VK_EXT_HDR_METADATA_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_HDR_METADATA_EXT"/>
+                <type name="VkHdrMetadataEXT"/>
+                <type name="VkXYColorEXT"/>
+                <command name="vkSetHdrMetadataEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_extension_107" number="107" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_IMG_EXTENSION_107_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_extension_107&quot;"              name="VK_IMG_EXTENSION_107_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_extension_108" number="108" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_IMG_EXTENSION_108_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_extension_108&quot;"              name="VK_IMG_EXTENSION_108_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_imageless_framebuffer" requires="VK_KHR_maintenance2,VK_KHR_image_format_list" number="109" author="KHR" contact="Tobias Hector @tobias" type="device" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_imageless_framebuffer&quot;"      name="VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME"/>
+                <type name="VkPhysicalDeviceImagelessFramebufferFeaturesKHR"/>
+                <type name="VkFramebufferAttachmentsCreateInfoKHR"/>
+                <type name="VkFramebufferAttachmentImageInfoKHR"/>
+                <type name="VkRenderPassAttachmentBeginInfoKHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR" alias="VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO"/>
+                <enum extends="VkFramebufferCreateFlagBits"                 name="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR" alias="VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_create_renderpass2" requires="VK_KHR_multiview,VK_KHR_maintenance2" number="110" contact="Tobias Hector @tobias" type="device" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_create_renderpass2&quot;"         name="VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_END_INFO"/>
+                <command name="vkCreateRenderPass2KHR"/>
+                <command name="vkCmdBeginRenderPass2KHR"/>
+                <command name="vkCmdNextSubpass2KHR"/>
+                <command name="vkCmdEndRenderPass2KHR"/>
+                <type name="VkRenderPassCreateInfo2KHR"/>
+                <type name="VkAttachmentDescription2KHR"/>
+                <type name="VkAttachmentReference2KHR"/>
+                <type name="VkSubpassDescription2KHR"/>
+                <type name="VkSubpassDependency2KHR"/>
+                <type name="VkSubpassBeginInfoKHR"/>
+                <type name="VkSubpassEndInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_IMG_extension_111" number="111" author="IMG" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_IMG_EXTENSION_111_SPEC_VERSION"/>
+                <enum value="&quot;VK_IMG_extension_111&quot;"              name="VK_IMG_EXTENSION_111_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shared_presentable_image" number="112" type="device" requires="VK_KHR_swapchain,VK_KHR_get_physical_device_properties2,VK_KHR_get_surface_capabilities2" author="KHR" contact="Alon Or-bach @alonorbach" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shared_presentable_image&quot;"   name="VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR"/>
+                <enum offset="0" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR"/>
+                <enum offset="1" extends="VkPresentModeKHR"                 name="VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR"/>
+                <enum offset="0" extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR"/>
+                <type name="VkSharedPresentSurfaceCapabilitiesKHR"/>
+                <command name="vkGetSwapchainStatusKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence_capabilities" number="113" type="instance" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence_capabilities&quot;" name="VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"/>
+                <enum name="VK_LUID_SIZE_KHR"/>
+                <type name="VkExternalFenceHandleTypeFlagsKHR"/>
+                <type name="VkExternalFenceHandleTypeFlagBitsKHR"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT"/>
+                <enum extends="VkExternalFenceHandleTypeFlagBits"           name="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR" alias="VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT"/>
+                <type name="VkExternalFenceFeatureFlagsKHR"/>
+                <type name="VkExternalFenceFeatureFlagBitsKHR"/>
+                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT"/>
+                <enum extends="VkExternalFenceFeatureFlagBits"              name="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR" alias="VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT"/>
+                <type name="VkPhysicalDeviceExternalFenceInfoKHR"/>
+                <type name="VkExternalFencePropertiesKHR"/>
+                <type name="VkPhysicalDeviceIDPropertiesKHR"/>
+                <command name="vkGetPhysicalDeviceExternalFencePropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence" number="114" type="device" requires="VK_KHR_external_fence_capabilities" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence&quot;"             name="VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO"/>
+                <type name="VkFenceImportFlagsKHR"/>
+                <type name="VkFenceImportFlagBitsKHR"/>
+                <enum extends="VkFenceImportFlagBits"                       name="VK_FENCE_IMPORT_TEMPORARY_BIT_KHR" alias="VK_FENCE_IMPORT_TEMPORARY_BIT"/>
+                <type name="VkExportFenceCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence_win32" number="115" type="device" requires="VK_KHR_external_fence" author="KHR" contact="Jesse Hall @critsec" platform="win32" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence_win32&quot;"       name="VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR"/>
+                <type name="VkImportFenceWin32HandleInfoKHR"/>
+                <type name="VkExportFenceWin32HandleInfoKHR"/>
+                <type name="VkFenceGetWin32HandleInfoKHR"/>
+                <command name="vkImportFenceWin32HandleKHR"/>
+                <command name="vkGetFenceWin32HandleKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_external_fence_fd" number="116" type="device" requires="VK_KHR_external_fence" author="KHR" contact="Jesse Hall @critsec" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_external_fence_fd&quot;"          name="VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR"/>
+                <type name="VkImportFenceFdInfoKHR"/>
+                <type name="VkFenceGetFdInfoKHR"/>
+                <command name="vkImportFenceFdKHR"/>
+                <command name="vkGetFenceFdKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_performance_query" number="117" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alon Or-bach @alonorbach" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="1"                                    name="VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_performance_query&quot;" name="VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkQueryType"             name="VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR"/>
+                <enum offset="0" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR"/>
+                <enum offset="3" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR"/>
+                <enum offset="4" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR"/>
+                <enum offset="5" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR"/>
+                <enum offset="6" extends="VkStructureType"         name="VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR"/>
+                <type name="VkPhysicalDevicePerformanceQueryFeaturesKHR"/>
+                <type name="VkPhysicalDevicePerformanceQueryPropertiesKHR"/>
+                <type name="VkPerformanceCounterKHR"/>
+                <type name="VkPerformanceCounterDescriptionKHR"/>
+                <type name="VkPerformanceCounterDescriptionFlagsKHR"/>
+                <type name="VkPerformanceCounterDescriptionFlagBitsKHR"/>
+                <type name="VkQueryPoolPerformanceCreateInfoKHR"/>
+                <type name="VkPerformanceCounterScopeKHR"/>
+                <type name="VkPerformanceCounterStorageKHR"/>
+                <type name="VkPerformanceCounterUnitKHR"/>
+                <type name="VkPerformanceCounterResultKHR"/>
+                <type name="VkAcquireProfilingLockInfoKHR"/>
+                <type name="VkAcquireProfilingLockFlagsKHR"/>
+                <type name="VkAcquireProfilingLockFlagBitsKHR"/>
+                <type name="VkPerformanceQuerySubmitInfoKHR"/>
+                <command name="vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"/>
+                <command name="vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"/>
+                <command name="vkAcquireProfilingLockKHR"/>
+                <command name="vkReleaseProfilingLockKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance2" number="118" type="device" author="KHR" contact="Michael Worcester @michaelworcester" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_MAINTENANCE_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance2&quot;"               name="VK_KHR_MAINTENANCE_2_EXTENSION_NAME"/>
+                <enum alias="VK_KHR_MAINTENANCE_2_SPEC_VERSION"             name="VK_KHR_MAINTENANCE2_SPEC_VERSION" comment="Backwards-compatible alias containing a typo"/>
+                <enum alias="VK_KHR_MAINTENANCE_2_EXTENSION_NAME"           name="VK_KHR_MAINTENANCE2_EXTENSION_NAME" comment="Backwards-compatible alias containing a typo"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR" alias="VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR" alias="VK_IMAGE_CREATE_EXTENDED_USAGE_BIT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL"/>
+                <type name="VkPhysicalDevicePointClippingPropertiesKHR"/>
+                <type name="VkPointClippingBehaviorKHR"/>
+                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES"/>
+                <enum extends="VkPointClippingBehavior"                     name="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR" alias="VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY"/>
+                <type name="VkRenderPassInputAttachmentAspectCreateInfoKHR"/>
+                <type name="VkInputAttachmentAspectReferenceKHR"/>
+                <type name="VkImageViewUsageCreateInfoKHR"/>
+                <type name="VkTessellationDomainOriginKHR"/>
+                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT"/>
+                <enum extends="VkTessellationDomainOrigin"                  name="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR" alias="VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT"/>
+                <type name="VkPipelineTessellationDomainOriginStateCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_119" number="119" author="KHR" contact="Michael Worcester @michaelworcester" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_119_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_119&quot;"              name="VK_KHR_EXTENSION_119_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_surface_capabilities2" number="120" type="instance" requires="VK_KHR_surface" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_surface_capabilities2&quot;"  name="VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR"/>
+                <type name="VkPhysicalDeviceSurfaceInfo2KHR"/>
+                <type name="VkSurfaceCapabilities2KHR"/>
+                <type name="VkSurfaceFormat2KHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceCapabilities2KHR"/>
+                <command name="vkGetPhysicalDeviceSurfaceFormats2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_variable_pointers" number="121" type="device" author="KHR" contact="Jesse Hall @critsec" requires="VK_KHR_get_physical_device_properties2,VK_KHR_storage_buffer_storage_class" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_VARIABLE_POINTERS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_variable_pointers&quot;"          name="VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceVariablePointerFeaturesKHR"/>
+                <type name="VkPhysicalDeviceVariablePointersFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_display_properties2" number="122" type="instance" requires="VK_KHR_display" author="KHR" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_display_properties2&quot;"    name="VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR"/>
+                <type name="VkDisplayProperties2KHR"/>
+                <type name="VkDisplayPlaneProperties2KHR"/>
+                <type name="VkDisplayModeProperties2KHR"/>
+                <type name="VkDisplayPlaneInfo2KHR"/>
+                <type name="VkDisplayPlaneCapabilities2KHR"/>
+                <command name="vkGetPhysicalDeviceDisplayProperties2KHR"/>
+                <command name="vkGetPhysicalDeviceDisplayPlaneProperties2KHR"/>
+                <command name="vkGetDisplayModeProperties2KHR"/>
+                <command name="vkGetDisplayPlaneCapabilities2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_MVK_ios_surface" number="123" type="instance" requires="VK_KHR_surface" platform="ios" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings" deprecatedby="VK_EXT_metal_surface">
+            <require>
+                <enum value="3"                                             name="VK_MVK_IOS_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_MVK_ios_surface&quot;"                name="VK_MVK_IOS_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK"/>
+                <type name="VkIOSSurfaceCreateFlagsMVK"/>
+                <type name="VkIOSSurfaceCreateInfoMVK"/>
+                <command name="vkCreateIOSSurfaceMVK"/>
+            </require>
+        </extension>
+        <extension name="VK_MVK_macos_surface" number="124" type="instance" requires="VK_KHR_surface" platform="macos" supported="vulkan" author="MVK" contact="Bill Hollings @billhollings" deprecatedby="VK_EXT_metal_surface">
+            <require>
+                <enum value="3"                                             name="VK_MVK_MACOS_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_MVK_macos_surface&quot;"              name="VK_MVK_MACOS_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK"/>
+                <type name="VkMacOSSurfaceCreateFlagsMVK"/>
+                <type name="VkMacOSSurfaceCreateInfoMVK"/>
+                <command name="vkCreateMacOSSurfaceMVK"/>
+            </require>
+        </extension>
+        <extension name="VK_MVK_moltenvk" number="125" type="instance" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_MVK_MOLTENVK_SPEC_VERSION"/>
+                <enum value="&quot;VK_MVK_moltenvk&quot;"                   name="VK_MVK_MOLTENVK_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_external_memory_dma_buf" number="126" type="device" requires="VK_KHR_external_memory_fd" author="EXT" contact="Chad Versace @chadversary" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_external_memory_dma_buf&quot;"    name="VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME"/>
+                <enum bitpos="9" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_queue_family_foreign" number="127" type="device" author="EXT" requires="VK_KHR_external_memory" contact="Chad Versace @chadversary" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_queue_family_foreign&quot;"       name="VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME"/>
+                <enum                                                       name="VK_QUEUE_FAMILY_FOREIGN_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_dedicated_allocation" number="128" type="device" author="KHR" requires="VK_KHR_get_memory_requirements2" contact="James Jones @cubanismo" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="3"                                             name="VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_dedicated_allocation&quot;"       name="VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO"/>
+                <type name="VkMemoryDedicatedRequirementsKHR"/>
+                <type name="VkMemoryDedicatedAllocateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_debug_utils" number="129" type="instance" author="EXT" contact="Mark Young @marky-lunarg" specialuse="debugging" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DEBUG_UTILS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_debug_utils&quot;"                name="VK_EXT_DEBUG_UTILS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT"/>
+                <type name="PFN_vkDebugUtilsMessengerCallbackEXT"/>
+                <type name="VkDebugUtilsLabelEXT"/>
+                <type name="VkDebugUtilsMessageSeverityFlagBitsEXT"/>
+                <type name="VkDebugUtilsMessageSeverityFlagsEXT"/>
+                <type name="VkDebugUtilsMessageTypeFlagBitsEXT"/>
+                <type name="VkDebugUtilsMessageTypeFlagsEXT"/>
+                <type name="VkDebugUtilsMessengerCallbackDataEXT"/>
+                <type name="VkDebugUtilsMessengerCallbackDataFlagsEXT"/>
+                <type name="VkDebugUtilsMessengerCreateFlagsEXT"/>
+                <type name="VkDebugUtilsMessengerCreateInfoEXT"/>
+                <type name="VkDebugUtilsMessengerEXT"/>
+                <type name="VkDebugUtilsObjectNameInfoEXT"/>
+                <type name="VkDebugUtilsObjectTagInfoEXT"/>
+                <command name="vkSetDebugUtilsObjectNameEXT"/>
+                <command name="vkSetDebugUtilsObjectTagEXT"/>
+                <command name="vkQueueBeginDebugUtilsLabelEXT"/>
+                <command name="vkQueueEndDebugUtilsLabelEXT"/>
+                <command name="vkQueueInsertDebugUtilsLabelEXT"/>
+                <command name="vkCmdBeginDebugUtilsLabelEXT"/>
+                <command name="vkCmdEndDebugUtilsLabelEXT"/>
+                <command name="vkCmdInsertDebugUtilsLabelEXT"/>
+                <command name="vkCreateDebugUtilsMessengerEXT"/>
+                <command name="vkDestroyDebugUtilsMessengerEXT"/>
+                <command name="vkSubmitDebugUtilsMessageEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_ANDROID_external_memory_android_hardware_buffer" number="130" type="device" author="ANDROID" requires="VK_KHR_sampler_ycbcr_conversion,VK_KHR_external_memory,VK_EXT_queue_family_foreign,VK_KHR_dedicated_allocation" platform="android" contact="Jesse Hall @critsec" supported="vulkan">
+            <require>
+                <enum value="4"                                             name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION"/>
+                <enum value="&quot;VK_ANDROID_external_memory_android_hardware_buffer&quot;" name="VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME"/>
+                <enum bitpos="10" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID"/>
+                <type name="VkAndroidHardwareBufferUsageANDROID"/>
+                <type name="VkAndroidHardwareBufferPropertiesANDROID"/>
+                <type name="VkAndroidHardwareBufferFormatPropertiesANDROID"/>
+                <type name="VkImportAndroidHardwareBufferInfoANDROID"/>
+                <type name="VkMemoryGetAndroidHardwareBufferInfoANDROID"/>
+                <type name="VkExternalFormatANDROID"/>
+                <command name="vkGetAndroidHardwareBufferPropertiesANDROID"/>
+                <command name="vkGetMemoryAndroidHardwareBufferANDROID"/>
+                <type name="AHardwareBuffer"/>
+            </require>
+            <require extension="VK_KHR_format_feature_flags2">
+                <type name="VkAndroidHardwareBufferFormatProperties2ANDROID"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_sampler_filter_minmax" number="131" type="device" author="NV" requires="VK_KHR_get_physical_device_properties2" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="2"                                             name="VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_sampler_filter_minmax&quot;"      name="VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT"/>
+                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT" alias="VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE"/>
+                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_MIN_EXT" alias="VK_SAMPLER_REDUCTION_MODE_MIN"/>
+                <enum extends="VkSamplerReductionMode"                      name="VK_SAMPLER_REDUCTION_MODE_MAX_EXT" alias="VK_SAMPLER_REDUCTION_MODE_MAX"/>
+                <type name="VkSamplerReductionModeEXT"/>
+                <type name="VkSamplerReductionModeCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_storage_buffer_storage_class" number="132" type="device" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_storage_buffer_storage_class&quot;" name="VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_gpu_shader_int16" number="133" type="device" author="AMD" contact="Qun Lin @linqun" supported="vulkan" deprecatedby="VK_KHR_shader_float16_int8">
+            <require>
+                <enum value="2"                                             name="VK_AMD_GPU_SHADER_INT16_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_gpu_shader_int16&quot;"           name="VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_134" number="134" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_134_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_134&quot;"              name="VK_AMD_EXTENSION_134_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_135" number="135" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_135_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_135&quot;"              name="VK_AMD_EXTENSION_135_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_136" number="136" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_136_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_136&quot;"              name="VK_AMD_EXTENSION_136_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_mixed_attachment_samples" number="137" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_mixed_attachment_samples&quot;"   name="VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_fragment_mask" number="138" author="AMD" contact="Aaron Hagan @AaronHaganAMD" supported="vulkan" type="device">
+            <require>
+                <enum value="1"                                             name="VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_fragment_mask&quot;"       name="VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_inline_uniform_block" number="139" type="device" author="EXT" requires="VK_KHR_get_physical_device_properties2,VK_KHR_maintenance1" contact="Daniel Rakos @aqnuep" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_inline_uniform_block&quot;"       name="VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkDescriptorType"                 name="VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceInlineUniformBlockFeaturesEXT"/>
+                <type name="VkPhysicalDeviceInlineUniformBlockPropertiesEXT"/>
+                <type name="VkWriteDescriptorSetInlineUniformBlockEXT"/>
+                <type name="VkDescriptorPoolInlineUniformBlockCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_140" number="140" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_140_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_140&quot;"              name="VK_AMD_EXTENSION_140_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_stencil_export" number="141" type="device" author="EXT" contact="Dominik Witczak @dominikwitczakamd" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_stencil_export&quot;"      name="VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_142" number="142" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_142_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_142&quot;"              name="VK_AMD_EXTENSION_142_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_143" number="143" author="AMD" contact="Mais Alnasser @malnasse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_143_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_143&quot;"              name="VK_AMD_EXTENSION_143_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_sample_locations" number="144" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" supported="vulkan" requires="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_sample_locations&quot;"           name="VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME"/>
+                <enum bitpos="12" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT"/>
+                <type name="VkSampleLocationEXT"/>
+                <type name="VkSampleLocationsInfoEXT"/>
+                <type name="VkAttachmentSampleLocationsEXT"/>
+                <type name="VkSubpassSampleLocationsEXT"/>
+                <type name="VkRenderPassSampleLocationsBeginInfoEXT"/>
+                <type name="VkPipelineSampleLocationsStateCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceSampleLocationsPropertiesEXT"/>
+                <type name="VkMultisamplePropertiesEXT"/>
+                <command name="vkCmdSetSampleLocationsEXT"/>
+                <command name="vkGetPhysicalDeviceMultisamplePropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_relaxed_block_layout" number="145" type="device" author="KHR" contact="John Kessenich @johnkslang" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_relaxed_block_layout&quot;"       name="VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_RESERVED_do_not_use_146" number="146" supported="disabled" comment="Used for functionality subsumed into Vulkan 1.1 and not published as an extension">
+            <require>
+                <enum value="1"                                             name="VK_RESERVED_DO_NOT_USE_146_SPEC_VERSION"/>
+                <enum value="&quot;VK_RESERVED_do_not_use_146&quot;"        name="VK_RESERVED_DO_NOT_USE_146_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_get_memory_requirements2" number="147" type="device" author="KHR" contact="Jason Ekstrand @jekstrand" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1" name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_get_memory_requirements2&quot;"   name="VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR" alias="VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2"/>
+                <type name="VkBufferMemoryRequirementsInfo2KHR"/>
+                <type name="VkImageMemoryRequirementsInfo2KHR"/>
+                <type name="VkImageSparseMemoryRequirementsInfo2KHR"/>
+                <type name="VkMemoryRequirements2KHR"/>
+                <type name="VkSparseImageMemoryRequirements2KHR"/>
+                <command name="vkGetImageMemoryRequirements2KHR"/>
+                <command name="vkGetBufferMemoryRequirements2KHR"/>
+                <command name="vkGetImageSparseMemoryRequirements2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_image_format_list" number="148" type="device" author="KHR" contact="Jason Ekstrand @jekstrand" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_image_format_list&quot;"          name="VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO"/>
+                <type name="VkImageFormatListCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_blend_operation_advanced" number="149" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_blend_operation_advanced&quot;"   name="VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT"/>
+                <type name="VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT"/>
+                <type name="VkPipelineColorBlendAdvancedStateCreateInfoEXT"/>
+                <type name="VkBlendOverlapEXT"/>
+                <enum offset="0" extends="VkBlendOp"                        name="VK_BLEND_OP_ZERO_EXT"/>
+                <enum offset="1" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_EXT"/>
+                <enum offset="2" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_EXT"/>
+                <enum offset="3" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OVER_EXT"/>
+                <enum offset="4" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OVER_EXT"/>
+                <enum offset="5" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_IN_EXT"/>
+                <enum offset="6" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_IN_EXT"/>
+                <enum offset="7" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_OUT_EXT"/>
+                <enum offset="8" extends="VkBlendOp"                        name="VK_BLEND_OP_DST_OUT_EXT"/>
+                <enum offset="9" extends="VkBlendOp"                        name="VK_BLEND_OP_SRC_ATOP_EXT"/>
+                <enum offset="10" extends="VkBlendOp"                       name="VK_BLEND_OP_DST_ATOP_EXT"/>
+                <enum offset="11" extends="VkBlendOp"                       name="VK_BLEND_OP_XOR_EXT"/>
+                <enum offset="12" extends="VkBlendOp"                       name="VK_BLEND_OP_MULTIPLY_EXT"/>
+                <enum offset="13" extends="VkBlendOp"                       name="VK_BLEND_OP_SCREEN_EXT"/>
+                <enum offset="14" extends="VkBlendOp"                       name="VK_BLEND_OP_OVERLAY_EXT"/>
+                <enum offset="15" extends="VkBlendOp"                       name="VK_BLEND_OP_DARKEN_EXT"/>
+                <enum offset="16" extends="VkBlendOp"                       name="VK_BLEND_OP_LIGHTEN_EXT"/>
+                <enum offset="17" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORDODGE_EXT"/>
+                <enum offset="18" extends="VkBlendOp"                       name="VK_BLEND_OP_COLORBURN_EXT"/>
+                <enum offset="19" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDLIGHT_EXT"/>
+                <enum offset="20" extends="VkBlendOp"                       name="VK_BLEND_OP_SOFTLIGHT_EXT"/>
+                <enum offset="21" extends="VkBlendOp"                       name="VK_BLEND_OP_DIFFERENCE_EXT"/>
+                <enum offset="22" extends="VkBlendOp"                       name="VK_BLEND_OP_EXCLUSION_EXT"/>
+                <enum offset="23" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_EXT"/>
+                <enum offset="24" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_RGB_EXT"/>
+                <enum offset="25" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARDODGE_EXT"/>
+                <enum offset="26" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARBURN_EXT"/>
+                <enum offset="27" extends="VkBlendOp"                       name="VK_BLEND_OP_VIVIDLIGHT_EXT"/>
+                <enum offset="28" extends="VkBlendOp"                       name="VK_BLEND_OP_LINEARLIGHT_EXT"/>
+                <enum offset="29" extends="VkBlendOp"                       name="VK_BLEND_OP_PINLIGHT_EXT"/>
+                <enum offset="30" extends="VkBlendOp"                       name="VK_BLEND_OP_HARDMIX_EXT"/>
+                <enum offset="31" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_HUE_EXT"/>
+                <enum offset="32" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_SATURATION_EXT"/>
+                <enum offset="33" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_COLOR_EXT"/>
+                <enum offset="34" extends="VkBlendOp"                       name="VK_BLEND_OP_HSL_LUMINOSITY_EXT"/>
+                <enum offset="35" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_EXT"/>
+                <enum offset="36" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_EXT"/>
+                <enum offset="37" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT"/>
+                <enum offset="38" extends="VkBlendOp"                       name="VK_BLEND_OP_PLUS_DARKER_EXT"/>
+                <enum offset="39" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_EXT"/>
+                <enum offset="40" extends="VkBlendOp"                       name="VK_BLEND_OP_MINUS_CLAMPED_EXT"/>
+                <enum offset="41" extends="VkBlendOp"                       name="VK_BLEND_OP_CONTRAST_EXT"/>
+                <enum offset="42" extends="VkBlendOp"                       name="VK_BLEND_OP_INVERT_OVG_EXT"/>
+                <enum offset="43" extends="VkBlendOp"                       name="VK_BLEND_OP_RED_EXT"/>
+                <enum offset="44" extends="VkBlendOp"                       name="VK_BLEND_OP_GREEN_EXT"/>
+                <enum offset="45" extends="VkBlendOp"                       name="VK_BLEND_OP_BLUE_EXT"/>
+                <enum bitpos="19" extends="VkAccessFlagBits"                name="VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fragment_coverage_to_color" number="150" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fragment_coverage_to_color&quot;"  name="VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV"/>
+                <type name="VkPipelineCoverageToColorStateCreateFlagsNV"/>
+                <type name="VkPipelineCoverageToColorStateCreateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_acceleration_structure" number="151" type="device" requiresCore="1.1" requires="VK_EXT_descriptor_indexing,VK_KHR_buffer_device_address,VK_KHR_deferred_host_operations" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1">
+            <require>
+                <enum value="13"                                            name="VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_acceleration_structure&quot;"     name="VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME"/>
+                <enum offset="7"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR"/>
+                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR"/>
+                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR"/>
+                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR"/>
+                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR"/>
+                <enum offset="6"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR"/>
+                <enum offset="9"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR"/>
+                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR"/>
+                <enum offset="11" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR"/>
+                <enum offset="12" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR"/>
+                <enum offset="13" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"/>
+                <enum offset="14" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"/>
+                <enum offset="17" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR"/>
+                <enum offset="20" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR"/>
+                <enum bitpos="25" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum offset="0"  extends="VkDescriptorType"                name="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR"/>
+                <enum bitpos="21" extends="VkAccessFlagBits"                name="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum bitpos="22" extends="VkAccessFlagBits"                name="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+                <enum offset="0"  extends="VkQueryType"                     name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR"/>
+                <enum offset="1"  extends="VkQueryType"                     name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR"/>
+                <enum offset="0"  extends="VkObjectType"                    name="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR"/>
+                <enum offset="0"  extends="VkDebugReportObjectTypeEXT"      name="VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT"/>
+                <enum offset="0"  extends="VkIndexType" extnumber="166"     name="VK_INDEX_TYPE_NONE_KHR"/>
+                <enum bitpos="29" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"/>
+                <enum bitpos="19" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR"/>
+                <enum bitpos="20" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR"/>
+                <type name="VkAccelerationStructureTypeKHR"/>
+                <type name="VkDeviceOrHostAddressKHR"/>
+                <type name="VkDeviceOrHostAddressConstKHR"/>
+                <type name="VkAccelerationStructureBuildRangeInfoKHR"/>
+                <type name="VkAabbPositionsKHR"/>
+                <type name="VkAccelerationStructureGeometryTrianglesDataKHR"/>
+                <type name="VkTransformMatrixKHR"/>
+                <type name="VkAccelerationStructureBuildGeometryInfoKHR"/>
+                <type name="VkAccelerationStructureBuildTypeKHR"/>
+                <type name="VkAccelerationStructureGeometryAabbsDataKHR"/>
+                <type name="VkAccelerationStructureInstanceKHR"/>
+                <type name="VkAccelerationStructureGeometryInstancesDataKHR"/>
+                <type name="VkAccelerationStructureGeometryDataKHR"/>
+                <type name="VkAccelerationStructureGeometryKHR"/>
+                <type name="VkGeometryFlagsKHR"/>
+                <type name="VkGeometryInstanceFlagsKHR"/>
+                <type name="VkGeometryFlagBitsKHR"/>
+                <type name="VkGeometryInstanceFlagBitsKHR"/>
+                <type name="VkAccelerationStructureCreateInfoKHR"/>
+                <type name="VkAccelerationStructureKHR"/>
+                <type name="VkBuildAccelerationStructureFlagBitsKHR"/>
+                <type name="VkBuildAccelerationStructureFlagsKHR"/>
+                <type name="VkCopyAccelerationStructureModeKHR"/>
+                <type name="VkGeometryTypeKHR"/>
+                <type name="VkWriteDescriptorSetAccelerationStructureKHR"/>
+                <type name="VkPhysicalDeviceAccelerationStructureFeaturesKHR"/>
+                <type name="VkPhysicalDeviceAccelerationStructurePropertiesKHR"/>
+                <type name="VkAccelerationStructureDeviceAddressInfoKHR"/>
+                <type name="VkAccelerationStructureVersionInfoKHR"/>
+                <type name="VkCopyAccelerationStructureToMemoryInfoKHR"/>
+                <type name="VkCopyMemoryToAccelerationStructureInfoKHR"/>
+                <type name="VkCopyAccelerationStructureInfoKHR"/>
+                <type name="VkAccelerationStructureCompatibilityKHR"/>
+                <type name="VkAccelerationStructureCreateFlagBitsKHR"/>
+                <type name="VkAccelerationStructureCreateFlagsKHR"/>
+                <type name="VkBuildAccelerationStructureModeKHR"/>
+                <type name="VkAccelerationStructureBuildSizesInfoKHR"/>
+                <command name="vkCreateAccelerationStructureKHR"/>
+                <command name="vkDestroyAccelerationStructureKHR"/>
+                <command name="vkCmdBuildAccelerationStructuresKHR"/>
+                <command name="vkCmdBuildAccelerationStructuresIndirectKHR"/>
+                <command name="vkBuildAccelerationStructuresKHR"/>
+                <command name="vkCopyAccelerationStructureKHR"/>
+                <command name="vkCopyAccelerationStructureToMemoryKHR"/>
+                <command name="vkCopyMemoryToAccelerationStructureKHR"/>
+                <command name="vkWriteAccelerationStructuresPropertiesKHR"/>
+                <command name="vkCmdCopyAccelerationStructureKHR"/>
+                <command name="vkCmdCopyAccelerationStructureToMemoryKHR"/>
+                <command name="vkCmdCopyMemoryToAccelerationStructureKHR"/>
+                <command name="vkGetAccelerationStructureDeviceAddressKHR"/>
+                <command name="vkCmdWriteAccelerationStructuresPropertiesKHR"/>
+                <command name="vkGetDeviceAccelerationStructureCompatibilityKHR"/>
+                <command name="vkGetAccelerationStructureBuildSizesKHR"/>
+            </require>
+            <require extension="VK_KHR_format_feature_flags2">
+                <enum bitpos="29" extends="VkFormatFeatureFlagBits2KHR"     name="VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_ray_tracing_pipeline" number="348" type="device" requiresCore="1.1" requires="VK_KHR_spirv_1_4,VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_ray_tracing_pipeline&quot;"       name="VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME"/>
+                <enum                                                       name="VK_SHADER_UNUSED_KHR"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"/>
+                <enum offset="15" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR"/>
+                <enum offset="16" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR"/>
+                <enum offset="18" extends="VkStructureType" extnumber="151" name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR"/>
+                <enum bitpos="8"  extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_RAYGEN_BIT_KHR"/>
+                <enum bitpos="9"  extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_ANY_HIT_BIT_KHR"/>
+                <enum bitpos="10" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"/>
+                <enum bitpos="11" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_MISS_BIT_KHR"/>
+                <enum bitpos="12" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_INTERSECTION_BIT_KHR"/>
+                <enum bitpos="13" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_CALLABLE_BIT_KHR"/>
+                <enum bitpos="21" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"/>
+                <enum bitpos="10" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"/>
+                <enum offset="0"  extends="VkPipelineBindPoint" extnumber="166" name="VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"/>
+                <enum bitpos="14" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR"/>
+                <enum bitpos="15" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR"/>
+                <enum bitpos="16" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR"/>
+                <enum bitpos="17" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR"/>
+                <enum bitpos="12" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR"/>
+                <enum bitpos="13" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR"/>
+                <enum bitpos="19" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR"/>
+                <enum offset="0"  extends="VkDynamicState"                  name="VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR"/>
+                <type name="VkRayTracingShaderGroupCreateInfoKHR"/>
+                <type name="VkRayTracingShaderGroupTypeKHR"/>
+                <type name="VkRayTracingPipelineCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceRayTracingPipelineFeaturesKHR"/>
+                <type name="VkPhysicalDeviceRayTracingPipelinePropertiesKHR"/>
+                <type name="VkStridedDeviceAddressRegionKHR"/>
+                <type name="VkTraceRaysIndirectCommandKHR"/>
+                <type name="VkRayTracingPipelineInterfaceCreateInfoKHR"/>
+                <type name="VkShaderGroupShaderKHR"/>
+                <command name="vkCmdTraceRaysKHR"/>
+                <command name="vkCreateRayTracingPipelinesKHR"/>
+                <command name="vkGetRayTracingShaderGroupHandlesKHR"/>
+                <command name="vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"/>
+                <command name="vkCmdTraceRaysIndirectKHR"/>
+                <command name="vkGetRayTracingShaderGroupStackSizeKHR"/>
+                <command name="vkCmdSetRayTracingPipelineStackSizeKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_ray_query" number="349" type="device" requiresCore="1.1" requires="VK_KHR_spirv_1_4,VK_KHR_acceleration_structure" author="KHR" contact="Daniel Koch @dgkoch" supported="vulkan" sortorder="1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_RAY_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_ray_query&quot;"                  name="VK_KHR_RAY_QUERY_EXTENSION_NAME"/>
+                <enum offset="13" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceRayQueryFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_152" number="152" author="NV" contact="Jeff Bolz @jeffbolznv" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_152_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_152&quot;"               name="VK_NV_EXTENSION_152_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_framebuffer_mixed_samples" number="153" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_framebuffer_mixed_samples&quot;"   name="VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV"/>
+                <type name="VkPipelineCoverageModulationStateCreateInfoNV"/>
+                <type name="VkPipelineCoverageModulationStateCreateFlagsNV"/>
+                <type name="VkCoverageModulationModeNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fill_rectangle" number="154" type="device" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_FILL_RECTANGLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fill_rectangle&quot;"              name="VK_NV_FILL_RECTANGLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkPolygonMode"                    name="VK_POLYGON_MODE_FILL_RECTANGLE_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shader_sm_builtins" number="155" type="device" requiresCore="1.1" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shader_sm_builtins&quot;"          name="VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"/>
+                <type name="VkPhysicalDeviceShaderSMBuiltinsPropertiesNV"/>
+                <type name="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_post_depth_coverage" number="156" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_post_depth_coverage&quot;"        name="VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_sampler_ycbcr_conversion" number="157" type="device" requires="VK_KHR_maintenance1,VK_KHR_bind_memory2,VK_KHR_get_memory_requirements2,VK_KHR_get_physical_device_properties2" author="KHR" contact="Andrew Garrard @fluppeteer" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="14"                                            name="VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_sampler_ycbcr_conversion&quot;"   name="VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR" alias="VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES"/>
+                <enum extends="VkDebugReportObjectTypeEXT"                  name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT" alias="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
+                <enum extends="VkObjectType"                                name="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR" alias="VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8B8G8R8_422_UNORM_KHR" alias="VK_FORMAT_G8B8G8R8_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B8G8R8G8_422_UNORM_KHR" alias="VK_FORMAT_B8G8R8G8_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G8_B8R8_2PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6_UNORM_PACK16_KHR" alias="VK_FORMAT_R10X6_UNORM_PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR" alias="VK_FORMAT_R10X6G10X6_UNORM_2PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR" alias="VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4_UNORM_PACK16_KHR" alias="VK_FORMAT_R12X4_UNORM_PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR" alias="VK_FORMAT_R12X4G12X4_UNORM_2PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR" alias="VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR" alias="VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR" alias="VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16B16G16R16_422_UNORM_KHR" alias="VK_FORMAT_G16B16G16R16_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_B16G16R16G16_422_UNORM_KHR" alias="VK_FORMAT_B16G16R16G16_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_420_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR" alias="VK_FORMAT_G16_B16R16_2PLANE_422_UNORM"/>
+                <enum extends="VkFormat"                                    name="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR" alias="VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM"/>
+                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_0_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_0_BIT"/>
+                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_1_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_1_BIT"/>
+                <enum extends="VkImageAspectFlagBits"                       name="VK_IMAGE_ASPECT_PLANE_2_BIT_KHR" alias="VK_IMAGE_ASPECT_PLANE_2_BIT"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_DISJOINT_BIT_KHR" alias="VK_IMAGE_CREATE_DISJOINT_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_DISJOINT_BIT_KHR" alias="VK_FORMAT_FEATURE_DISJOINT_BIT"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR" alias="VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT"/>
+                <type name="VkSamplerYcbcrConversionCreateInfoKHR"/>
+                <type name="VkSamplerYcbcrConversionInfoKHR"/>
+                <type name="VkBindImagePlaneMemoryInfoKHR"/>
+                <type name="VkImagePlaneMemoryRequirementsInfoKHR"/>
+                <type name="VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"/>
+                <type name="VkSamplerYcbcrConversionImageFormatPropertiesKHR"/>
+                <command name="vkCreateSamplerYcbcrConversionKHR"/>
+                <command name="vkDestroySamplerYcbcrConversionKHR"/>
+                <type name="VkSamplerYcbcrConversionKHR"/>
+                <type name="VkSamplerYcbcrModelConversionKHR"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601"/>
+                <enum extends="VkSamplerYcbcrModelConversion"               name="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR" alias="VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020"/>
+                <type name="VkSamplerYcbcrRangeKHR"/>
+                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_FULL"/>
+                <enum extends="VkSamplerYcbcrRange"                         name="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR" alias="VK_SAMPLER_YCBCR_RANGE_ITU_NARROW"/>
+                <type name="VkChromaLocationKHR"/>
+                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_COSITED_EVEN_KHR" alias="VK_CHROMA_LOCATION_COSITED_EVEN"/>
+                <enum extends="VkChromaLocation"                            name="VK_CHROMA_LOCATION_MIDPOINT_KHR" alias="VK_CHROMA_LOCATION_MIDPOINT"/>
+            </require>
+            <require extension="VK_EXT_debug_report">
+                <enum extends="VkDebugReportObjectTypeEXT" offset="0"       name="VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_bind_memory2" number="158" type="device" author="KHR" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_BIND_MEMORY_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_bind_memory2&quot;"               name="VK_KHR_BIND_MEMORY_2_EXTENSION_NAME"/>
+                <command name="vkBindBufferMemory2KHR"/>
+                <command name="vkBindImageMemory2KHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR" alias="VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO"/>
+                <enum extends="VkImageCreateFlagBits"                       name="VK_IMAGE_CREATE_ALIAS_BIT_KHR" alias="VK_IMAGE_CREATE_ALIAS_BIT"/>
+                <type name="VkBindBufferMemoryInfoKHR"/>
+                <type name="VkBindImageMemoryInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_drm_format_modifier" number="159" type="device" requires="VK_KHR_bind_memory2,VK_KHR_get_physical_device_properties2,VK_KHR_image_format_list,VK_KHR_sampler_ycbcr_conversion" author="EXT" contact="Chad Versace @chadversary" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_drm_format_modifier&quot;"  name="VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME"/>
+                <enum offset="0" dir="-" extends="VkResult"                 name="VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT"/>
+                <enum offset="0" extends="VkImageTiling"                    name="VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT"/>
+                <enum bitpos="7"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT"/>
+                <enum bitpos="8"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT"/>
+                <enum bitpos="9"  extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT"/>
+                <enum bitpos="10" extends="VkImageAspectFlagBits"           name="VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT"/>
+                <type name="VkDrmFormatModifierPropertiesListEXT"/>
+                <type name="VkDrmFormatModifierPropertiesEXT"/>
+                <type name="VkPhysicalDeviceImageDrmFormatModifierInfoEXT"/>
+                <type name="VkImageDrmFormatModifierListCreateInfoEXT"/>
+                <type name="VkImageDrmFormatModifierExplicitCreateInfoEXT"/>
+                <type name="VkImageDrmFormatModifierPropertiesEXT"/>
+                <command name="vkGetImageDrmFormatModifierPropertiesEXT"/>
+            </require>
+            <require extension="VK_KHR_format_feature_flags2">
+                <type name="VkDrmFormatModifierPropertiesList2EXT"/>
+                <type name="VkDrmFormatModifierProperties2EXT"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_160" number="160" author="EXT" contact="Mark Young @marky-lunarg" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_160_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_160&quot;"              name="VK_EXT_EXTENSION_160_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_validation_cache" number="161" type="device" author="GOOGLE" contact="Cort Stratton @cdwfs" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_VALIDATION_CACHE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_validation_cache&quot;"           name="VK_EXT_VALIDATION_CACHE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_VALIDATION_CACHE_EXT"/>
+                <type name="VkValidationCacheEXT"/>
+                <type name="VkValidationCacheCreateInfoEXT"/>
+                <type name="VkShaderModuleValidationCacheCreateInfoEXT"/>
+                <type name="VkValidationCacheHeaderVersionEXT"/>
+                <type name="VkValidationCacheCreateFlagsEXT"/>
+                <command name="vkCreateValidationCacheEXT"/>
+                <command name="vkDestroyValidationCacheEXT"/>
+                <command name="vkMergeValidationCachesEXT"/>
+                <command name="vkGetValidationCacheDataEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_descriptor_indexing" number="162" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_maintenance3" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_descriptor_indexing&quot;"        name="VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT"/>
+                <enum extends="VkDescriptorBindingFlagBits"                 name="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT" alias="VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT"/>
+                <enum extends="VkDescriptorPoolCreateFlagBits"              name="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT" alias="VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT"/>
+                <enum extends="VkDescriptorSetLayoutCreateFlagBits"         name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT" alias="VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT"/>
+                <enum extends="VkResult"                                    name="VK_ERROR_FRAGMENTATION_EXT" alias="VK_ERROR_FRAGMENTATION"/>
+                <type name="VkDescriptorSetLayoutBindingFlagsCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceDescriptorIndexingFeaturesEXT"/>
+                <type name="VkPhysicalDeviceDescriptorIndexingPropertiesEXT"/>
+                <type name="VkDescriptorSetVariableDescriptorCountAllocateInfoEXT"/>
+                <type name="VkDescriptorSetVariableDescriptorCountLayoutSupportEXT"/>
+                <type name="VkDescriptorBindingFlagBitsEXT"/>
+                <type name="VkDescriptorBindingFlagsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_viewport_index_layer" number="163" type="device" author="NV" contact="Daniel Koch @dgkoch" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_viewport_index_layer&quot;" name="VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_portability_subset" number="164" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Bill Hollings @billhollings" platform="provisional" supported="vulkan" provisional="true">
+            <require>
+                <enum value="1"                                             name="VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_portability_subset&quot;"         name="VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <type name="VkPhysicalDevicePortabilitySubsetFeaturesKHR"/>
+                <type name="VkPhysicalDevicePortabilitySubsetPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shading_rate_image" number="165" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="3"                                             name="VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shading_rate_image&quot;"          name="VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"/>
+                <enum            extends="VkImageLayout"                    name="VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV" alias="VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"/>
+                <enum offset="4" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV"/>
+                <enum            extends="VkAccessFlagBits"                 name="VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV" alias="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+                <enum            extends="VkImageUsageFlagBits"             name="VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV" alias="VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum            extends="VkPipelineStageFlagBits"          name="VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV" alias="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV"/>
+                <enum offset="6" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV"/>
+                <type name="VkShadingRatePaletteEntryNV"/>
+                <type name="VkShadingRatePaletteNV"/>
+                <type name="VkPipelineViewportShadingRateImageStateCreateInfoNV"/>
+                <type name="VkPhysicalDeviceShadingRateImageFeaturesNV"/>
+                <type name="VkPhysicalDeviceShadingRateImagePropertiesNV"/>
+                <type name="VkCoarseSampleLocationNV"/>
+                <type name="VkCoarseSampleOrderCustomNV"/>
+                <type name="VkPipelineViewportCoarseSampleOrderStateCreateInfoNV"/>
+                <type name="VkCoarseSampleOrderTypeNV"/>
+                <command name="vkCmdBindShadingRateImageNV"/>
+                <command name="vkCmdSetViewportShadingRatePaletteNV"/>
+                <command name="vkCmdSetCoarseSampleOrderNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_ray_tracing" number="166" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_get_memory_requirements2" author="NV" contact="Eric Werness @ewerness-nv" supported="vulkan">
+            <require>
+                <enum value="3"                               name="VK_NV_RAY_TRACING_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_ray_tracing&quot;"   name="VK_NV_RAY_TRACING_EXTENSION_NAME"/>
+                <enum                                         name="VK_SHADER_UNUSED_NV"/>
+                <enum offset="0"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV"/>
+                <enum offset="1"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV"/>
+                <enum offset="3"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_NV"/>
+                <enum offset="4"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV"/>
+                <enum offset="5"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV"/>
+                <enum offset="6"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV"/>
+                <enum offset="7"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV"/>
+                <enum offset="8"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV"/>
+                <enum offset="9"  extends="VkStructureType"   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"/>
+                <enum offset="11" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV"/>
+                <enum offset="12" extends="VkStructureType"   name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_RAYGEN_BIT_NV" alias="VK_SHADER_STAGE_RAYGEN_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_ANY_HIT_BIT_NV" alias="VK_SHADER_STAGE_ANY_HIT_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV" alias="VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_MISS_BIT_NV" alias="VK_SHADER_STAGE_MISS_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_INTERSECTION_BIT_NV" alias="VK_SHADER_STAGE_INTERSECTION_BIT_KHR"/>
+                <enum extends="VkShaderStageFlagBits"         name="VK_SHADER_STAGE_CALLABLE_BIT_NV" alias="VK_SHADER_STAGE_CALLABLE_BIT_KHR"/>
+                <enum extends="VkPipelineStageFlagBits"       name="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR"/>
+                <enum extends="VkPipelineStageFlagBits"       name="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV" alias="VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum extends="VkBufferUsageFlagBits"         name="VK_BUFFER_USAGE_RAY_TRACING_BIT_NV" alias="VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR"/>
+                <enum extends="VkPipelineBindPoint"           name="VK_PIPELINE_BIND_POINT_RAY_TRACING_NV" alias="VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR"/>
+                <enum offset="0" extends="VkDescriptorType"   name="VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV"/>
+                <enum extends="VkAccessFlagBits"              name="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV" alias="VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits"              name="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV" alias="VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+                <enum offset="0" extends="VkQueryType"        name="VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV"/>
+                <enum bitpos="5" extends="VkPipelineCreateFlagBits"      name="VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV"/>
+                <enum offset="0" extends="VkObjectType"       name="VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV"/>
+                <enum offset="0" extends="VkDebugReportObjectTypeEXT" name="VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT"/>
+                <enum extends="VkIndexType"                   name="VK_INDEX_TYPE_NONE_NV" alias="VK_INDEX_TYPE_NONE_KHR"/>
+                <type name="VkRayTracingShaderGroupCreateInfoNV"/>
+                <type name="VkRayTracingShaderGroupTypeNV"/>
+                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR"/>
+                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR"/>
+                <enum extends="VkRayTracingShaderGroupTypeKHR" name="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV" alias="VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR"/>
+                <type name="VkRayTracingPipelineCreateInfoNV"/>
+                <type name="VkGeometryTypeNV"/>
+                <enum extends="VkGeometryTypeKHR" name="VK_GEOMETRY_TYPE_TRIANGLES_NV" alias="VK_GEOMETRY_TYPE_TRIANGLES_KHR"/>
+                <enum extends="VkGeometryTypeKHR" name="VK_GEOMETRY_TYPE_AABBS_NV" alias="VK_GEOMETRY_TYPE_AABBS_KHR"/>
+                <type name="VkAccelerationStructureTypeNV"/>
+                <enum extends="VkAccelerationStructureTypeKHR" name="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV" alias="VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR"/>
+                <enum extends="VkAccelerationStructureTypeKHR" name="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV" alias="VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR"/>
+                <type name="VkGeometryTrianglesNV"/>
+                <type name="VkGeometryAABBNV"/>
+                <type name="VkGeometryDataNV"/>
+                <type name="VkGeometryNV"/>
+                <type name="VkGeometryFlagsNV"/>
+                <type name="VkGeometryFlagBitsNV"/>
+                <enum extends="VkGeometryFlagBitsKHR" name="VK_GEOMETRY_OPAQUE_BIT_NV" alias="VK_GEOMETRY_OPAQUE_BIT_KHR"/>
+                <enum extends="VkGeometryFlagBitsKHR" name="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV" alias="VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR"/>
+                <type name="VkGeometryInstanceFlagsNV"/>
+                <type name="VkGeometryInstanceFlagBitsNV"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR"/>
+                <enum extends="VkGeometryInstanceFlagBitsKHR" name="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV" alias="VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR"/>
+                <type name="VkAccelerationStructureInfoNV"/>
+                <type name="VkAccelerationStructureCreateInfoNV"/>
+                <type name="VkAccelerationStructureNV"/>
+                <type name="VkBuildAccelerationStructureFlagBitsNV"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR"/>
+                <enum extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV" alias="VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR"/>
+                <type name="VkBuildAccelerationStructureFlagsNV"/>
+                <type name="VkCopyAccelerationStructureModeNV"/>
+                <enum extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV" alias="VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR"/>
+                <enum extends="VkCopyAccelerationStructureModeKHR" name="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV" alias="VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR"/>
+                <type name="VkBindAccelerationStructureMemoryInfoNV"/>
+                <type name="VkWriteDescriptorSetAccelerationStructureNV"/>
+                <type name="VkAccelerationStructureMemoryRequirementsInfoNV"/>
+                <type name="VkPhysicalDeviceRayTracingPropertiesNV"/>
+                <type name="VkMemoryRequirements2KHR"/>
+                <type name="VkAccelerationStructureMemoryRequirementsTypeNV"/>
+                <type name="VkTransformMatrixNV"/>
+                <type name="VkAabbPositionsNV"/>
+                <type name="VkAccelerationStructureInstanceNV"/>
+                <command name="vkCreateAccelerationStructureNV"/>
+                <command name="vkDestroyAccelerationStructureNV"/>
+                <command name="vkGetAccelerationStructureMemoryRequirementsNV"/>
+                <command name="vkBindAccelerationStructureMemoryNV"/>
+                <command name="vkCmdBuildAccelerationStructureNV"/>
+                <command name="vkCmdCopyAccelerationStructureNV"/>
+                <command name="vkCmdTraceRaysNV"/>
+                <command name="vkCreateRayTracingPipelinesNV"/>
+                <command name="vkGetRayTracingShaderGroupHandlesNV"/>
+                <command name="vkGetAccelerationStructureHandleNV"/>
+                <command name="vkCmdWriteAccelerationStructuresPropertiesNV"/>
+                <command name="vkCompileDeferredNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_representative_fragment_test" number="167" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_representative_fragment_test&quot;" name="VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"  name="VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV"/>
+                <type name="VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV"/>
+                <type name="VkPipelineRepresentativeFragmentTestStateCreateInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_168" number="168" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_168_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_168&quot;"               name="VK_NV_EXTENSION_168_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance3" number="169" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_1">
+            <require>
+                <enum value="1"                                             name="VK_KHR_MAINTENANCE_3_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance3&quot;"               name="VK_KHR_MAINTENANCE_3_EXTENSION_NAME"/>
+                <enum alias="VK_KHR_MAINTENANCE_3_SPEC_VERSION"             name="VK_KHR_MAINTENANCE3_SPEC_VERSION" comment="Backwards-compatible alias containing a typo"/>
+                <enum alias="VK_KHR_MAINTENANCE_3_EXTENSION_NAME"           name="VK_KHR_MAINTENANCE3_EXTENSION_NAME" comment="Backwards-compatible alias containing a typo"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR" alias="VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT"/>
+                <type name="VkPhysicalDeviceMaintenance3PropertiesKHR"/>
+                <type name="VkDescriptorSetLayoutSupportKHR"/>
+                <command name="vkGetDescriptorSetLayoutSupportKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_draw_indirect_count" number="170" type="device" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_draw_indirect_count&quot;"        name="VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME"/>
+                <command name="vkCmdDrawIndirectCountKHR"/>
+                <command name="vkCmdDrawIndexedIndirectCountKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_filter_cubic" number="171" type="device" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="vulkan">
+            <require>
+                <enum value="3"                                             name="VK_EXT_FILTER_CUBIC_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_filter_cubic&quot;"               name="VK_EXT_FILTER_CUBIC_EXTENSION_NAME"/>
+                <enum extends="VkFilter"                                    name="VK_FILTER_CUBIC_EXT" alias="VK_FILTER_CUBIC_IMG"/>
+                <enum extends="VkFormatFeatureFlagBits"                     name="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT" alias="VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceImageViewImageFormatInfoEXT"/>
+                <type name="VkFilterCubicImageViewImageFormatPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_render_pass_shader_resolve" number="172" type="device" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="vulkan">
+            <require>
+                <enum value="4"                                                 name="VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_render_pass_shader_resolve&quot;"    name="VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME"/>
+                <enum bitpos="2" extends="VkSubpassDescriptionFlagBits"         name="VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM"/>
+                <enum bitpos="3" extends="VkSubpassDescriptionFlagBits"         name="VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_173" number="173" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_173_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_173&quot;"             name="VK_QCOM_EXTENSION_173_EXTENSION_NAME"/>
+                <enum bitpos="18" extends="VkBufferUsageFlagBits"           name="VK_BUFFER_USAGE_RESERVED_18_BIT_QCOM"/>
+                <enum bitpos="16" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_16_BIT_QCOM"/>
+                <enum bitpos="17" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_17_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_174" number="174" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_174_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_174&quot;"             name="VK_QCOM_EXTENSION_174_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_global_priority" number="175" type="device" author="EXT" contact="Andres Rodriguez @lostgoat" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_global_priority&quot;"            name="VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT"/>
+                <enum offset="1" dir="-" extends="VkResult"                 name="VK_ERROR_NOT_PERMITTED_EXT"/>
+                <type name="VkDeviceQueueGlobalPriorityCreateInfoEXT"/>
+                <type name="VkQueueGlobalPriorityEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_subgroup_extended_types" number="176" type="device" requiresCore="1.1" author="KHR" contact="Neil Henning @sheredom" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_subgroup_extended_types&quot;" name="VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_177" number="177" author="EXT" contact="Neil Henning @sheredom" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_177_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_177&quot;"              name="VK_EXT_EXTENSION_177_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_8bit_storage" number="178" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_storage_buffer_storage_class" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_8BIT_STORAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_8bit_storage&quot;"               name="VK_KHR_8BIT_STORAGE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"/>
+                <type name="VkPhysicalDevice8BitStorageFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_external_memory_host" number="179" type="device" author="EXT" requires="VK_KHR_external_memory" contact="Daniel Rakos @drakos-amd" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_external_memory_host&quot;"       name="VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"/>
+                <enum bitpos="7" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT"/>
+                <enum bitpos="8" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT"/>
+                <type name="VkImportMemoryHostPointerInfoEXT"/>
+                <type name="VkMemoryHostPointerPropertiesEXT"/>
+                <type name="VkPhysicalDeviceExternalMemoryHostPropertiesEXT"/>
+                <command name="vkGetMemoryHostPointerPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_buffer_marker" number="180" type="device" author="AMD" contact="Daniel Rakos @drakos-amd" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="1"                                          name="VK_AMD_BUFFER_MARKER_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_buffer_marker&quot;"           name="VK_AMD_BUFFER_MARKER_EXTENSION_NAME"/>
+                <command name="vkCmdWriteBufferMarkerAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_atomic_int64" number="181" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Aaron Hagan @ahagan" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_atomic_int64&quot;"        name="VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"/>
+                <type name="VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_clock" number="182" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Aaron Hagan @ahagan" supported="vulkan">
+            <require>
+                <enum value="1"                                          name="VK_KHR_SHADER_CLOCK_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_clock&quot;"            name="VK_KHR_SHADER_CLOCK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceShaderClockFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_183" number="183" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_183_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_183&quot;"              name="VK_AMD_EXTENSION_183_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_pipeline_compiler_control" number="184" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_pipeline_compiler_control&quot;"  name="VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD"/>
+                <type name="VkPipelineCompilerControlFlagBitsAMD"/>
+                <type name="VkPipelineCompilerControlFlagsAMD"/>
+                <type name="VkPipelineCompilerControlCreateInfoAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_calibrated_timestamps" number="185" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Daniel Rakos @drakos-amd" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_calibrated_timestamps&quot;"      name="VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT"/>
+                <type name="VkTimeDomainEXT"/>
+                <type name="VkCalibratedTimestampInfoEXT"/>
+                <command name="vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"/>
+                <command name="vkGetCalibratedTimestampsEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_core_properties" number="186" type="device" author="AMD" requires="VK_KHR_get_physical_device_properties2" contact="Martin Dinkov @mdinkov" supported="vulkan">
+            <require>
+                <enum value="2"                                          name="VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_core_properties&quot;"  name="VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"               name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"/>
+                <type name="VkPhysicalDeviceShaderCorePropertiesAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_187" number="187" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_187_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_187&quot;"              name="VK_AMD_EXTENSION_187_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_video_decode_h265" number="188" type="device" requires="VK_KHR_video_decode_queue" author="KHR" contact="peter.fang@amd.com" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_VIDEO_DECODE_H265_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_video_decode_h265&quot;"      name="VK_EXT_VIDEO_DECODE_H265_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="1" extends="VkVideoCodecOperationFlagBitsKHR"      name="VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_EXT" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoDecodeH265CreateFlagsEXT"/>
+                <type name="VkVideoDecodeH265ProfileEXT"/>
+                <type name="VkVideoDecodeH265CapabilitiesEXT"/>
+                <type name="VkVideoDecodeH265SessionCreateInfoEXT"/>
+
+                <type name="VkVideoDecodeH265SessionParametersCreateInfoEXT"/>
+                <type name="VkVideoDecodeH265SessionParametersAddInfoEXT"/>
+                <type name="VkVideoDecodeH265PictureInfoEXT"/>
+                <type name="VkVideoDecodeH265DpbSlotInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_189" number="189" author="AMD" contact="Daniel Rakos @drakos-amd" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_189_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_189&quot;"              name="VK_AMD_EXTENSION_189_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_memory_overallocation_behavior" number="190" type="device" author="AMD" contact="Martin Dinkov @mdinkov" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_memory_overallocation_behavior&quot;"    name="VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD"/>
+                <type name="VkMemoryOverallocationBehaviorAMD"/>
+                <type name="VkDeviceMemoryOverallocationCreateInfoAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_vertex_attribute_divisor" number="191" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Vikram Kushwaha @vkushwaha" supported="vulkan">
+            <require>
+                <enum value="3"                                         name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_vertex_attribute_divisor&quot;"   name="VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"/>
+                <type name="VkVertexInputBindingDivisorDescriptionEXT"/>
+                <type name="VkPipelineVertexInputDivisorStateCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_frame_token" number="192" type="device" requires="VK_KHR_swapchain,VK_GGP_stream_descriptor_surface" platform="ggp" author="GGP" contact="Jean-Francois Roy @jfroy" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_GGP_FRAME_TOKEN_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_frame_token&quot;"                    name="VK_GGP_FRAME_TOKEN_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP"/>
+                <type name="VkPresentFrameTokenGGP"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_creation_feedback" number="193" type="device" author="GOOGLE" contact="Jean-Francois Roy @jfroy" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_creation_feedback&quot;" name="VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT"/>
+                <type name="VkPipelineCreationFeedbackFlagBitsEXT"/>
+                <type name="VkPipelineCreationFeedbackFlagsEXT"/>
+                <type name="VkPipelineCreationFeedbackCreateInfoEXT"/>
+                <type name="VkPipelineCreationFeedbackEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_194" number="194" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_194_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_194&quot;"       name="VK_GOOGLE_EXTENSION_194_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_195" number="195" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_195_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_195&quot;"       name="VK_GOOGLE_EXTENSION_195_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_196" number="196" author="GOOGLE" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_196_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_196&quot;"       name="VK_GOOGLE_EXTENSION_196_EXTENSION_NAME"/>
+                <enum bitpos="1"  extends="VkPipelineCacheCreateFlagBits"
+                    name="VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_driver_properties" number="197" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_driver_properties&quot;"          name="VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"/>
+                <enum name="VK_MAX_DRIVER_NAME_SIZE_KHR"/>
+                <enum name="VK_MAX_DRIVER_INFO_SIZE_KHR"/>
+                <type name="VkDriverIdKHR"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_AMD_PROPRIETARY_KHR" alias="VK_DRIVER_ID_AMD_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR" alias="VK_DRIVER_ID_AMD_OPEN_SOURCE"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_MESA_RADV_KHR" alias="VK_DRIVER_ID_MESA_RADV"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR" alias="VK_DRIVER_ID_NVIDIA_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR" alias="VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR" alias="VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR" alias="VK_DRIVER_ID_IMAGINATION_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_QUALCOMM_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_ARM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_ARM_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR" alias="VK_DRIVER_ID_GOOGLE_SWIFTSHADER"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_GGP_PROPRIETARY_KHR" alias="VK_DRIVER_ID_GGP_PROPRIETARY"/>
+                <enum extends="VkDriverId"                                  name="VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR" alias="VK_DRIVER_ID_BROADCOM_PROPRIETARY"/>
+                <type name="VkConformanceVersionKHR"/>
+                <type name="VkPhysicalDeviceDriverPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_float_controls" number="198" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alexander Galazin @alegal-arm" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="4"                                             name="VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_float_controls&quot;"      name="VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"/>
+                <type name="VkPhysicalDeviceFloatControlsPropertiesKHR"/>
+                <type name="VkShaderFloatControlsIndependenceKHR"/>
+                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR" alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY"/>
+                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR"         alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL"/>
+                <enum extends="VkShaderFloatControlsIndependence"           name="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR"        alias="VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shader_subgroup_partitioned" number="199" type="device" requiresCore="1.1" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shader_subgroup_partitioned&quot;" name="VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME"/>
+                <enum bitpos="8" extends="VkSubgroupFeatureFlagBits"        name="VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_depth_stencil_resolve" number="200" type="device" requires="VK_KHR_create_renderpass2" author="KHR" contact="Jan-Harald Fredriksen @janharald" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_depth_stencil_resolve&quot;"      name="VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR" alias="VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE"/>
+                <type name="VkSubpassDescriptionDepthStencilResolveKHR"/>
+                <type name="VkPhysicalDeviceDepthStencilResolvePropertiesKHR"/>
+                <type name="VkResolveModeFlagBitsKHR"/>
+                <type name="VkResolveModeFlagsKHR"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_NONE_KHR" alias="VK_RESOLVE_MODE_NONE"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR" alias="VK_RESOLVE_MODE_SAMPLE_ZERO_BIT"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_AVERAGE_BIT_KHR" alias="VK_RESOLVE_MODE_AVERAGE_BIT"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_MIN_BIT_KHR" alias="VK_RESOLVE_MODE_MIN_BIT"/>
+                <enum extends="VkResolveModeFlagBits"                       name="VK_RESOLVE_MODE_MAX_BIT_KHR" alias="VK_RESOLVE_MODE_MAX_BIT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_swapchain_mutable_format" number="201" type="device" author="KHR" requires="VK_KHR_swapchain,VK_KHR_maintenance2,VK_KHR_image_format_list" contact="Daniel Rakos @drakos-arm" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_swapchain_mutable_format&quot;" name="VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME"/>
+                <enum bitpos="2" extends="VkSwapchainCreateFlagBitsKHR" name="VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_compute_shader_derivatives" number="202" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_compute_shader_derivatives&quot;" name="VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_mesh_shader" number="203" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_MESH_SHADER_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_mesh_shader&quot;"             name="VK_NV_MESH_SHADER_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"/>
+                <enum bitpos="6" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_TASK_BIT_NV"/>
+                <enum bitpos="7" extends="VkShaderStageFlagBits"        name="VK_SHADER_STAGE_MESH_BIT_NV"/>
+                <enum bitpos="19" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV"/>
+                <enum bitpos="20" extends="VkPipelineStageFlagBits"     name="VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV"/>
+                <command name="vkCmdDrawMeshTasksNV"/>
+                <command name="vkCmdDrawMeshTasksIndirectNV"/>
+                <command name="vkCmdDrawMeshTasksIndirectCountNV"/>
+                <type name="VkPhysicalDeviceMeshShaderFeaturesNV"/>
+                <type name="VkPhysicalDeviceMeshShaderPropertiesNV"/>
+                <type name="VkDrawMeshTasksIndirectCommandNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fragment_shader_barycentric" number="204" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fragment_shader_barycentric&quot;" name="VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_shader_image_footprint" number="205" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_shader_image_footprint&quot;"  name="VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceShaderImageFootprintFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_scissor_exclusive" number="206" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_scissor_exclusive&quot;"       name="VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV"/>
+                <enum offset="1" extends="VkDynamicState" name="VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV"/>
+                <enum offset="2" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"/>
+                <type name="VkPipelineViewportExclusiveScissorStateCreateInfoNV"/>
+                <type name="VkPhysicalDeviceExclusiveScissorFeaturesNV"/>
+                <command name="vkCmdSetExclusiveScissorNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_device_diagnostic_checkpoints" type="device" number="207" requires="VK_KHR_get_physical_device_properties2" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_device_diagnostic_checkpoints&quot;" name="VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV"/>
+                <type name="VkQueueFamilyCheckpointPropertiesNV"/>
+                <type name="VkCheckpointDataNV"/>
+                <command name="vkCmdSetCheckpointNV"/>
+                <command name="vkGetQueueCheckpointDataNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_timeline_semaphore" number="208" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jason Ekstrand @jekstrand" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="2"                                         name="VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_timeline_semaphore&quot;"     name="VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR" alias="VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO"/>
+                <enum extends="VkSemaphoreType"                             name="VK_SEMAPHORE_TYPE_BINARY_KHR" alias="VK_SEMAPHORE_TYPE_BINARY"/>
+                <enum extends="VkSemaphoreType"                             name="VK_SEMAPHORE_TYPE_TIMELINE_KHR" alias="VK_SEMAPHORE_TYPE_TIMELINE"/>
+                <enum extends="VkSemaphoreWaitFlagBits"                     name="VK_SEMAPHORE_WAIT_ANY_BIT_KHR" alias="VK_SEMAPHORE_WAIT_ANY_BIT"/>
+                <type name="VkSemaphoreTypeKHR"/>
+                <type name="VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"/>
+                <type name="VkPhysicalDeviceTimelineSemaphorePropertiesKHR"/>
+                <type name="VkSemaphoreTypeCreateInfoKHR"/>
+                <type name="VkTimelineSemaphoreSubmitInfoKHR"/>
+                <type name="VkSemaphoreWaitFlagBitsKHR"/>
+                <type name="VkSemaphoreWaitFlagsKHR"/>
+                <type name="VkSemaphoreWaitInfoKHR"/>
+                <type name="VkSemaphoreSignalInfoKHR"/>
+                <command name="vkGetSemaphoreCounterValueKHR"/>
+                <command name="vkWaitSemaphoresKHR"/>
+                <command name="vkSignalSemaphoreKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_209" number="209" type="device" author="KHR" contact="Ian Elliott @ianelliott" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_209_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_209&quot;"          name="VK_KHR_EXTENSION_209_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_shader_integer_functions2" number="210" type="device" requires="VK_KHR_get_physical_device_properties2" author="INTEL" contact="Ian Romanick @ianromanick" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_shader_integer_functions2&quot;" name="VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"/>
+                <type name="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_performance_query" number="211" type="device" author="INTEL" contact="Lionel Landwerlin @llandwerlin" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_performance_query&quot;"    name="VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL"/>
+                <enum extends="VkStructureType" name="VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL" alias="VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL" comment="Backwards-compatible alias"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL"/>
+                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL"/>
+                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL"/>
+                <type name="VkPerformanceConfigurationTypeINTEL"/>
+                <type name="VkQueryPoolSamplingModeINTEL"/>
+                <type name="VkPerformanceOverrideTypeINTEL"/>
+                <type name="VkPerformanceParameterTypeINTEL"/>
+                <type name="VkPerformanceValueTypeINTEL"/>
+                <type name="VkPerformanceValueDataINTEL"/>
+                <type name="VkPerformanceValueINTEL"/>
+                <type name="VkInitializePerformanceApiInfoINTEL"/>
+                <type name="VkQueryPoolCreateInfoINTEL"/>
+                <type name="VkQueryPoolPerformanceQueryCreateInfoINTEL"/>
+                <type name="VkPerformanceMarkerInfoINTEL"/>
+                <type name="VkPerformanceStreamMarkerInfoINTEL"/>
+                <type name="VkPerformanceOverrideInfoINTEL"/>
+                <type name="VkPerformanceConfigurationAcquireInfoINTEL"/>
+                <type name="VkPerformanceConfigurationINTEL"/>
+                <command name="vkInitializePerformanceApiINTEL"/>
+                <command name="vkUninitializePerformanceApiINTEL"/>
+                <command name="vkCmdSetPerformanceMarkerINTEL"/>
+                <command name="vkCmdSetPerformanceStreamMarkerINTEL"/>
+                <command name="vkCmdSetPerformanceOverrideINTEL"/>
+                <command name="vkAcquirePerformanceConfigurationINTEL"/>
+                <command name="vkReleasePerformanceConfigurationINTEL"/>
+                <command name="vkQueueSetPerformanceConfigurationINTEL"/>
+                <command name="vkGetPerformanceParameterINTEL"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_vulkan_memory_model" number="212" type="device" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="3"                                         name="VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_vulkan_memory_model&quot;"    name="VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"/>
+                <type name="VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pci_bus_info" number="213" type="device" author="EXT" requires="VK_KHR_get_physical_device_properties2" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_EXT_PCI_BUS_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pci_bus_info&quot;"           name="VK_EXT_PCI_BUS_INFO_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDevicePCIBusInfoPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_display_native_hdr" number="214" type="device" author="AMD" requires="VK_KHR_get_physical_device_properties2,VK_KHR_get_surface_capabilities2,VK_KHR_swapchain" contact="Matthaeus G. Chajdas @anteru" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_display_native_hdr&quot;"     name="VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD"/>
+                <enum offset="0" extends="VkColorSpaceKHR"              name="VK_COLOR_SPACE_DISPLAY_NATIVE_AMD"/>
+                <type name="VkDisplayNativeHdrSurfaceCapabilitiesAMD"/>
+                <type name="VkSwapchainDisplayNativeHdrCreateInfoAMD"/>
+                <command name="vkSetLocalDimmingAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_imagepipe_surface" number="215" type="instance" author="FUCHSIA" requires="VK_KHR_surface" platform="fuchsia" contact="Craig Stout @cdotstout" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_imagepipe_surface&quot;"  name="VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA"/>
+                <type name="VkImagePipeSurfaceCreateFlagsFUCHSIA"/>
+                <type name="VkImagePipeSurfaceCreateInfoFUCHSIA"/>
+                <command name="vkCreateImagePipeSurfaceFUCHSIA"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_terminate_invocation" number="216" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Jesse Hall @critsec" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_terminate_invocation&quot;"    name="VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_217" number="217" author="GOOGLE" contact="Jesse Hall @critsec" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_GOOGLE_EXTENSION_217_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_217&quot;"           name="VK_GOOGLE_EXTENSION_217_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_metal_surface" number="218" type="instance" requires="VK_KHR_surface" platform="metal" supported="vulkan" author="EXT" contact="Dzmitry Malyshau @kvark">
+            <require>
+                <enum value="1"                                             name="VK_EXT_METAL_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_metal_surface&quot;"              name="VK_EXT_METAL_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT"/>
+                <type name="VkMetalSurfaceCreateFlagsEXT"/>
+                <type name="VkMetalSurfaceCreateInfoEXT"/>
+                <command name="vkCreateMetalSurfaceEXT"/>
+                <type name="CAMetalLayer"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_fragment_density_map" number="219" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Matthew Netsch @mnetsch" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_fragment_density_map&quot;"       name="VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"/>
+                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"/>
+                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT"/>
+                <enum bitpos="14" extends="VkImageCreateFlagBits"           name="VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT"/>
+                <enum offset="0"  extends="VkImageLayout"                   name="VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT"/>
+                <enum bitpos="24" extends="VkAccessFlagBits"                name="VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"/>
+                <enum bitpos="24" extends="VkFormatFeatureFlagBits"         name="VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
+                <enum bitpos="9"  extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
+                <enum bitpos="0"  extends="VkImageViewCreateFlagBits"       name="VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT"/>
+                <enum bitpos="23" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
+                <enum bitpos="0"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT"/>
+                <enum bitpos="1"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMapFeaturesEXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMapPropertiesEXT"/>
+                <type name="VkRenderPassFragmentDensityMapCreateInfoEXT"/>
+            </require>
+            <require extension="VK_KHR_format_feature_flags2">
+                <enum bitpos="24" extends="VkFormatFeatureFlagBits2KHR"     name="VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_220" number="220" author="EXT" contact="Dzmitry Malyshau @kvark" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_EXT_EXTENSION_220_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_220&quot;"               name="VK_EXT_EXTENSION_220_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_221" number="221" author="KHR" contact="Tobias Hector @tobski" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_KHR_EXTENSION_221_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_221&quot;"               name="VK_KHR_EXTENSION_221_EXTENSION_NAME"/>
+                <enum bitpos="0" extends="VkRenderPassCreateFlagBits"        name="VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_scalar_block_layout" number="222" requires="VK_KHR_get_physical_device_properties2" type="device" author="EXT" contact="Tobias Hector @tobski" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_scalar_block_layout&quot;"        name="VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME"/>
+                <type name="VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_223" number="223" author="EXT" contact="Tobias Hector @tobski" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_223_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_223&quot;"              name="VK_EXT_EXTENSION_223_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_hlsl_functionality1" number="224" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_hlsl_functionality1&quot;"     name="VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME"/>
+                <enum alias="VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION"   name="VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION" comment="Backwards-compatible alias containing a typo"/>
+                <enum alias="VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME" name="VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME" comment="Backwards-compatible alias containing a typo"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_decorate_string" number="225" type="device" author="GOOGLE" contact="Hai Nguyen @chaoticbob" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_DECORATE_STRING_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_decorate_string&quot;"         name="VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_subgroup_size_control" number="226" type="device" requiresCore="1.1" author="EXT" contact="Neil Henning @sheredom" supported="vulkan">
+            <require>
+                <enum value="2"                                                name="VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_subgroup_size_control&quot;"         name="VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME"/>
+                <type                                                          name="VkPhysicalDeviceSubgroupSizeControlFeaturesEXT"/>
+                <type                                                          name="VkPhysicalDeviceSubgroupSizeControlPropertiesEXT"/>
+                <type                                                          name="VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT"/>
+                <enum bitpos="0" extends="VkPipelineShaderStageCreateFlagBits" name="VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT"/>
+                <enum bitpos="1" extends="VkPipelineShaderStageCreateFlagBits" name="VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_fragment_shading_rate" number="227" type="device" requires="VK_KHR_create_renderpass2,VK_KHR_get_physical_device_properties2" author="KHR" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="2"                                                 name="VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_fragment_shading_rate&quot;" name="VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME"/>
+                <type name="VkFragmentShadingRateCombinerOpKHR"/>
+                <type name="VkFragmentShadingRateAttachmentInfoKHR"/>
+                <type name="VkPipelineFragmentShadingRateStateCreateInfoKHR"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateFeaturesKHR"/>
+                <type name="VkPhysicalDeviceFragmentShadingRatePropertiesKHR"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateKHR"/>
+                <command name="vkGetPhysicalDeviceFragmentShadingRatesKHR"/>
+                <command name="vkCmdSetFragmentShadingRateKHR"/>
+                <enum offset="3" extends="VkImageLayout" extnumber="165"        name="VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR"/>
+                <enum offset="0" extends="VkDynamicState"                       name="VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"/>
+                <enum offset="3" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"/>
+                <enum offset="4" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR"/>
+                <enum bitpos="23" extends="VkAccessFlagBits"                    name="VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+                <enum bitpos="8" extends="VkImageUsageFlagBits"                 name="VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum bitpos="22" extends="VkPipelineStageFlagBits"             name="VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum bitpos="30" extends="VkFormatFeatureFlagBits"             name="VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+            </require>
+            <require extension="VK_KHR_format_feature_flags2">
+                <enum bitpos="30" extends="VkFormatFeatureFlagBits2KHR"         name="VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_shader_core_properties2" number="228" type="device" author="AMD" contact="Matthaeus G. Chajdas @anteru" supported="vulkan" requires="VK_AMD_shader_core_properties">
+            <require>
+                <enum value="1"                                             name="VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_shader_core_properties2&quot;"    name="VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"/>
+                <type                                                       name="VkPhysicalDeviceShaderCoreProperties2AMD"/>
+                <type                                                       name="VkShaderCorePropertiesFlagBitsAMD"/>
+                <type                                                       name="VkShaderCorePropertiesFlagsAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_229" number="229" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_229_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_229&quot;"              name="VK_AMD_EXTENSION_229_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_device_coherent_memory" number="230" type="device" author="AMD" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_device_coherent_memory&quot;"     name="VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME"/>
+                <enum bitpos="6" extends="VkMemoryPropertyFlagBits"         name="VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD"/>
+                <enum bitpos="7" extends="VkMemoryPropertyFlagBits"         name="VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"/>
+                <type                                                       name="VkPhysicalDeviceCoherentMemoryFeaturesAMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_231" number="231" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_231_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_231&quot;"              name="VK_AMD_EXTENSION_231_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_232" number="232" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_232_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_232&quot;"              name="VK_AMD_EXTENSION_232_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_233" number="233" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_233_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_233&quot;"              name="VK_AMD_EXTENSION_233_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_234" number="234" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_234_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_234&quot;"              name="VK_AMD_EXTENSION_234_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_image_atomic_int64" number="235" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_image_atomic_int64&quot;"  name="VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_236" number="236" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_236_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_236&quot;"              name="VK_AMD_EXTENSION_236_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_spirv_1_4" number="237" type="device" requiresCore="1.1" requires="VK_KHR_shader_float_controls" author="KHR" contact="Jesse Hall @critsec" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SPIRV_1_4_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_spirv_1_4&quot;"                  name="VK_KHR_SPIRV_1_4_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_memory_budget" number="238" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_MEMORY_BUDGET_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_memory_budget&quot;"              name="VK_EXT_MEMORY_BUDGET_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceMemoryBudgetPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_memory_priority" number="239" type="device" requires="VK_KHR_get_physical_device_properties2"  author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_MEMORY_PRIORITY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_memory_priority&quot;"            name="VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceMemoryPriorityFeaturesEXT"/>
+                <type name="VkMemoryPriorityAllocateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_surface_protected_capabilities" number="240" type="instance" requiresCore="1.1" requires="VK_KHR_get_surface_capabilities2" author="KHR" contact="Sandeep Shinde @sashinde" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_surface_protected_capabilities&quot;"   name="VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR"/>
+                <type name="VkSurfaceProtectedCapabilitiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_dedicated_allocation_image_aliasing" number="241" type="device" requires="VK_KHR_dedicated_allocation" author="NVIDIA" contact="Nuno Subtil @nsubtil" supported="vulkan">
+            <require>
+                <enum value="1"                                                         name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_dedicated_allocation_image_aliasing&quot;"     name="VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"/>
+                <type name="VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_separate_depth_stencil_layouts" number="242" type="device" requires="VK_KHR_get_physical_device_properties2,VK_KHR_create_renderpass2" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                                   name="VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_separate_depth_stencil_layouts&quot;"   name="VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR" alias="VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL"/>
+                <enum extends="VkImageLayout"                               name="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR" alias="VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL"/>
+                <type name="VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"/>
+                <type name="VkAttachmentReferenceStencilLayoutKHR"/>
+                <type name="VkAttachmentDescriptionStencilLayoutKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_extension_243" number="243" author="INTEL" contact="Slawek Grajewski @sgrajewski" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_INTEL_EXTENSION_243_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_extension_243&quot;"             name="VK_INTEL_EXTENSION_243_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_MESA_extension_244" number="244" author="MESA" contact="Andres Rodriguez @lostgoat" supported="disabled">
+            <require>
+                <enum value="0"                                              name="VK_MESA_EXTENSION_244_SPEC_VERSION"/>
+                <enum value="&quot;VK_MESA_extension_244&quot;"              name="VK_MESA_EXTENSION_244_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_buffer_device_address" number="245" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Jeff Bolz @jeffbolznv"  deprecatedby="VK_KHR_buffer_device_address" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_buffer_device_address&quot;"      name="VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT" alias="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT"/>
+                <enum extends="VkBufferUsageFlagBits"                       name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT" alias="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
+                <enum extends="VkBufferCreateFlagBits"                      name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT" alias="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+                <enum extends="VkResult"                                    name="VK_ERROR_INVALID_DEVICE_ADDRESS_EXT" alias="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
+                <type name="VkPhysicalDeviceBufferAddressFeaturesEXT"/>
+                <type name="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT"/>
+                <type name="VkBufferDeviceAddressInfoEXT"/>
+                <type name="VkBufferDeviceAddressCreateInfoEXT"/>
+                <command name="vkGetBufferDeviceAddressEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_tooling_info" number="246" type="device" author="EXT" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_TOOLING_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_tooling_info&quot;"               name="VK_EXT_TOOLING_INFO_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT"/>
+                <type                                                       name="VkToolPurposeFlagBitsEXT"/>
+                <type                                                       name="VkToolPurposeFlagsEXT"/>
+                <type                                                       name="VkPhysicalDeviceToolPropertiesEXT"/>
+                <command                                                    name="vkGetPhysicalDeviceToolPropertiesEXT"/>
+            </require>
+            <require extension="VK_EXT_debug_report">
+                <enum bitpos="5" extends="VkToolPurposeFlagBitsEXT"         name="VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"/>
+            </require>
+            <require extension="VK_EXT_debug_marker">
+                <enum bitpos="6" extends="VkToolPurposeFlagBitsEXT"         name="VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"/>
+            </require>
+            <require extension="VK_EXT_debug_utils">
+                <enum bitpos="5" extends="VkToolPurposeFlagBitsEXT"         name="VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT"/>
+                <enum bitpos="6" extends="VkToolPurposeFlagBitsEXT"         name="VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_separate_stencil_usage" number="247" type="device" author="EXT" contact="Daniel Rakos @drakos-amd" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_separate_stencil_usage&quot;"     name="VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT" alias="VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO"/>
+                <type name="VkImageStencilUsageCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_validation_features" number="248" type="instance" author="LUNARG" contact="Karl Schultz @karl-lunarg" specialuse="debugging" supported="vulkan">
+            <require>
+                <enum value="5"                                             name="VK_EXT_VALIDATION_FEATURES_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_validation_features&quot;"        name="VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT"/>
+                <type name="VkValidationFeaturesEXT"/>
+                <type name="VkValidationFeatureEnableEXT"/>
+                <type name="VkValidationFeatureDisableEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_present_wait" number="249" type="device" requires="VK_KHR_swapchain,VK_KHR_present_id" author="KHR" contact="Keith Packard @keithp" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_PRESENT_WAIT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_present_wait&quot;"           name="VK_KHR_PRESENT_WAIT_EXTENSION_NAME"/>
+                <command name="vkWaitForPresentKHR"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"/>
+                <type name="VkPhysicalDevicePresentWaitFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_cooperative_matrix" number="250" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                              name="VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_cooperative_matrix&quot;"           name="VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
+                <enum offset="2" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"/>
+                <type name="VkCooperativeMatrixPropertiesNV"/>
+                <type name="VkScopeNV"/>
+                <type name="VkComponentTypeNV"/>
+                <type name="VkPhysicalDeviceCooperativeMatrixFeaturesNV"/>
+                <type name="VkPhysicalDeviceCooperativeMatrixPropertiesNV"/>
+                <command name="vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_coverage_reduction_mode" number="251" requires="VK_NV_framebuffer_mixed_samples" type="device" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_coverage_reduction_mode&quot;"     name="VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV"/>
+                <type name="VkPhysicalDeviceCoverageReductionModeFeaturesNV"/>
+                <type name="VkPipelineCoverageReductionStateCreateInfoNV"/>
+                <type name="VkPipelineCoverageReductionStateCreateFlagsNV"/>
+                <type name="VkCoverageReductionModeNV"/>
+                <type name="VkFramebufferMixedSamplesCombinationNV"/>
+                <command name="vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_fragment_shader_interlock" number="252" author="EXT" type="device" requires="VK_KHR_get_physical_device_properties2" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_fragment_shader_interlock&quot;"      name="VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_ycbcr_image_arrays" number="253" type="device" requires="VK_KHR_sampler_ycbcr_conversion" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_ycbcr_image_arrays&quot;"         name="VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_uniform_buffer_standard_layout" number="254" requires="VK_KHR_get_physical_device_properties2" type="device" author="KHR" contact="Graeme Leese @gnl21" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                                 name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_uniform_buffer_standard_layout&quot;" name="VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME"/>
+                <type                                                           name="VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_provoking_vertex" number="255" type="device" author="EXT" requires="VK_KHR_get_physical_device_properties2" contact="Jesse Hall @jessehall" specialuse="glemulation" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PROVOKING_VERTEX_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_provoking_vertex&quot;"           name="VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceProvokingVertexFeaturesEXT"/>
+                <type name="VkPhysicalDeviceProvokingVertexPropertiesEXT"/>
+                <type name="VkPipelineRasterizationProvokingVertexStateCreateInfoEXT"/>
+                <type name="VkProvokingVertexModeEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_full_screen_exclusive" number="256" type="device" author="EXT" requires="VK_KHR_get_physical_device_properties2,VK_KHR_surface,VK_KHR_get_surface_capabilities2,VK_KHR_swapchain" platform="win32" contact="James Jones @cubanismo" supported="vulkan">
+            <require>
+                <enum value="4"                                             name="VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_full_screen_exclusive&quot;"      name="VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT"/>
+                <enum offset="0" extends="VkResult" dir="-"                 name="VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT"/>
+                <type name="VkFullScreenExclusiveEXT"/>
+                <type name="VkSurfaceFullScreenExclusiveInfoEXT"/>
+                <type name="VkSurfaceCapabilitiesFullScreenExclusiveEXT"/>
+                <command name="vkGetPhysicalDeviceSurfacePresentModes2EXT"/>
+                <command name="vkAcquireFullScreenExclusiveModeEXT"/>
+                <command name="vkReleaseFullScreenExclusiveModeEXT"/>
+            </require>
+            <require extension="VK_KHR_win32_surface">
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT"/>
+                <type name="VkSurfaceFullScreenExclusiveWin32InfoEXT"/>
+            </require>
+            <require extension="VK_KHR_device_group">
+                <command name="vkGetDeviceGroupSurfacePresentModes2EXT"/>
+            </require>
+            <require feature="VK_VERSION_1_1">
+                <command name="vkGetDeviceGroupSurfacePresentModes2EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_headless_surface" number="257" type="instance" requires="VK_KHR_surface" author="EXT" contact="Lisa Wu @chengtianww" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_HEADLESS_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_headless_surface&quot;"               name="VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT"/>
+                <type name="VkHeadlessSurfaceCreateFlagsEXT"/>
+                <type name="VkHeadlessSurfaceCreateInfoEXT"/>
+                <command name="vkCreateHeadlessSurfaceEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_buffer_device_address" number="258" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="vulkan" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_buffer_device_address&quot;"      name="VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR" alias="VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR" alias="VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO"/>
+                <enum extends="VkBufferUsageFlagBits"                       name="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR" alias="VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT"/>
+                <enum extends="VkBufferCreateFlagBits"                      name="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" alias="VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+                <enum extends="VkMemoryAllocateFlagBits"                    name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT"/>
+                <enum extends="VkMemoryAllocateFlagBits"                    name="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR" alias="VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT"/>
+                <enum extends="VkResult"                                    name="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR" alias="VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS"/>
+                <type name="VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"/>
+                <type name="VkBufferDeviceAddressInfoKHR"/>
+                <type name="VkBufferOpaqueCaptureAddressCreateInfoKHR"/>
+                <type name="VkMemoryOpaqueCaptureAddressAllocateInfoKHR"/>
+                <type name="VkDeviceMemoryOpaqueCaptureAddressInfoKHR"/>
+                <command name="vkGetBufferDeviceAddressKHR"/>
+                <command name="vkGetBufferOpaqueCaptureAddressKHR"/>
+                <command name="vkGetDeviceMemoryOpaqueCaptureAddressKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_259" number="259" author="EXT" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_259_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_259&quot;"              name="VK_EXT_EXTENSION_259_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_line_rasterization" number="260" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Jeff Bolz @jeffbolznv" specialuse="cadsupport" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_LINE_RASTERIZATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_line_rasterization&quot;"         name="VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LINE_STIPPLE_EXT"/>
+                <type name="VkPhysicalDeviceLineRasterizationFeaturesEXT"/>
+                <type name="VkPhysicalDeviceLineRasterizationPropertiesEXT"/>
+                <type name="VkPipelineRasterizationLineStateCreateInfoEXT"/>
+                <type name="VkLineRasterizationModeEXT"/>
+                <command name="vkCmdSetLineStippleEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_atomic_float" number="261" type="device" author="NV" requires="VK_KHR_get_physical_device_properties2" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_atomic_float&quot;"        name="VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_host_query_reset" number="262" author="EXT" contact="Bas Nieuwenhuizen @BNieuwenhuizen" supported="vulkan" type="device" requires="VK_KHR_get_physical_device_properties2" promotedto="VK_VERSION_1_2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_HOST_QUERY_RESET_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_host_query_reset&quot;"           name="VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME"/>
+                <enum extends="VkStructureType"                             name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT" alias="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"/>
+                <type name="VkPhysicalDeviceHostQueryResetFeaturesEXT"/>
+                <command name="vkResetQueryPoolEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_263" number="263" author="GGP" contact="Jean-Francois Roy @jfroy" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_GGP_EXTENSION_263_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_263&quot;"              name="VK_GGP_EXTENSION_263_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_BRCM_extension_264" number="264" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_BRCM_EXTENSION_264_SPEC_VERSION"/>
+                <enum value="&quot;VK_BRCM_extension_264&quot;"             name="VK_BRCM_EXTENSION_264_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_BRCM_extension_265" number="265" author="BRCM" contact="Graeme Leese @gnl21" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_BRCM_EXTENSION_265_SPEC_VERSION"/>
+                <enum value="&quot;VK_BRCM_extension_265&quot;"             name="VK_BRCM_EXTENSION_265_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_index_type_uint8" number="266" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_index_type_uint8&quot;"           name="VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT"/>
+                <enum offset="0" extends="VkIndexType"                      name="VK_INDEX_TYPE_UINT8_EXT"/>
+                <type name="VkPhysicalDeviceIndexTypeUint8FeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_267" number="267" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_267_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_267&quot;"              name="VK_EXT_EXTENSION_267_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extended_dynamic_state" number="268" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extended_dynamic_state&quot;"     name="VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_CULL_MODE_EXT"/>
+                <enum offset="1" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_FRONT_FACE_EXT"/>
+                <enum offset="2" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT"/>
+                <enum offset="3" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT"/>
+                <enum offset="4" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT"/>
+                <enum offset="5" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT"/>
+                <enum offset="6" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT"/>
+                <enum offset="7" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT"/>
+                <enum offset="8" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT"/>
+                <enum offset="9" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT"/>
+                <enum offset="10" extends="VkDynamicState"                  name="VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT"/>
+                <enum offset="11" extends="VkDynamicState"                  name="VK_DYNAMIC_STATE_STENCIL_OP_EXT"/>
+                <type name="VkPhysicalDeviceExtendedDynamicStateFeaturesEXT"/>
+                <command name="vkCmdSetCullModeEXT"/>
+                <command name="vkCmdSetFrontFaceEXT"/>
+                <command name="vkCmdSetPrimitiveTopologyEXT"/>
+                <command name="vkCmdSetViewportWithCountEXT"/>
+                <command name="vkCmdSetScissorWithCountEXT"/>
+                <command name="vkCmdBindVertexBuffers2EXT"/>
+                <command name="vkCmdSetDepthTestEnableEXT"/>
+                <command name="vkCmdSetDepthWriteEnableEXT"/>
+                <command name="vkCmdSetDepthCompareOpEXT"/>
+                <command name="vkCmdSetDepthBoundsTestEnableEXT"/>
+                <command name="vkCmdSetStencilTestEnableEXT"/>
+                <command name="vkCmdSetStencilOpEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_deferred_host_operations" number="269" type="device" author="KHR" contact="Josh Barczak @jbarczak" supported="vulkan">
+            <require>
+                <enum value="4"                                             name="VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_deferred_host_operations&quot;"   name="VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR"/>
+                <type name="VkDeferredOperationKHR"/>
+                <command name="vkCreateDeferredOperationKHR"/>
+                <command name="vkDestroyDeferredOperationKHR"/>
+                <command name="vkGetDeferredOperationMaxConcurrencyKHR"/>
+                <command name="vkGetDeferredOperationResultKHR"/>
+                <command name="vkDeferredOperationJoinKHR" />
+                <enum extends="VkResult"       offset="0"       name="VK_THREAD_IDLE_KHR" />
+                <enum extends="VkResult"       offset="1"       name="VK_THREAD_DONE_KHR" />
+                <enum extends="VkResult"       offset="2"       name="VK_OPERATION_DEFERRED_KHR" />
+                <enum extends="VkResult"       offset="3"       name="VK_OPERATION_NOT_DEFERRED_KHR" />
+            </require>
+        </extension>
+        <extension name="VK_KHR_pipeline_executable_properties" number="270" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Jason Ekstrand @jekstrand" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_pipeline_executable_properties&quot;"   name="VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR"/>
+                <enum bitpos="6" extends="VkPipelineCreateFlagBits"     name="VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR"/>
+                <enum bitpos="7" extends="VkPipelineCreateFlagBits"     name="VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR"/>
+                <type name="VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR"/>
+                <type name="VkPipelineInfoKHR"/>
+                <type name="VkPipelineExecutablePropertiesKHR"/>
+                <type name="VkPipelineExecutableInfoKHR"/>
+                <type name="VkPipelineExecutableStatisticFormatKHR"/>
+                <type name="VkPipelineExecutableStatisticValueKHR"/>
+                <type name="VkPipelineExecutableStatisticKHR"/>
+                <type name="VkPipelineExecutableInternalRepresentationKHR"/>
+                <command name="vkGetPipelineExecutablePropertiesKHR"/>
+                <command name="vkGetPipelineExecutableStatisticsKHR"/>
+                <command name="vkGetPipelineExecutableInternalRepresentationsKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_extension_271" number="271" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_INTEL_EXTENSION_271_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_extension_271&quot;"            name="VK_INTEL_EXTENSION_271_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_extension_272" number="272" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_INTEL_EXTENSION_272_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_extension_272&quot;"            name="VK_INTEL_EXTENSION_272_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_INTEL_extension_273" number="273" type="device" author="INTEL" contact="Jason Ekstrand @jekstrand" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_INTEL_EXTENSION_273_SPEC_VERSION"/>
+                <enum value="&quot;VK_INTEL_extension_273&quot;"            name="VK_INTEL_EXTENSION_273_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_atomic_float2" number="274" type="device" requires="VK_EXT_shader_atomic_float" author="EXT" contact="Jason Ekstrand @jekstrand" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_atomic_float2&quot;"       name="VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_275" number="275" type="instance" author="KHR" contact="Lionel Landwerlin @llandwerlin" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_275_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_275&quot;"              name="VK_KHR_EXTENSION_275_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_276" number="276" type="device" author="KHR" contact="James Jones @cubanismo" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_276_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_276&quot;"              name="VK_KHR_EXTENSION_276_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_shader_demote_to_helper_invocation" number="277" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_shader_demote_to_helper_invocation&quot;" name="VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                          name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_device_generated_commands" number="278" type="device" requiresCore="1.1" requires="VK_KHR_buffer_device_address" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
+            <require>
+                <comment>
+                    This extension requires buffer_device_address functionality.
+                    VK_EXT_buffer_device_address is also acceptable, but since it is deprecated the KHR version is preferred.
+                </comment>
+                <enum value="3"                                             name="VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_device_generated_commands&quot;"   name="VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV"/>
+                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"/>
+                <enum bitpos="18" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV"/>
+                <enum bitpos="17" extends="VkPipelineStageFlagBits"         name="VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV"/>
+                <enum bitpos="17" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV"/>
+                <enum bitpos="18" extends="VkAccessFlagBits"                name="VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV"/>
+                <type name="VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV"/>
+                <type name="VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV"/>
+                <type name="VkGraphicsShaderGroupCreateInfoNV"/>
+                <type name="VkGraphicsPipelineShaderGroupsCreateInfoNV"/>
+                <type name="VkBindShaderGroupIndirectCommandNV"/>
+                <type name="VkBindIndexBufferIndirectCommandNV"/>
+                <type name="VkBindVertexBufferIndirectCommandNV"/>
+                <type name="VkSetStateFlagsIndirectCommandNV"/>
+                <type name="VkIndirectStateFlagBitsNV"/>
+                <type name="VkIndirectStateFlagsNV"/>
+                <type name="VkIndirectCommandsLayoutNV"/>
+                <type name="VkIndirectCommandsTokenTypeNV"/>
+                <type name="VkIndirectCommandsLayoutUsageFlagBitsNV"/>
+                <type name="VkIndirectCommandsLayoutUsageFlagsNV"/>
+                <type name="VkIndirectCommandsStreamNV"/>
+                <type name="VkIndirectCommandsLayoutTokenNV"/>
+                <type name="VkIndirectCommandsLayoutCreateInfoNV"/>
+                <type name="VkGeneratedCommandsInfoNV"/>
+                <type name="VkGeneratedCommandsMemoryRequirementsInfoNV"/>
+                <command name="vkGetGeneratedCommandsMemoryRequirementsNV"/>
+                <command name="vkCmdPreprocessGeneratedCommandsNV"/>
+                <command name="vkCmdExecuteGeneratedCommandsNV"/>
+                <command name="vkCmdBindPipelineShaderGroupNV"/>
+                <command name="vkCreateIndirectCommandsLayoutNV"/>
+                <command name="vkDestroyIndirectCommandsLayoutNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_inherited_viewport_scissor" number="279" type="device" author="NV" contact="David Zhao Akeley @akeley98" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_inherited_viewport_scissor&quot;"  name="VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV"/>
+                <type name="VkPhysicalDeviceInheritedViewportScissorFeaturesNV"/>
+                <type name="VkCommandBufferInheritanceViewportScissorInfoNV"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_280" number="280" type="device" author="KHR" contact="Kevin Petit @kevinpetit" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_280_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_280&quot;"              name="VK_KHR_EXTENSION_280_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_integer_dot_product" number="281" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Kevin Petit @kevinpetit" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_integer_dot_product&quot;" name="VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR"/>
+                <type name="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR"/>
+                <type name="VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_texel_buffer_alignment" number="282" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Jeff Bolz @jeffbolznv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_texel_buffer_alignment&quot;"     name="VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT"/>
+                <type name="VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_render_pass_transform" number="283" type="device" requires="VK_KHR_swapchain,VK_KHR_surface" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_render_pass_transform&quot;"     name="VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM"/>
+                <enum bitpos="1" extends="VkRenderPassCreateFlagBits"       name="VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM"/>
+                <type name="VkRenderPassTransformBeginInfoQCOM"/>
+                <type name="VkCommandBufferInheritanceRenderPassTransformInfoQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_284" number="284" type="device" author="EXT" contact="Samuel Pitoiset @hakzsam" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_284_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_284&quot;"              name="VK_EXT_EXTENSION_284_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_device_memory_report" number="285" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Yiwei Zhang @zhangyiwei" specialuse="devtools" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_device_memory_report&quot;"       name="VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT"/>
+                <type name="VkPhysicalDeviceDeviceMemoryReportFeaturesEXT"/>
+                <type name="VkDeviceDeviceMemoryReportCreateInfoEXT"/>
+                <type name="VkDeviceMemoryReportCallbackDataEXT"/>
+                <type name="VkDeviceMemoryReportFlagsEXT"/>
+                <type name="VkDeviceMemoryReportEventTypeEXT"/>
+                <type name="PFN_vkDeviceMemoryReportCallbackEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_acquire_drm_display" number="286" type="instance" requires="VK_EXT_direct_mode_display" author="EXT" contact="Drew DeVault sir@cmpwn.com" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_acquire_drm_display&quot;"        name="VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkAcquireDrmDisplayEXT"/>
+                <command name="vkGetDrmDisplayEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_robustness2" number="287"  type="device" author="EXT" contact="Liam Middlebrook @liam-middlebrook" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_EXT_ROBUSTNESS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_robustness2&quot;"                    name="VK_EXT_ROBUSTNESS_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceRobustness2FeaturesEXT"/>
+                <type name="VkPhysicalDeviceRobustness2PropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_custom_border_color" number="288" type="device" author="EXT" contact="Liam Middlebrook @liam-middlebrook" specialuse="glemulation,d3demulation" supported="vulkan">
+            <require>
+                <enum value="12"                                            name="VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_custom_border_color&quot;"        name="VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"/>
+                <enum offset="3" extends="VkBorderColor"                    name="VK_BORDER_COLOR_FLOAT_CUSTOM_EXT"/>
+                <enum offset="4" extends="VkBorderColor"                    name="VK_BORDER_COLOR_INT_CUSTOM_EXT"/>
+                <type name="VkSamplerCustomBorderColorCreateInfoEXT"/>
+                <type name="VkPhysicalDeviceCustomBorderColorPropertiesEXT"/>
+                <type name="VkPhysicalDeviceCustomBorderColorFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_289" number="289" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <comment>
+                    These enums are present only to inform downstream
+                    consumers like KTX2. There is no actual Vulkan extension
+                    corresponding to the enums.
+                </comment>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_289_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_289&quot;"              name="VK_EXT_EXTENSION_289_EXTENSION_NAME"/>
+                <enum extends="VkFormat" extnumber="289" offset="0" name="VK_FORMAT_ASTC_3x3x3_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="1" name="VK_FORMAT_ASTC_3x3x3_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="2" name="VK_FORMAT_ASTC_3x3x3_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="3" name="VK_FORMAT_ASTC_4x3x3_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="4" name="VK_FORMAT_ASTC_4x3x3_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="5" name="VK_FORMAT_ASTC_4x3x3_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="6" name="VK_FORMAT_ASTC_4x4x3_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="7" name="VK_FORMAT_ASTC_4x4x3_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="8" name="VK_FORMAT_ASTC_4x4x3_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="9" name="VK_FORMAT_ASTC_4x4x4_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="10" name="VK_FORMAT_ASTC_4x4x4_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="11" name="VK_FORMAT_ASTC_4x4x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="12" name="VK_FORMAT_ASTC_5x4x4_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="13" name="VK_FORMAT_ASTC_5x4x4_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="14" name="VK_FORMAT_ASTC_5x4x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="15" name="VK_FORMAT_ASTC_5x5x4_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="16" name="VK_FORMAT_ASTC_5x5x4_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="17" name="VK_FORMAT_ASTC_5x5x4_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="18" name="VK_FORMAT_ASTC_5x5x5_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="19" name="VK_FORMAT_ASTC_5x5x5_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="20" name="VK_FORMAT_ASTC_5x5x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="21" name="VK_FORMAT_ASTC_6x5x5_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="22" name="VK_FORMAT_ASTC_6x5x5_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="23" name="VK_FORMAT_ASTC_6x5x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="24" name="VK_FORMAT_ASTC_6x6x5_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="25" name="VK_FORMAT_ASTC_6x6x5_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="26" name="VK_FORMAT_ASTC_6x6x5_SFLOAT_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="27" name="VK_FORMAT_ASTC_6x6x6_UNORM_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="28" name="VK_FORMAT_ASTC_6x6x6_SRGB_BLOCK_EXT"/>
+                <enum extends="VkFormat" extnumber="289" offset="29" name="VK_FORMAT_ASTC_6x6x6_SFLOAT_BLOCK_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_user_type" number="290" type="device" author="GOOGLE" contact="Kaye Mason @chaleur" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_GOOGLE_USER_TYPE_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_user_type&quot;"               name="VK_GOOGLE_USER_TYPE_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_pipeline_library" number="291" type="device" author="KHR" contact="Christoph Kubisch @pixeljetstream" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_pipeline_library&quot;"           name="VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME"/>
+                <enum bitpos="11" extends="VkPipelineCreateFlagBits"        name="VK_PIPELINE_CREATE_LIBRARY_BIT_KHR"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR"/>
+                <type name="VkPipelineLibraryCreateInfoKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_292" number="292" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_292_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_292&quot;"               name="VK_NV_EXTENSION_292_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_293" number="293" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_293_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_293&quot;"               name="VK_NV_EXTENSION_293_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_non_semantic_info" number="294" type="device" author="KHR" contact="Baldur Karlsson @baldurk" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_non_semantic_info&quot;"   name="VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_present_id" number="295" type="device" requires="VK_KHR_swapchain" author="KHR" contact="Keith Packard @keithp" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_KHR_PRESENT_ID_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_present_id&quot;"             name="VK_KHR_PRESENT_ID_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PRESENT_ID_KHR"/>
+                <type name="VkPresentIdKHR"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"/>
+                <type name="VkPhysicalDevicePresentIdFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_private_data" number="296" type="device" author="NV" contact="Matthew Rusch @mattruschnv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PRIVATE_DATA_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_private_data&quot;"               name="VK_EXT_PRIVATE_DATA_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkObjectType"                     name="VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT"/>
+                <type name="VkPhysicalDevicePrivateDataFeaturesEXT"/>
+                <type name="VkDevicePrivateDataCreateInfoEXT"/>
+                <type name="VkPrivateDataSlotCreateInfoEXT"/>
+                <type name="VkPrivateDataSlotEXT"/>
+                <type name="VkPrivateDataSlotCreateFlagsEXT"/>
+                <type name="VkPrivateDataSlotCreateFlagBitsEXT"/>
+                <command name="vkCreatePrivateDataSlotEXT"/>
+                <command name="vkDestroyPrivateDataSlotEXT"/>
+                <command name="vkSetPrivateDataEXT"/>
+                <command name="vkGetPrivateDataEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_297" number="297" author="KHR" contact="Corentin Wallez @Kangz" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_297_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_297&quot;"              name="VK_KHR_EXTENSION_297_EXTENSION_NAME"/>
+                <enum bitpos="3" extends="VkPipelineShaderStageCreateFlagBits"  name="VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_3_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pipeline_creation_cache_control" number="298" type="device" author="AMD" contact="Gregory Grebe @grgrebe_amd" supported="vulkan">
+            <require>
+                <enum value="3" name="VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pipeline_creation_cache_control&quot;"
+                    name="VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"
+                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT"/>
+                <type name="VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT"/>
+                <enum bitpos="8"  extends="VkPipelineCreateFlagBits"
+                    name="VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT"/>
+                <enum bitpos="9" extends="VkPipelineCreateFlagBits"
+                    name="VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT"/>
+                <enum extends="VkResult" offset="0" name="VK_PIPELINE_COMPILE_REQUIRED_EXT"/>
+                <enum extends="VkResult"            name="VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT" alias="VK_PIPELINE_COMPILE_REQUIRED_EXT"/>
+                <enum bitpos="0"  extends="VkPipelineCacheCreateFlagBits"
+                    name="VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT"/>
+                <type name="VkPipelineCacheCreateFlagBits" comment="This is a temporary workaround for processors not recognizing that VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT above also requires this type"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_299" number="299" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_299_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_299&quot;"              name="VK_KHR_EXTENSION_299_EXTENSION_NAME"/>
+                <enum bitpos="2"  extends="VkMemoryHeapFlagBits"            name="VK_MEMORY_HEAP_RESERVED_2_BIT_KHR"/>
+                <enum             extends="VkPipelineCacheCreateFlagBits"   name="VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_KHR" alias="VK_PIPELINE_CACHE_CREATE_RESERVED_1_BIT_EXT"/>
+                <enum bitpos="2"  extends="VkPipelineCacheCreateFlagBits"   name="VK_PIPELINE_CACHE_CREATE_RESERVED_2_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_video_encode_queue" number="300"  type="device" requires="VK_KHR_video_queue,VK_KHR_synchronization2" author="KHR" contact="ahmed.abdelkalek@amd.com" provisional="true" platform="provisional" supported="vulkan">
+            <require>
+                <enum value="3"                                         name="VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_video_encode_queue&quot;"     name="VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME"/>
+                <enum bitpos="27" extends="VkPipelineStageFlagBits2KHR" name="VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS" />
+                <enum bitpos="37" extends="VkAccessFlagBits2KHR"        name="VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS" />
+                <enum bitpos="38" extends="VkAccessFlagBits2KHR"        name="VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="6" extends="VkQueueFlagBits"              name="VK_QUEUE_VIDEO_ENCODE_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="15" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="16" extends="VkBufferUsageFlagBits"       name="VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="13" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="14" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="15" extends="VkImageUsageFlagBits"        name="VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="27" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="28" extends="VkFormatFeatureFlagBits"     name="VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="1" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="2" extends="VkImageLayout"                name="VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum offset="0" extends="VkQueryType"                  name="VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+
+                <type name="VkVideoEncodeFlagBitsKHR"/>
+                <type name="VkVideoEncodeFlagsKHR"/>
+                <type name="VkVideoEncodeInfoKHR"/>
+
+                <type name="VkVideoEncodeRateControlFlagBitsKHR"/>
+                <type name="VkVideoEncodeRateControlFlagsKHR"/>
+                <type name="VkVideoEncodeRateControlModeFlagBitsKHR"/>
+                <type name="VkVideoEncodeRateControlModeFlagsKHR"/>
+
+                <type name="VkVideoEncodeRateControlInfoKHR"/>
+                <command name="vkCmdEncodeVideoKHR"/>
+            </require>
+            <require extension="VK_KHR_format_feature_flags2">
+                <enum bitpos="27" extends="VkFormatFeatureFlagBits2KHR"     name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+                <enum bitpos="28" extends="VkFormatFeatureFlagBits2KHR"     name="VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR" protect="VK_ENABLE_BETA_EXTENSIONS"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_device_diagnostics_config" number="301" type="device" requires="VK_KHR_get_physical_device_properties2" author="NV" contact="Kedarnath Thangudu @kthangudu" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_device_diagnostics_config&quot;"   name="VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"/>
+                <enum offset="1" extends="VkStructureType" name="VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV"/>
+                <type name="VkPhysicalDeviceDiagnosticsConfigFeaturesNV"/>
+                <type name="VkDeviceDiagnosticsConfigCreateInfoNV"/>
+                <type name="VkDeviceDiagnosticsConfigFlagsNV"/>
+                <type name="VkDeviceDiagnosticsConfigFlagBitsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_render_pass_store_ops" number="302" type="device" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_render_pass_store_ops&quot;"     name="VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME"/>
+                <enum extends="VkAttachmentStoreOp"                         name="VK_ATTACHMENT_STORE_OP_NONE_QCOM" alias="VK_ATTACHMENT_STORE_OP_NONE_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_303" number="303" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_303_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_303&quot;"             name="VK_QCOM_EXTENSION_303_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_304" number="304" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_304_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_304&quot;"             name="VK_QCOM_EXTENSION_304_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_305" number="305" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_305_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_305&quot;"             name="VK_QCOM_EXTENSION_305_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_306" number="306" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_306_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_306&quot;"             name="VK_QCOM_EXTENSION_306_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_307" number="307" author="QCOM" contact="Bill Licea-Kane @wwlk" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_307_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_307&quot;"             name="VK_QCOM_EXTENSION_307_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_308" number="308" type="device" author="NV" contact="Tristan Lorach @tlorach" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_308_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_308&quot;"               name="VK_NV_EXTENSION_308_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_309" number="309" author="KHR" contact="Aidan Fabius @afabius" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_309_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_309&quot;"              name="VK_KHR_EXTENSION_309_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_310" number="310" author="QCOM" contact="Jeff Leger @jackohound" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_QCOM_EXTENSION_310_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_310&quot;"             name="VK_QCOM_EXTENSION_310_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RESERVED_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_311" number="311" author="NV" contact="Charles Hansen @cshansen" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_311_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_311&quot;"               name="VK_NV_EXTENSION_311_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_312" number="312" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_312_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_312&quot;"              name="VK_EXT_EXTENSION_312_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_313" number="313" author="MVK" contact="Bill Hollings @billhollings" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_313_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_313&quot;"              name="VK_EXT_EXTENSION_313_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_314" number="314" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_314_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_314&quot;"              name="VK_AMD_EXTENSION_314_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_synchronization2" number="315" type="device" author="KHR" requires="VK_KHR_get_physical_device_properties2" contact="Tobias Hector @tobski" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_synchronization2&quot;"           name="VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR"/>
+                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR"/>
+                <enum offset="2"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR"/>
+                <enum offset="3"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR"/>
+                <enum offset="4"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR"/>
+                <enum offset="5"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR"/>
+                <enum offset="6"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR"/>
+                <enum offset="7"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR"/>
+                <enum bitpos="0"  extends="VkEventCreateFlagBits"           name="VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR"/>
+                <enum offset="0"  extends="VkImageLayout"                   name="VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR"/>
+                <enum offset="1"  extends="VkImageLayout"                   name="VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR"/>
+                <enum value="0"  extends="VkPipelineStageFlagBits"          name="VK_PIPELINE_STAGE_NONE_KHR"/>
+                <enum value="0"  extends="VkAccessFlagBits"                 name="VK_ACCESS_NONE_KHR"/>
+                <type name="VkFlags64"/>
+                <type name="VkPipelineStageFlags2KHR"/>
+                <type name="VkPipelineStageFlagBits2KHR"/>
+                <type name="VkAccessFlags2KHR"/>
+                <type name="VkAccessFlagBits2KHR"/>
+                <type name="VkMemoryBarrier2KHR"/>
+                <type name="VkBufferMemoryBarrier2KHR"/>
+                <type name="VkImageMemoryBarrier2KHR"/>
+                <type name="VkDependencyInfoKHR"/>
+                <type name="VkSubmitInfo2KHR"/>
+                <type name="VkSemaphoreSubmitInfoKHR"/>
+                <type name="VkCommandBufferSubmitInfoKHR"/>
+                <type name="VkSubmitFlagBitsKHR"/>
+                <type name="VkSubmitFlagsKHR"/>
+                <type name="VkPhysicalDeviceSynchronization2FeaturesKHR"/>
+                <command name="vkCmdSetEvent2KHR"/>
+                <command name="vkCmdResetEvent2KHR"/>
+                <command name="vkCmdWaitEvents2KHR"/>
+                <command name="vkCmdPipelineBarrier2KHR"/>
+                <command name="vkCmdWriteTimestamp2KHR"/>
+                <command name="vkQueueSubmit2KHR"/>
+            </require>
+            <require extension="VK_EXT_transform_feedback">
+                <enum bitpos="24" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT"/>
+                <enum bitpos="25" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT"/>
+                <enum bitpos="26" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT"/>
+                <enum bitpos="27" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT"/>
+            </require>
+            <require extension="VK_EXT_conditional_rendering">
+                <enum bitpos="18" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT" comment="A pipeline stage for conditional rendering predicate fetch"/>
+                <enum bitpos="20" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT"  comment="read access flag for reading conditional rendering predicate"/>
+            </require>
+            <require extension="VK_NV_device_generated_commands">
+                <enum bitpos="17" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV"/>
+                <enum bitpos="17" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV"/>
+                <enum bitpos="18" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV"/>
+            </require>
+            <require extension="VK_KHR_fragment_shading_rate">
+                <enum bitpos="22" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum bitpos="23" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+            </require>
+            <require extension="VK_NV_shading_rate_image">
+                <enum extends="VkPipelineStageFlagBits2KHR"                 name="VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV" alias="VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits2KHR"                        name="VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV"    alias="VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR"/>
+            </require>
+            <require extension="VK_KHR_acceleration_structure">
+                <enum bitpos="25" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum bitpos="21" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum bitpos="22" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+            </require>
+            <require extension="VK_KHR_ray_tracing_pipeline">
+                <enum bitpos="21" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"/>
+            </require>
+            <require extension="VK_NV_ray_tracing">
+                <enum extends="VkPipelineStageFlagBits2KHR"                 name="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV" alias="VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR"/>
+                <enum extends="VkPipelineStageFlagBits2KHR"                 name="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV" alias="VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits2KHR"                        name="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV" alias="VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR"/>
+                <enum extends="VkAccessFlagBits2KHR"                        name="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV" alias="VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR"/>
+            </require>
+            <require extension="VK_EXT_fragment_density_map">
+                <enum bitpos="23" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT"/>
+                <enum bitpos="24" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT"/>
+            </require>
+            <require extension="VK_EXT_blend_operation_advanced">
+                <enum bitpos="19" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT"/>
+            </require>
+            <require extension="VK_NV_mesh_shader">
+                <enum bitpos="19" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV"/>
+                <enum bitpos="20" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV"/>
+            </require>
+            <require extension="VK_AMD_buffer_marker">
+                <command name="vkCmdWriteBufferMarker2AMD"/>
+            </require>
+            <require extension="VK_NV_device_diagnostic_checkpoints">
+                <type name="VkQueueFamilyCheckpointProperties2NV"/>
+                <type name="VkCheckpointData2NV"/>
+                <command name="vkGetQueueCheckpointData2NV"/>
+                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV"/>
+                <enum offset="9" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_316" number="316" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_316_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_316&quot;"              name="VK_AMD_EXTENSION_316_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_317" number="317" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_317_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_317&quot;"              name="VK_AMD_EXTENSION_317_EXTENSION_NAME"/>
+                <enum bitpos="4" extends="VkDescriptorSetLayoutCreateFlagBits"  name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_4_BIT_AMD"/>
+                <enum bitpos="21" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_RESERVED_21_BIT_AMD"/>
+                <enum bitpos="22" extends="VkBufferUsageFlagBits"               name="VK_BUFFER_USAGE_RESERVED_22_BIT_AMD"/>
+                <enum bitpos="5" extends="VkBufferCreateFlagBits"               name="VK_BUFFER_CREATE_RESERVED_5_BIT_AMD"/>
+                <enum bitpos="16" extends="VkImageCreateFlagBits"               name="VK_IMAGE_CREATE_RESERVED_16_BIT_AMD"/>
+                <enum bitpos="3" extends="VkSamplerCreateFlagBits"              name="VK_SAMPLER_CREATE_RESERVED_3_BIT_AMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_318" number="318" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_318_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_318&quot;"              name="VK_AMD_EXTENSION_318_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_319" number="319" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_319_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_319&quot;"              name="VK_AMD_EXTENSION_319_EXTENSION_NAME"/>
+                <enum bitpos="3" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_RESERVED_3_BIT_AMD"/>
+                <enum bitpos="0" extends="VkPipelineLayoutCreateFlagBits" name="VK_PIPELINE_LAYOUT_CREATE_RESERVED_0_BIT_AMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_320" number="320" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_320_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_320&quot;"              name="VK_AMD_EXTENSION_320_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_321" number="321" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_321_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_321&quot;"              name="VK_AMD_EXTENSION_321_EXTENSION_NAME"/>
+                <enum bitpos="23" extends="VkPipelineCreateFlagBits"            name="VK_PIPELINE_CREATE_RESERVED_23_BIT_AMD"/>
+                <enum bitpos="10" extends="VkPipelineCreateFlagBits"            name="VK_PIPELINE_CREATE_RESERVED_10_BIT_AMD"/>
+                <enum bitpos="1"  extends="VkPipelineLayoutCreateFlagBits"      name="VK_PIPELINE_LAYOUT_CREATE_RESERVED_1_BIT_AMD"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_322" number="322" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_322_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_322&quot;"              name="VK_AMD_EXTENSION_322_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_AMD_extension_323" number="323" author="AMD" contact="Martin Dinkov @mdinkov" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_AMD_EXTENSION_323_SPEC_VERSION"/>
+                <enum value="&quot;VK_AMD_extension_323&quot;"              name="VK_AMD_EXTENSION_323_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_shader_subgroup_uniform_control_flow" number="324" type="device" requiresCore="1.1" author="KHR" contact="Alan Baker @alan-baker" supported="vulkan">
+            <require>
+                <enum value="1" name="VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_shader_subgroup_uniform_control_flow&quot;" name="VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_325" number="325" author="KHR" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_325_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_325&quot;"              name="VK_KHR_EXTENSION_325_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_zero_initialize_workgroup_memory" number="326" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Alan Baker @alan-baker" supported="vulkan">
+            <require>
+                <enum value="1" name="VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_zero_initialize_workgroup_memory&quot;" name="VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_fragment_shading_rate_enums" number="327" type="device" requires="VK_KHR_fragment_shading_rate" author="NV" contact="Pat Brown @nvpbrown" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_fragment_shading_rate_enums&quot;" name="VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"/>
+                <enum offset="1" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"/>
+                <enum offset="2" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV"/>
+                <type name="VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV"/>
+                <type name="VkPipelineFragmentShadingRateEnumStateCreateInfoNV"/>
+                <type name="VkFragmentShadingRateNV"/>
+                <type name="VkFragmentShadingRateTypeNV"/>
+                <command name="vkCmdSetFragmentShadingRateEnumNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_ray_tracing_motion_blur" number="328" type="device" requires="VK_KHR_ray_tracing_pipeline" author="NV" contact="Eric Werness" supported="vulkan">
+            <require>
+                <enum value="1"                                                    name="VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_ray_tracing_motion_blur&quot;"            name="VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV"/>
+                <enum offset="1" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"/>
+                <enum offset="2" extends="VkStructureType"                         name="VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV"/>
+                <enum bitpos="5" extends="VkBuildAccelerationStructureFlagBitsKHR" name="VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV"/>
+                <enum bitpos="2" extends="VkAccelerationStructureCreateFlagBitsKHR" name="VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV"/>
+                <enum bitpos="20" extends="VkPipelineCreateFlagBits"               name="VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV"/>
+                <type name="VkAccelerationStructureGeometryMotionTrianglesDataNV"/>
+                <type name="VkAccelerationStructureMotionInfoNV"/>
+                <type name="VkAccelerationStructureMotionInstanceNV"/>
+                <type name="VkAccelerationStructureMotionInstanceDataNV"/>
+                <type name="VkAccelerationStructureMatrixMotionInstanceNV"/>
+                <type name="VkAccelerationStructureSRTMotionInstanceNV"/>
+                <type name="VkSRTDataNV"/>
+                <type name="VkAccelerationStructureMotionInstanceTypeNV"/>
+                <type name="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV"/>
+                <type name="VkAccelerationStructureMotionInfoFlagsNV"/>
+                <type name="VkAccelerationStructureMotionInstanceFlagsNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_329" number="329" author="NV" contact="Pat Brown @nvpbrown" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_329_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_329&quot;"               name="VK_NV_EXTENSION_329_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_330" number="330" author="NV" contact="Liam Middlebrook @liam-middlebrook" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_330_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_330&quot;"               name="VK_NV_EXTENSION_330_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_ycbcr_2plane_444_formats" number="331" type="device" requires="VK_KHR_sampler_ycbcr_conversion" author="EXT" contact="Tony Zlatinski @tzlatinski" supported="vulkan">
+            <require>
+                <enum value="1"                                           name="VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_ycbcr_2plane_444_formats&quot;" name="VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"/>
+                <enum offset="0" extends="VkFormat"                       name="VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT"/>
+                <enum offset="1" extends="VkFormat"                       name="VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT"/>
+                <enum offset="2" extends="VkFormat"                       name="VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT"/>
+                <enum offset="3" extends="VkFormat"                       name="VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT"/>
+                <type name="VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_332" number="332" author="NV" contact="Tony Zlatinski @tzlatinski" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_332_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_332&quot;"               name="VK_NV_EXTENSION_332_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_fragment_density_map2" number="333" type="device" requires="VK_EXT_fragment_density_map" author="EXT" contact="Matthew Netsch @mnetsch" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_fragment_density_map2&quot;"      name="VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME"/>
+                <enum offset="0"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"/>
+                <enum offset="1"  extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"/>
+                <enum bitpos="1"  extends="VkImageViewCreateFlagBits"       name="VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMap2FeaturesEXT"/>
+                <type name="VkPhysicalDeviceFragmentDensityMap2PropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_rotated_copy_commands" number="334" type="device" requires="VK_KHR_swapchain,VK_KHR_copy_commands2" author="QCOM" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_rotated_copy_commands&quot;"     name="VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM"/>
+                <type name="VkCopyCommandTransformInfoQCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_335" number="335" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_335_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_335&quot;"              name="VK_KHR_EXTENSION_335_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_image_robustness" number="336" type="device" author="EXT" contact="Graeme Leese @gnl21" supported="vulkan" requires="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_image_robustness&quot;"           name="VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT"/>
+                <type name="VkPhysicalDeviceImageRobustnessFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_workgroup_memory_explicit_layout" number="337" type="device" requires="VK_KHR_get_physical_device_properties2" author="KHR" contact="Caio Marcelo de Oliveira Filho @cmarcelo" supported="vulkan">
+            <require>
+                <enum value="1"                                                      name="VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_workgroup_memory_explicit_layout&quot;"    name="VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                           name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"/>
+                <type name="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_copy_commands2" number="338" author="KHR" type="device" contact="Jeff Leger @jackohound" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_COPY_COMMANDS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_copy_commands2&quot;"             name="VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR"/>
+                <enum offset="3" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR"/>
+                <enum offset="4" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR"/>
+                <enum offset="5" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR"/>
+                <enum offset="6" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR"/>
+                <enum offset="7" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR"/>
+                <enum offset="8" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR"/>
+                <enum offset="9" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR"/>
+                <enum offset="10" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR"/>
+                <type name="VkCopyBufferInfo2KHR"/>
+                <type name="VkCopyImageInfo2KHR"/>
+                <type name="VkCopyBufferToImageInfo2KHR"/>
+                <type name="VkCopyImageToBufferInfo2KHR"/>
+                <type name="VkBlitImageInfo2KHR"/>
+                <type name="VkResolveImageInfo2KHR"/>
+                <type name="VkBufferCopy2KHR"/>
+                <type name="VkImageCopy2KHR"/>
+                <type name="VkImageBlit2KHR"/>
+                <type name="VkBufferImageCopy2KHR"/>
+                <type name="VkImageResolve2KHR"/>
+                <command name="vkCmdCopyBuffer2KHR"/>
+                <command name="vkCmdCopyImage2KHR"/>
+                <command name="vkCmdCopyBufferToImage2KHR"/>
+                <command name="vkCmdCopyImageToBuffer2KHR"/>
+                <command name="vkCmdBlitImage2KHR"/>
+                <command name="vkCmdResolveImage2KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_339" number="339" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_ARM_EXTENSION_339_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_339&quot;"              name="VK_ARM_EXTENSION_339_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_340" number="340" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_340_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_340&quot;"              name="VK_EXT_EXTENSION_340_EXTENSION_NAME"/>
+                <enum bitpos="19" extends="VkImageUsageFlagBits"            name="VK_IMAGE_USAGE_RESERVED_19_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_4444_formats" number="341" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_4444_FORMATS_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_4444_formats&quot;"               name="VK_EXT_4444_FORMATS_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"/>
+                <enum offset="0" extends="VkFormat"                         name="VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT"/>
+                <enum offset="1" extends="VkFormat"                         name="VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT"/>
+                <type name="VkPhysicalDevice4444FormatsFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_342" number="342" author="EXT" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_342_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_342&quot;"              name="VK_EXT_EXTENSION_342_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_343" number="343" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_ARM_EXTENSION_343_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_343&quot;"              name="VK_ARM_EXTENSION_343_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_344" number="344" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_ARM_EXTENSION_344_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_344&quot;"              name="VK_ARM_EXTENSION_344_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_rgba10x6_formats" number="345" type="device" requires="VK_KHR_sampler_ycbcr_conversion" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="vulkan">
+             <require>
+                    <enum value="1"                                                name="VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION"/>
+                    <enum value="&quot;VK_EXT_rgba10x6_formats&quot;"              name="VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME"/>
+                    <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"/>
+                    <type name="VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_acquire_winrt_display" number="346" type="device" requires="VK_EXT_direct_mode_display" author="NV" contact="Jeff Juliano @jjuliano" platform="win32" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_acquire_winrt_display&quot;"       name="VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME"/>
+                <command name="vkAcquireWinrtDisplayNV"/>
+                <command name="vkGetWinrtDisplayNV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_directfb_surface" number="347" type="instance" requires="VK_KHR_surface" platform="directfb" supported="vulkan" author="EXT" contact="Nicolas Caramelli @caramelli">
+            <require>
+                <enum value="1"                                             name="VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_directfb_surface&quot;"           name="VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT"/>
+                <type name="VkDirectFBSurfaceCreateFlagsEXT"/>
+                <type name="VkDirectFBSurfaceCreateInfoEXT"/>
+                <command name="vkCreateDirectFBSurfaceEXT"/>
+                <command name="vkGetPhysicalDeviceDirectFBPresentationSupportEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_350" number="350" author="KHR" contact="Mark Bellamy @mark.bellamy_arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_350_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_350&quot;"              name="VK_KHR_EXTENSION_350_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_351" number="351" author="NV" contact="Liam Middlebrook @liam-middlebrook" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_NV_EXTENSION_351_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_351&quot;"               name="VK_NV_EXTENSION_351_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_VALVE_mutable_descriptor_type" number="352" type="device" supported="vulkan" author="VALVE" contact="Joshua Ashton @Joshua-Ashton,Hans-Kristian Arntzen @HansKristian-Work" specialuse="d3demulation" requires="VK_KHR_maintenance3">
+            <require>
+                <enum value="1"                                                name="VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION"/>
+                <enum value="&quot;VK_VALVE_mutable_descriptor_type&quot;"     name="VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE"/>
+                <enum offset="2" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE"/>
+                <enum offset="0" extends="VkDescriptorType"                    name="VK_DESCRIPTOR_TYPE_MUTABLE_VALVE"/>
+                <enum bitpos="2" extends="VkDescriptorPoolCreateFlagBits"      name="VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE"/>
+                <enum bitpos="2" extends="VkDescriptorSetLayoutCreateFlagBits" name="VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE"/>
+                <type name="VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE"/>
+                <type name="VkMutableDescriptorTypeListVALVE"/>
+                <type name="VkMutableDescriptorTypeCreateInfoVALVE"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_vertex_input_dynamic_state" number="353" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="2"                                             name="VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_vertex_input_dynamic_state&quot;" name="VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_VERTEX_INPUT_EXT"/>
+                <type name="VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT"/>
+                <type name="VkVertexInputBindingDescription2EXT"/>
+                <type name="VkVertexInputAttributeDescription2EXT"/>
+                <command name="vkCmdSetVertexInputEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_physical_device_drm" number="354" author="EXT" type="device" contact="Simon Ser @emersion" supported="vulkan" requires="VK_KHR_get_physical_device_properties2">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_physical_device_drm&quot;"        name="VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME"/>
+
+                <enum offset="0" extends="VkStructureType" name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"/>
+
+                <type name="VkPhysicalDeviceDrmPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_355" number="355" author="EXT" contact="Ralph Potter gitlab:@r_potter" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_355_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_355&quot;"              name="VK_EXT_EXTENSION_355_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_vertex_attribute_aliasing" number="356" type="device" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled" specialuse="glemulation">
+            <require>
+                <enum value="0"                                             name="VK_EXT_VERTEX_ATTRIBUTE_ALIASING_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_vertex_attribute_aliasing&quot;"  name="VK_EXT_VERTEX_ATTRIBUTE_ALIASING_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_primitive_topology_list_restart" number="357" type="device" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="vulkan" specialuse="glemulation">
+            <require>
+                <enum value="1"                                             name="VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_primitive_topology_list_restart&quot;"           name="VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"/>
+                <type name="VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_358" number="358" author="KHR" contact="Jeff Bolz @jeffbolznv" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_358_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_358&quot;"              name="VK_KHR_EXTENSION_358_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_359" number="359" author="EXT" contact="Bill Hollings @billhollings" supported="disabled" specialuse="glemulation">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_359_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_359&quot;"              name="VK_EXT_EXTENSION_359_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_360" number="360" author="EXT" contact="Bill Hollings @billhollings" supported="disabled" specialuse="glemulation">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_360_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_360&quot;"              name="VK_EXT_EXTENSION_360_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_format_feature_flags2" number="361" author="KHR" type="device" requires="VK_KHR_get_physical_device_properties2" contact="Lionel Landwerlin @llandwerlin" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_format_feature_flags2&quot;"      name="VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR"/>
+                <type                                                       name="VkFormatFeatureFlags2KHR"/>
+                <type                                                       name="VkFormatFeatureFlagBits2KHR"/>
+                <type                                                       name="VkFormatProperties3KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_362" number="362" author="EXT" contact="Lionel Duc @nvlduc" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_362_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_362&quot;"              name="VK_EXT_EXTENSION_362_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_363" number="363" author="EXT" contact="Kaye Mason @chaleur" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_363_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_363&quot;"              name="VK_EXT_EXTENSION_363_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_extension_364" number="364" author="FUCHSIA" contact="Craig Stout @cdotstout" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_FUCHSIA_EXTENSION_364_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_extension_364&quot;"          name="VK_FUCHSIA_EXTENSION_364_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_external_memory" number="365" type="device" requires="VK_KHR_external_memory_capabilities,VK_KHR_external_memory" author="FUCHSIA" contact="John Rosasco @rosasco" platform="fuchsia" supported="vulkan">
+            <require>
+                <enum value="1"                                                name="VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_external_memory&quot;"           name="VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA"/>
+                <enum offset="2" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum bitpos="11" extends="VkExternalMemoryHandleTypeFlagBits" name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA"/>
+                <type name="VkImportMemoryZirconHandleInfoFUCHSIA"/>
+                <type name="VkMemoryZirconHandlePropertiesFUCHSIA"/>
+                <type name="VkMemoryGetZirconHandleInfoFUCHSIA"/>
+                <command name="vkGetMemoryZirconHandleFUCHSIA"/>
+                <command name="vkGetMemoryZirconHandlePropertiesFUCHSIA"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_external_semaphore" number="366" type="device" requires="VK_KHR_external_semaphore_capabilities,VK_KHR_external_semaphore" author="FUCHSIA" contact="John Rosasco @rosasco" platform="fuchsia" supported="vulkan">
+            <require>
+                <enum value="1"                                                name="VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_external_semaphore&quot;"        name="VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum offset="1" extends="VkStructureType"                     name="VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA"/>
+                <enum bitpos="7" extends="VkExternalSemaphoreHandleTypeFlagBits" name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA"/>
+                <type name="VkImportSemaphoreZirconHandleInfoFUCHSIA"/>
+                <type name="VkSemaphoreGetZirconHandleInfoFUCHSIA"/>
+                <command name="vkImportSemaphoreZirconHandleFUCHSIA"/>
+                <command name="vkGetSemaphoreZirconHandleFUCHSIA"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_buffer_collection" number="367" type="device" requires="VK_FUCHSIA_external_memory,VK_KHR_sampler_ycbcr_conversion" author="FUCHSIA" contact="John Rosasco @rosasco" supported="vulkan" platform="fuchsia">
+            <require>
+                <enum value="2"                                         name="VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_buffer_collection&quot;"  name="VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA"/>
+                <enum offset="0" extends="VkObjectType"                 name="VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA" comment="VkBufferCollectionFUCHSIA"/>
+                <enum offset="0" extends="VkDebugReportObjectTypeEXT"   name="VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA"/>
+                <enum offset="2" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA"/>
+                <enum offset="3" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA"/>
+                <enum offset="4" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA"/>
+                <enum offset="5" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA"/>
+                <enum offset="6" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA"/>
+                <enum offset="7" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA"/>
+                <enum offset="8" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA"/>
+                <enum offset="9" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA"/>
+                <type name="VkBufferCollectionFUCHSIA"/>
+                <type name="VkBufferCollectionCreateInfoFUCHSIA"/>
+                <type name="VkImportMemoryBufferCollectionFUCHSIA"/>
+                <type name="VkBufferCollectionImageCreateInfoFUCHSIA"/>
+                <type name="VkBufferConstraintsInfoFUCHSIA"/>
+                <type name="VkBufferCollectionBufferCreateInfoFUCHSIA"/>
+                <type name="VkBufferCollectionPropertiesFUCHSIA"/>
+                <type name="VkImageFormatConstraintsFlagsFUCHSIA" comment="Will add VkImageFormatConstraintsFlagBitsFUCHSIA when bits are defined in the future"/>
+                <type name="VkSysmemColorSpaceFUCHSIA"/>
+                <type name="VkImageConstraintsInfoFlagBitsFUCHSIA"/>
+                <type name="VkImageConstraintsInfoFlagsFUCHSIA"/>
+                <type name="VkImageConstraintsInfoFUCHSIA"/>
+                <type name="VkImageFormatConstraintsInfoFUCHSIA"/>
+                <type name="VkBufferCollectionConstraintsInfoFUCHSIA"/>
+                <command name="vkCreateBufferCollectionFUCHSIA"/>
+                <command name="vkSetBufferCollectionImageConstraintsFUCHSIA"/>
+                <command name="vkSetBufferCollectionBufferConstraintsFUCHSIA"/>
+                <command name="vkDestroyBufferCollectionFUCHSIA"/>
+                <command name="vkGetBufferCollectionPropertiesFUCHSIA"/>
+            </require>
+        </extension>
+        <extension name="VK_FUCHSIA_extension_368" number="368" author="FUCHSIA" contact="Craig Stout @cdotstout" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_FUCHSIA_EXTENSION_368_SPEC_VERSION"/>
+                <enum value="&quot;VK_FUCHSIA_extension_368&quot;"          name="VK_FUCHSIA_EXTENSION_368_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_369" number="369" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_QCOM_EXTENSION_369_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_369&quot;"         name="VK_QCOM_EXTENSION_369_EXTENSION_NAME"/>
+                <enum bitpos="4" extends="VkDescriptorBindingFlagBits"  name="VK_DESCRIPTOR_BINDING_RESERVED_4_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_subpass_shading" number="370" type="device" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" requires="VK_KHR_create_renderpass2,VK_KHR_synchronization2" supported="vulkan">
+            <require>
+                <enum value="2"                                         name="VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_subpass_shading&quot;"         name="VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI"/>
+                <enum offset="1" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"/>
+                <enum offset="2" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"/>
+                <enum offset="3" extends="VkPipelineBindPoint" extnumber="370" name="VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI"/>
+                <enum bitpos="39" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI"/>
+                <enum bitpos="14" extends="VkShaderStageFlagBits"           name="VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI"/>
+                <type name="VkSubpassShadingPipelineCreateInfoHUAWEI"/>
+                <type name="VkPhysicalDeviceSubpassShadingFeaturesHUAWEI"/>
+                <type name="VkPhysicalDeviceSubpassShadingPropertiesHUAWEI"/>
+                <command name="vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"/>
+                <command name="vkCmdSubpassShadingHUAWEI"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_invocation_mask" number="371" type="device" requires="VK_KHR_ray_tracing_pipeline,VK_KHR_synchronization2" author="Huawei" contact="Yunpeng Zhu @yunxingzhu" supported="vulkan">
+            <require>
+                <enum value="1"                                              name="VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_invocation_mask&quot;"        name="VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                   name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"/>
+                <enum bitpos="39" extends="VkAccessFlagBits2KHR"             name="VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI"/>
+                <enum bitpos="18" extends="VkImageUsageFlagBits"             name="VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI"/>
+                <enum bitpos="40" extends="VkPipelineStageFlagBits2KHR"      name="VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI"/>
+                <type name="VkPhysicalDeviceInvocationMaskFeaturesHUAWEI"/>
+                <command name="vkCmdBindInvocationMaskHUAWEI"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_external_memory_rdma" number="372" type="device" requires="VK_KHR_external_memory" author="NV" contact="Carsten Rohde @crohde" supported="vulkan">
+            <require>
+                <enum value="1"                                                 name="VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_external_memory_rdma&quot;"            name="VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV"/>
+                <enum offset="1" extends="VkStructureType"                      name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"/>
+                <enum bitpos="8" extends="VkMemoryPropertyFlagBits"             name="VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV"/>
+                <enum bitpos="12" extends="VkExternalMemoryHandleTypeFlagBits"  name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV"/>
+                <type name="VkRemoteAddressNV"/>
+                <type name="VkMemoryGetRemoteAddressInfoNV"/>
+                <type name="VkPhysicalDeviceExternalMemoryRDMAFeaturesNV"/>
+                <command name="vkGetMemoryRemoteAddressNV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_373" number="373" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_373_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_373&quot;"           name="VK_NV_EXTENSION_373_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_374" number="374" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_374_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_374&quot;"           name="VK_NV_EXTENSION_374_EXTENSION_NAME"/>
+                <enum bitpos="4" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_RESERVED_4_BIT_NV"/>
+                <enum bitpos="5" extends="VkExternalFenceHandleTypeFlagBits" name="VK_EXTERNAL_FENCE_HANDLE_TYPE_RESERVED_5_BIT_NV"/>
+                <enum bitpos="5" extends="VkExternalSemaphoreHandleTypeFlagBits" name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_RESERVED_5_BIT_NV"/>
+                <enum bitpos="6" extends="VkExternalSemaphoreHandleTypeFlagBits" name="VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_RESERVED_6_BIT_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_375" number="375" author="NV" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_375_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_375&quot;"           name="VK_NV_EXTENSION_375_EXTENSION_NAME"/>
+                <enum bitpos="13" extends="VkExternalMemoryHandleTypeFlagBits"  name="VK_EXTERNAL_MEMORY_HANDLE_TYPE_RESERVED_13_BIT_NV"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_376" number="376" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_376_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_376&quot;"          name="VK_EXT_EXTENSION_376_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_377" number="377" author="EXT" contact="Hugues Evrard @hevrard" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_377_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_377&quot;"          name="VK_EXT_EXTENSION_377_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extended_dynamic_state2" number="378" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Vikram Kushwaha @vkushwaha-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                             name="VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extended_dynamic_state2&quot;"     name="VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                  name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"/>
+                <enum offset="0" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT"/>
+                <enum offset="1" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT"/>
+                <enum offset="2" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT"/>
+                <enum offset="3" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_LOGIC_OP_EXT"/>
+                <enum offset="4" extends="VkDynamicState"                   name="VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT"/>
+                <type name="VkPhysicalDeviceExtendedDynamicState2FeaturesEXT"/>
+                <command name="vkCmdSetPatchControlPointsEXT"/>
+                <command name="vkCmdSetRasterizerDiscardEnableEXT"/>
+                <command name="vkCmdSetDepthBiasEnableEXT"/>
+                <command name="vkCmdSetLogicOpEXT"/>
+                <command name="vkCmdSetPrimitiveRestartEnableEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_QNX_screen_surface" number="379" type="instance" requires="VK_KHR_surface" platform="screen" author="QNX" contact="Mike Gorchak @mgorchak-blackberry" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_QNX_SCREEN_SURFACE_SPEC_VERSION"/>
+                <enum value="&quot;VK_QNX_screen_surface&quot;"         name="VK_QNX_SCREEN_SURFACE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX"/>
+                <type name="VkScreenSurfaceCreateFlagsQNX"/>
+                <type name="VkScreenSurfaceCreateInfoQNX"/>
+                <command name="vkCreateScreenSurfaceQNX"/>
+                <command name="vkGetPhysicalDeviceScreenPresentationSupportQNX"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_380" number="380" author="KHR" contact="James Jones @cubanismo" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_380_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_380&quot;"          name="VK_KHR_EXTENSION_380_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_381" number="381" author="KHR" contact="James Jones @cubanismo" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_381_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_381&quot;"          name="VK_KHR_EXTENSION_381_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_color_write_enable" number="382" type="device" requires="VK_KHR_get_physical_device_properties2" author="EXT" contact="Sharif Elcott @selcott" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_color_write_enable&quot;"     name="VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT"/>
+                <enum offset="0" extends="VkDynamicState"               name="VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT"/>
+                <type name="VkPhysicalDeviceColorWriteEnableFeaturesEXT"/>
+                <type name="VkPipelineColorWriteCreateInfoEXT"/>
+                <command name="vkCmdSetColorWriteEnableEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_383" number="383" author="EXT" contact="Shahbaz Youssefi @syoussefi" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_383_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_383&quot;"          name="VK_EXT_EXTENSION_383_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_384" number="384" type="instance" author="EXT" contact="Chia-I Wu @olvaffe1" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_EXT_EXTENSION_384_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_384&quot;"          name="VK_EXT_EXTENSION_384_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_MESA_extension_385" number="385" type="instance" author="MESA" contact="Chia-I Wu @olvaffe1" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_MESA_EXTENSION_385_SPEC_VERSION"/>
+                <enum value="&quot;VK_MESA_extension_385&quot;"         name="VK_MESA_EXTENSION_385_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GOOGLE_extension_386" number="386" author="GOOGLE" contact="Chia-I Wu @olvaffe1" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GOOGLE_EXTENSION_386_SPEC_VERSION"/>
+                <enum value="&quot;VK_GOOGLE_extension_386&quot;"       name="VK_GOOGLE_EXTENSION_386_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_387" number="387" author="KHR" contact="Daniel Koch @dgkoch" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_387_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_387&quot;"              name="VK_KHR_EXTENSION_387_EXTENSION_NAME"/>
+                <enum bitpos="28" extends="VkPipelineStageFlagBits2KHR"     name="VK_PIPELINE_STAGE_2_RESERVED_387_BIT_KHR"/>
+                <enum bitpos="40" extends="VkAccessFlagBits2KHR"            name="VK_ACCESS_2_RESERVED_387_BIT_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_388" number="388" author="EXT" contact="Alan Baker @alan-baker" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_388_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_388&quot;"              name="VK_EXT_EXTENSION_388_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_global_priority_query" number="389" type="device" requires="VK_EXT_global_priority,VK_KHR_get_physical_device_properties2" author="EXT" contact="Yiwei Zhang @zhangyiwei" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_global_priority_query&quot;"  name="VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT"/>
+                <enum                                                   name="VK_MAX_GLOBAL_PRIORITY_SIZE_EXT"/>
+                <type                                                   name="VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT"/>
+                <type                                                   name="VkQueueFamilyGlobalPriorityPropertiesEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_390" number="390" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_390_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_390&quot;"              name="VK_EXT_EXTENSION_390_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_391" number="391" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_391_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_391&quot;"              name="VK_EXT_EXTENSION_391_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_392" number="392" author="EXT" contact="Joshua Ashton @Joshua-Ashton" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_392_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_392&quot;"              name="VK_EXT_EXTENSION_392_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_multi_draw" number="393" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_MULTI_DRAW_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_multi_draw&quot;"             name="VK_EXT_MULTI_DRAW_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                 name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"/>
+                <type name="VkPhysicalDeviceMultiDrawFeaturesEXT"/>
+                <type name="VkPhysicalDeviceMultiDrawPropertiesEXT"/>
+                <command name="vkCmdDrawMultiEXT"/>
+                <command name="vkCmdDrawMultiIndexedEXT"/>
+                <type name="VkMultiDrawInfoEXT"/>
+                <type name="VkMultiDrawIndexedInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_394" number="394" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_394_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_394&quot;"              name="VK_EXT_EXTENSION_394_EXTENSION_NAME"/>
+                <enum extends="VkImageCreateFlagBits" bitpos="17" name="VK_IMAGE_CREATE_RESERVED_394_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_395" number="395" author="KHR" contact="Lenny Komow @lkomow" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_395_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_395&quot;"              name="VK_KHR_EXTENSION_395_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_396" number="396" author="EXT" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_396_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_396&quot;"              name="VK_KHR_EXTENSION_396_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_397" number="397" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_397_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_397&quot;"           name="VK_NV_EXTENSION_397_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_398" number="398" author="NV" contact="Christoph Kubisch @pixeljetstream" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_398_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_398&quot;"           name="VK_NV_EXTENSION_398_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_JUICE_extension_399" number="399" author="JUICE" contact="Dean Beeler @canadacow" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_JUICE_EXTENSION_399_SPEC_VERSION"/>
+                <enum value="&quot;VK_JUICE_extension_399&quot;"        name="VK_JUICE_EXTENSION_399_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_JUICE_extension_400" number="400" author="JUICE" contact="David McCloskey @damcclos" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_JUICE_EXTENSION_400_SPEC_VERSION"/>
+                <enum value="&quot;VK_JUICE_extension_400&quot;"        name="VK_JUICE_EXTENSION_400_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_load_store_op_none" number="401" author="EXT" type="device" contact="Shahbaz Youssefi @syoussefi" supported="vulkan">
+            <require>
+                <enum value="1"                                         name="VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_load_store_op_none&quot;"          name="VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkAttachmentLoadOp" name="VK_ATTACHMENT_LOAD_OP_NONE_EXT"/>
+                <enum extends="VkAttachmentStoreOp" name="VK_ATTACHMENT_STORE_OP_NONE_EXT" alias="VK_ATTACHMENT_STORE_OP_NONE_KHR"/>
+            </require>
+        </extension>
+        <extension name="VK_FB_extension_402" number="402" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_FB_EXTENSION_402_SPEC_VERSION"/>
+                <enum value="&quot;VK_FB_extension_402&quot;"           name="VK_FB_EXTENSION_402_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FB_extension_403" number="403" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_FB_EXTENSION_403_SPEC_VERSION"/>
+                <enum value="&quot;VK_FB_extension_403&quot;"           name="VK_FB_EXTENSION_403_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_FB_extension_404" number="404" author="FB" contact="Artem Bolgar @artyom17" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_FB_EXTENSION_404_SPEC_VERSION"/>
+                <enum value="&quot;VK_FB_extension_404&quot;"           name="VK_FB_EXTENSION_404_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_extension_405" number="405" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_HUAWEI_EXTENSION_405_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_extension_405&quot;"           name="VK_HUAWEI_EXTENSION_405_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_extension_406" number="406" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_HUAWEI_EXTENSION_406_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_extension_406&quot;"           name="VK_HUAWEI_EXTENSION_406_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_407" number="407" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_407_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_407&quot;"          name="VK_GGP_EXTENSION_407_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_408" number="408" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_408_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_408&quot;"          name="VK_GGP_EXTENSION_408_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_409" number="409" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_409_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_409&quot;"          name="VK_GGP_EXTENSION_409_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_410" number="410" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_410_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_410&quot;"          name="VK_GGP_EXTENSION_410_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_GGP_extension_411" number="411" author="GGP" contact="J.D. Rouan @jdrouan" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_GGP_EXTENSION_411_SPEC_VERSION"/>
+                <enum value="&quot;VK_GGP_extension_411&quot;"          name="VK_GGP_EXTENSION_411_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_border_color_swizzle" number="412" type="device" author="EXT" contact="Piers Daniell @pdaniell-nv" supported="vulkan" requires="VK_EXT_custom_border_color" specialuse="glemulation,d3demulation">
+            <require>
+                <enum value="1"                                         name="VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_border_color_swizzle&quot;"   name="VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"/>
+                <enum offset="1" extends="VkStructureType"              name="VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT"/>
+                <type name="VkPhysicalDeviceBorderColorSwizzleFeaturesEXT"/>
+                <type name="VkSamplerBorderColorComponentMappingCreateInfoEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_pageable_device_local_memory" number="413" author="EXT" contact="Piers Daniell @pdaniell-nv" type="device" requires="VK_EXT_memory_priority" supported="vulkan">
+            <require>
+                <enum value="1"                                                  name="VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_pageable_device_local_memory&quot;"    name="VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                       name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"/>
+                <type                                                            name="VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT"/>
+                <command                                                         name="vkSetDeviceMemoryPriorityEXT"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_maintenance4" number="414" type="device" requiresCore="1.1" author="KHR" contact="Piers Daniell @pdaniell-nv" supported="vulkan">
+            <require>
+                <enum value="1"                                               name="VK_KHR_MAINTENANCE_4_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_maintenance4&quot;"                 name="VK_KHR_MAINTENANCE_4_EXTENSION_NAME"/>
+                <enum offset="0" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR"/>
+                <enum offset="1" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR"/>
+                <enum offset="2" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR"/>
+                <enum offset="3" extends="VkStructureType"                    name="VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR"/>
+                <type name="VkPhysicalDeviceMaintenance4FeaturesKHR"/>
+                <type name="VkPhysicalDeviceMaintenance4PropertiesKHR"/>
+                <type name="VkDeviceBufferMemoryRequirementsKHR"/>
+                <type name="VkDeviceImageMemoryRequirementsKHR"/>
+                <command name="vkGetDeviceBufferMemoryRequirementsKHR"/>
+                <command name="vkGetDeviceImageMemoryRequirementsKHR"/>
+                <command name="vkGetDeviceImageSparseMemoryRequirementsKHR"/>
+            </require>
+        </extension>
+        <extension name="VK_HUAWEI_extension_415" number="415" author="HUAWEI" contact="Hueilong Wang @wyvernathuawei" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_HUAWEI_EXTENSION_415_SPEC_VERSION"/>
+                <enum value="&quot;VK_HUAWEI_extension_415&quot;"         name="VK_HUAWEI_EXTENSION_415_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_416" number="416" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_ARM_EXTENSION_416_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_416&quot;"          name="VK_ARM_EXTENSION_416_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_417" number="417" author="KHR" contact="Kevin Petit @kevinpetit" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_KHR_EXTENSION_417_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_417&quot;"          name="VK_KHR_EXTENSION_417_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_418" number="418" author="ARM" contact="Kevin Petit @kevinpetit" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_ARM_EXTENSION_418_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_418&quot;"          name="VK_ARM_EXTENSION_418_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_419" number="419" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_419_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_419&quot;"              name="VK_EXT_EXTENSION_419_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_420" number="420" author="EXT" contact="Mike Blumenkrantz @zmike" type="device" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_420_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_420&quot;"              name="VK_EXT_EXTENSION_420_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_KHR_extension_421" number="421" author="KHR" contact="Hans-Kristian Arntzen @HansKristian-Work" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_KHR_EXTENSION_421_SPEC_VERSION"/>
+                <enum value="&quot;VK_KHR_extension_421&quot;"              name="VK_KHR_EXTENSION_421_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_extension_422" number="422" author="EXT" contact="Graeme Leese @gnl21" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_EXTENSION_422_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_extension_422&quot;"              name="VK_EXT_EXTENSION_422_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_EXT_disable_cube_map_wrap" number="423" author="EXT" contact="Georg Lehmann @DadSchoorse" supported="disabled">
+            <require>
+                <enum value="0"                                             name="VK_EXT_DISABLE_CUBE_MAP_WRAP_SPEC_VERSION"/>
+                <enum value="&quot;VK_EXT_disable_cube_map_wrap&quot;"      name="VK_EXT_DISABLE_CUBE_MAP_WRAP_EXTENSION_NAME"/>
+                <enum bitpos="2"  extends="VkSamplerCreateFlagBits"         name="VK_SAMPLER_CREATE_RESERVED_2_BIT_EXT"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_424" number="424" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_ARM_EXTENSION_424_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_424&quot;"          name="VK_ARM_EXTENSION_424_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_ARM_extension_425" number="425" author="ARM" contact="Jan-Harald Fredriksen @janharaldfredriksen-arm" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_ARM_EXTENSION_425_SPEC_VERSION"/>
+                <enum value="&quot;VK_ARM_extension_425&quot;"          name="VK_ARM_EXTENSION_425_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_QCOM_extension_426" number="426" author="QCOM" contact="Matthew Netsch @mnetsch" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_QCOM_EXTENSION_426_SPEC_VERSION"/>
+                <enum value="&quot;VK_QCOM_extension_426&quot;"         name="VK_QCOM_EXTENSION_426_EXTENSION_NAME"/>
+                <enum bitpos="15" extends="VkImageCreateFlagBits"       name="VK_IMAGE_CREATE_RESERVED_426_BIT_QCOM"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_427" number="427" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_427_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_427&quot;"           name="VK_NV_EXTENSION_427_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_428" number="428" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_428_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_428&quot;"           name="VK_NV_EXTENSION_428_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_429" number="429" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_429_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_429&quot;"           name="VK_NV_EXTENSION_429_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_430" number="430" author="NV" contact="Vikram Kushwaha @vkushwaha-nv" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_430_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_430&quot;"           name="VK_NV_EXTENSION_430_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_431" number="431" author="NV" contact="Sourav Parmar @souravpNV" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_431_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_431&quot;"           name="VK_NV_EXTENSION_431_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_432" number="432" author="NV" contact="Sourav Parmar @souravpNV" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_432_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_432&quot;"           name="VK_NV_EXTENSION_432_EXTENSION_NAME"/>
+            </require>
+        </extension>
+        <extension name="VK_NV_extension_433" number="433" author="NV" contact="Sourav Parmar @souravpNV" supported="disabled">
+            <require>
+                <enum value="0"                                         name="VK_NV_EXTENSION_433_SPEC_VERSION"/>
+                <enum value="&quot;VK_NV_extension_433&quot;"           name="VK_NV_EXTENSION_433_EXTENSION_NAME"/>
+            </require>
+        </extension>
+    </extensions>
+    <spirvextensions comment="SPIR-V Extensions allowed in Vulkan and what is required to use it">
+        <spirvextension name="SPV_KHR_variable_pointers">
+            <enable version="VK_API_VERSION_1_1"/>
+            <enable extension="VK_KHR_variable_pointers"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_explicit_vertex_parameter">
+            <enable extension="VK_AMD_shader_explicit_vertex_parameter"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_gcn_shader">
+            <enable extension="VK_AMD_gcn_shader"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_gpu_shader_half_float">
+            <enable extension="VK_AMD_gpu_shader_half_float"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_gpu_shader_int16">
+            <enable extension="VK_AMD_gpu_shader_int16"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_ballot">
+            <enable extension="VK_AMD_shader_ballot"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_fragment_mask">
+            <enable extension="VK_AMD_shader_fragment_mask"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_image_load_store_lod">
+            <enable extension="VK_AMD_shader_image_load_store_lod"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_shader_trinary_minmax">
+            <enable extension="VK_AMD_shader_trinary_minmax"/>
+        </spirvextension>
+        <spirvextension name="SPV_AMD_texture_gather_bias_lod">
+            <enable extension="VK_AMD_texture_gather_bias_lod"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_shader_draw_parameters">
+            <enable version="VK_API_VERSION_1_1"/>
+            <enable extension="VK_KHR_shader_draw_parameters"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_8bit_storage">
+            <enable version="VK_API_VERSION_1_2"/>
+            <enable extension="VK_KHR_8bit_storage"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_16bit_storage">
+            <enable version="VK_API_VERSION_1_1"/>
+            <enable extension="VK_KHR_16bit_storage"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_shader_clock">
+            <enable extension="VK_KHR_shader_clock"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_float_controls">
+            <enable version="VK_API_VERSION_1_2"/>
+            <enable extension="VK_KHR_shader_float_controls"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_storage_buffer_storage_class">
+            <enable version="VK_API_VERSION_1_1"/>
+            <enable extension="VK_KHR_storage_buffer_storage_class"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_post_depth_coverage">
+            <enable extension="VK_EXT_post_depth_coverage"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_stencil_export">
+            <enable extension="VK_EXT_shader_stencil_export"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_shader_ballot">
+            <enable extension="VK_EXT_shader_subgroup_ballot"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_subgroup_vote">
+            <enable extension="VK_EXT_shader_subgroup_vote"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_sample_mask_override_coverage">
+            <enable extension="VK_NV_sample_mask_override_coverage"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_geometry_shader_passthrough">
+            <enable extension="VK_NV_geometry_shader_passthrough"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_mesh_shader">
+            <enable extension="VK_NV_mesh_shader"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_viewport_array2">
+            <enable extension="VK_NV_viewport_array2"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shader_subgroup_partitioned">
+            <enable extension="VK_NV_shader_subgroup_partitioned"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_viewport_index_layer">
+            <enable version="VK_API_VERSION_1_2"/>
+            <enable extension="VK_EXT_shader_viewport_index_layer"/>
+        </spirvextension>
+        <spirvextension name="SPV_NVX_multiview_per_view_attributes">
+            <enable extension="VK_NVX_multiview_per_view_attributes"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_descriptor_indexing">
+            <enable version="VK_API_VERSION_1_2"/>
+            <enable extension="VK_EXT_descriptor_indexing"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_vulkan_memory_model">
+            <enable version="VK_API_VERSION_1_2"/>
+            <enable extension="VK_KHR_vulkan_memory_model"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_compute_shader_derivatives">
+            <enable extension="VK_NV_compute_shader_derivatives"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_fragment_shader_barycentric">
+            <enable extension="VK_NV_fragment_shader_barycentric"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shader_image_footprint">
+            <enable extension="VK_NV_shader_image_footprint"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shading_rate">
+            <enable extension="VK_NV_shading_rate_image"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_ray_tracing">
+            <enable extension="VK_NV_ray_tracing"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_ray_tracing">
+            <enable extension="VK_KHR_ray_tracing_pipeline"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_ray_query">
+            <enable extension="VK_KHR_ray_query"/>
+        </spirvextension>
+        <spirvextension name="SPV_GOOGLE_hlsl_functionality1">
+            <enable extension="VK_GOOGLE_hlsl_functionality1"/>
+        </spirvextension>
+        <spirvextension name="SPV_GOOGLE_user_type">
+            <enable extension="VK_GOOGLE_user_type"/>
+        </spirvextension>
+        <spirvextension name="SPV_GOOGLE_decorate_string">
+            <enable extension="VK_GOOGLE_decorate_string"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_fragment_invocation_density">
+            <enable extension="VK_EXT_fragment_density_map"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_physical_storage_buffer">
+            <enable version="VK_API_VERSION_1_2"/>
+            <enable extension="VK_KHR_buffer_device_address"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_physical_storage_buffer">
+            <enable extension="VK_EXT_buffer_device_address"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_cooperative_matrix">
+            <enable extension="VK_NV_cooperative_matrix"/>
+        </spirvextension>
+        <spirvextension name="SPV_NV_shader_sm_builtins">
+            <enable extension="VK_NV_shader_sm_builtins"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_fragment_shader_interlock">
+            <enable extension="VK_EXT_fragment_shader_interlock"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_demote_to_helper_invocation">
+            <enable extension="VK_EXT_shader_demote_to_helper_invocation"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_fragment_shading_rate">
+            <enable extension="VK_KHR_fragment_shading_rate"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_non_semantic_info">
+            <enable extension="VK_KHR_shader_non_semantic_info"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_image_int64">
+            <enable extension="VK_EXT_shader_image_atomic_int64"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_terminate_invocation">
+            <enable extension="VK_KHR_shader_terminate_invocation"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_multiview">
+            <enable version="VK_API_VERSION_1_1"/>
+            <enable extension="VK_KHR_multiview"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_workgroup_memory_explicit_layout">
+            <enable extension="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_atomic_float_add">
+            <enable extension="VK_EXT_shader_atomic_float"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_subgroup_uniform_control_flow">
+            <enable extension="VK_KHR_shader_subgroup_uniform_control_flow"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_atomic_float_min_max">
+            <enable extension="VK_EXT_shader_atomic_float2"/>
+        </spirvextension>
+        <spirvextension name="SPV_EXT_shader_atomic_float16_add">
+            <enable extension="VK_EXT_shader_atomic_float2"/>
+        </spirvextension>
+        <spirvextension name="SPV_KHR_integer_dot_product">
+            <enable extension="VK_KHR_shader_integer_dot_product"/>
+        </spirvextension>
+    </spirvextensions>
+    <spirvcapabilities comment="SPIR-V Capabilities allowed in Vulkan and what is required to use it">
+        <spirvcapability name="Matrix">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Shader">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="InputAttachment">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Sampled1D">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Image1D">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampledBuffer">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageBuffer">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageQuery">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="DerivativeControl">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Geometry">
+            <enable struct="VkPhysicalDeviceFeatures" feature="geometryShader" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Tessellation">
+            <enable struct="VkPhysicalDeviceFeatures" feature="tessellationShader" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Float64">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderFloat64" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Int64">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderInt64" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="Int64Atomics">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderBufferInt64Atomics" requires="VK_VERSION_1_2,VK_KHR_shader_atomic_int64"/>
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderSharedInt64Atomics" requires="VK_VERSION_1_2,VK_KHR_shader_atomic_int64"/>
+            <enable struct="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" feature="shaderImageInt64Atomics" requires="VK_EXT_shader_image_atomic_int64"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat16AddEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat16AtomicAdd" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat16AtomicAdd" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat32AddEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderBufferFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderSharedFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderImageFloat32AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat64AddEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderBufferFloat64AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloatFeaturesEXT" feature="shaderSharedFloat64AtomicAdd" requires="VK_EXT_shader_atomic_float"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat16MinMaxEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat16AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat16AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat32MinMaxEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderImageFloat32AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="AtomicFloat64MinMaxEXT">
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderBufferFloat64AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+            <enable struct="VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT" feature="shaderSharedFloat64AtomicMinMax" requires="VK_EXT_shader_atomic_float2"/>
+        </spirvcapability>
+        <spirvcapability name="Int64ImageEXT">
+            <enable struct="VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT" feature="shaderImageInt64Atomics" requires="VK_EXT_shader_image_atomic_int64"/>
+        </spirvcapability>
+        <spirvcapability name="Int16">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderInt16" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="TessellationPointSize">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderTessellationAndGeometryPointSize" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="GeometryPointSize">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderTessellationAndGeometryPointSize" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageGatherExtended">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderImageGatherExtended" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageMultisample">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageMultisample" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="UniformBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderUniformBufferArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampledImageArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderSampledImageArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageBufferArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageArrayDynamicIndexing" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ClipDistance">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderClipDistance" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="CullDistance">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderCullDistance" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageCubeArray">
+            <enable struct="VkPhysicalDeviceFeatures" feature="imageCubeArray" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampleRateShading">
+            <enable struct="VkPhysicalDeviceFeatures" feature="sampleRateShading" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SparseResidency">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderResourceResidency" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="MinLod">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderResourceMinLod" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="SampledCubeArray">
+            <enable struct="VkPhysicalDeviceFeatures" feature="imageCubeArray" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="ImageMSArray">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageMultisample" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageExtendedFormats">
+            <enable version="VK_API_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="InterpolationFunction">
+            <enable struct="VkPhysicalDeviceFeatures" feature="sampleRateShading" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageReadWithoutFormat">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageReadWithoutFormat" requires="VK_VERSION_1_0"/>
+            <enable extension="VK_KHR_format_feature_flags2"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageWriteWithoutFormat">
+            <enable struct="VkPhysicalDeviceFeatures" feature="shaderStorageImageWriteWithoutFormat" requires="VK_VERSION_1_0"/>
+            <enable extension="VK_KHR_format_feature_flags2"/>
+        </spirvcapability>
+        <spirvcapability name="MultiViewport">
+            <enable struct="VkPhysicalDeviceFeatures" feature="multiViewport" requires="VK_VERSION_1_0"/>
+        </spirvcapability>
+        <spirvcapability name="DrawParameters">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="shaderDrawParameters" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceShaderDrawParametersFeatures" feature="shaderDrawParameters" requires="VK_VERSION_1_1"/>
+            <enable extension="VK_KHR_shader_draw_parameters"/>
+        </spirvcapability>
+        <spirvcapability name="MultiView">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="multiview" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceMultiviewFeatures" feature="multiview" requires="VK_KHR_multiview"/>
+        </spirvcapability>
+        <spirvcapability name="DeviceGroup">
+            <enable version="VK_API_VERSION_1_1"/>
+            <enable extension="VK_KHR_device_group"/>
+        </spirvcapability>
+        <spirvcapability name="VariablePointersStorageBuffer">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="variablePointersStorageBuffer" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceVariablePointersFeatures" feature="variablePointersStorageBuffer" requires="VK_KHR_variable_pointers"/>
+        </spirvcapability>
+        <spirvcapability name="VariablePointers">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="variablePointers" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDeviceVariablePointersFeatures" feature="variablePointers" requires="VK_KHR_variable_pointers"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderClockKHR">
+            <enable extension="VK_KHR_shader_clock"/>
+        </spirvcapability>
+        <spirvcapability name="StencilExportEXT">
+            <enable extension="VK_EXT_shader_stencil_export"/>
+        </spirvcapability>
+        <spirvcapability name="SubgroupBallotKHR">
+            <enable extension="VK_EXT_shader_subgroup_ballot"/>
+        </spirvcapability>
+        <spirvcapability name="SubgroupVoteKHR">
+            <enable extension="VK_EXT_shader_subgroup_vote"/>
+        </spirvcapability>
+        <spirvcapability name="ImageReadWriteLodAMD">
+            <enable extension="VK_AMD_shader_image_load_store_lod"/>
+        </spirvcapability>
+        <spirvcapability name="ImageGatherBiasLodAMD">
+            <enable extension="VK_AMD_texture_gather_bias_lod"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentMaskAMD">
+            <enable extension="VK_AMD_shader_fragment_mask"/>
+        </spirvcapability>
+        <spirvcapability name="SampleMaskOverrideCoverageNV">
+            <enable extension="VK_NV_sample_mask_override_coverage"/>
+        </spirvcapability>
+        <spirvcapability name="GeometryShaderPassthroughNV">
+            <enable extension="VK_NV_geometry_shader_passthrough"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportIndex">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderOutputViewportIndex" requires="VK_VERSION_1_2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderLayer">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderOutputLayer" requires="VK_VERSION_1_2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportIndexLayerEXT">
+            <enable extension="VK_EXT_shader_viewport_index_layer"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportIndexLayerNV">
+            <enable extension="VK_NV_viewport_array2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderViewportMaskNV">
+            <enable extension="VK_NV_viewport_array2"/>
+        </spirvcapability>
+        <spirvcapability name="PerViewAttributesNV">
+            <enable extension="VK_NVX_multiview_per_view_attributes"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBuffer16BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storageBuffer16BitAccess" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storageBuffer16BitAccess" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="UniformAndStorageBuffer16BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="uniformAndStorageBuffer16BitAccess" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="uniformAndStorageBuffer16BitAccess" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="StoragePushConstant16">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storagePushConstant16" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storagePushConstant16" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="StorageInputOutput16">
+            <enable struct="VkPhysicalDeviceVulkan11Features" feature="storageInputOutput16" requires="VK_VERSION_1_2"/>
+            <enable struct="VkPhysicalDevice16BitStorageFeatures" feature="storageInputOutput16" requires="VK_KHR_16bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniform">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_BASIC_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformVote">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_VOTE_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformArithmetic">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_ARITHMETIC_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformBallot">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_BALLOT_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformShuffle">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_SHUFFLE_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformShuffleRelative">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformClustered">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_CLUSTERED_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformQuad">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_QUAD_BIT" requires="VK_VERSION_1_1"/>
+        </spirvcapability>
+        <spirvcapability name="GroupNonUniformPartitionedNV">
+            <enable property="VkPhysicalDeviceVulkan11Properties" member="subgroupSupportedOperations" value="VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV" requires="VK_NV_shader_subgroup_partitioned"/>
+        </spirvcapability>
+        <spirvcapability name="SampleMaskPostDepthCoverage">
+            <enable extension="VK_EXT_post_depth_coverage"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderNonUniform">
+            <enable version="VK_API_VERSION_1_2"/>
+            <enable extension="VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="RuntimeDescriptorArray">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="runtimeDescriptorArray" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="InputAttachmentArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInputAttachmentArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="UniformTexelBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformTexelBufferArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageTexelBufferArrayDynamicIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageTexelBufferArrayDynamicIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="UniformBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="SampledImageArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderSampledImageArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageImageArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageImageArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="InputAttachmentArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInputAttachmentArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="UniformTexelBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderUniformTexelBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="StorageTexelBufferArrayNonUniformIndexing">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderStorageTexelBufferArrayNonUniformIndexing" requires="VK_VERSION_1_2,VK_EXT_descriptor_indexing"/>
+        </spirvcapability>
+        <spirvcapability name="Float16">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderFloat16" requires="VK_VERSION_1_2,VK_KHR_shader_float16_int8"/>
+            <enable extension="VK_AMD_gpu_shader_half_float"/>
+        </spirvcapability>
+        <spirvcapability name="Int8">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="shaderInt8" requires="VK_VERSION_1_2,VK_KHR_shader_float16_int8"/>
+        </spirvcapability>
+        <spirvcapability name="StorageBuffer8BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="storageBuffer8BitAccess" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="UniformAndStorageBuffer8BitAccess">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="uniformAndStorageBuffer8BitAccess" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="StoragePushConstant8">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="storagePushConstant8" requires="VK_VERSION_1_2,VK_KHR_8bit_storage"/>
+        </spirvcapability>
+        <spirvcapability name="VulkanMemoryModel">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="vulkanMemoryModel" requires="VK_VERSION_1_2,VK_KHR_vulkan_memory_model"/>
+        </spirvcapability>
+        <spirvcapability name="VulkanMemoryModelDeviceScope">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="vulkanMemoryModelDeviceScope" requires="VK_VERSION_1_2,VK_KHR_vulkan_memory_model"/>
+        </spirvcapability>
+        <spirvcapability name="DenormPreserve">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormPreserveFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="DenormFlushToZero">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderDenormFlushToZeroFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="SignedZeroInfNanPreserve">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderSignedZeroInfNanPreserveFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="RoundingModeRTE">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTEFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="RoundingModeRTZ">
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat16" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat32" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+            <enable property="VkPhysicalDeviceVulkan12Properties" member="shaderRoundingModeRTZFloat64" value="VK_TRUE" requires="VK_VERSION_1_2,VK_KHR_shader_float_controls"/>
+        </spirvcapability>
+        <spirvcapability name="ComputeDerivativeGroupQuadsNV">
+            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" feature="computeDerivativeGroupQuads" requires="VK_NV_compute_shader_derivatives"/>
+        </spirvcapability>
+        <spirvcapability name="ComputeDerivativeGroupLinearNV">
+            <enable struct="VkPhysicalDeviceComputeShaderDerivativesFeaturesNV" feature="computeDerivativeGroupLinear" requires="VK_NV_compute_shader_derivatives"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentBarycentricNV">
+            <enable struct="VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV" feature="fragmentShaderBarycentric" requires="VK_NV_fragment_shader_barycentric"/>
+        </spirvcapability>
+        <spirvcapability name="ImageFootprintNV">
+            <enable struct="VkPhysicalDeviceShaderImageFootprintFeaturesNV" feature="imageFootprint" requires="VK_NV_shader_image_footprint"/>
+        </spirvcapability>
+        <spirvcapability name="ShadingRateNV">
+            <enable struct="VkPhysicalDeviceShadingRateImageFeaturesNV" feature="shadingRateImage" requires="VK_NV_shading_rate_image"/>
+        </spirvcapability>
+        <spirvcapability name="MeshShadingNV">
+            <enable extension="VK_NV_mesh_shader"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingKHR">
+            <enable struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" feature="rayTracingPipeline" requires="VK_KHR_ray_tracing_pipeline"/>
+        </spirvcapability>
+        <spirvcapability name="RayQueryKHR">
+            <enable struct="VkPhysicalDeviceRayQueryFeaturesKHR" feature="rayQuery" requires="VK_KHR_ray_query"/>
+        </spirvcapability>
+        <spirvcapability name="RayTraversalPrimitiveCullingKHR">
+            <enable struct="VkPhysicalDeviceRayTracingPipelineFeaturesKHR" feature="rayTraversalPrimitiveCulling" requires="VK_KHR_ray_tracing_pipeline"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingNV">
+            <enable extension="VK_NV_ray_tracing"/>
+        </spirvcapability>
+        <spirvcapability name="RayTracingMotionBlurNV">
+            <enable struct="VkPhysicalDeviceRayTracingMotionBlurFeaturesNV" feature="rayTracingMotionBlur" requires="VK_NV_ray_tracing_motion_blur"/>
+        </spirvcapability>
+        <spirvcapability name="TransformFeedback">
+            <enable struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT" feature="transformFeedback" requires="VK_EXT_transform_feedback"/>
+        </spirvcapability>
+        <spirvcapability name="GeometryStreams">
+            <enable struct="VkPhysicalDeviceTransformFeedbackFeaturesEXT" feature="geometryStreams" requires="VK_EXT_transform_feedback"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentDensityEXT">
+            <enable struct="VkPhysicalDeviceFragmentDensityMapFeaturesEXT" feature="fragmentDensityMap" requires="VK_EXT_fragment_density_map"/>
+        </spirvcapability>
+        <spirvcapability name="PhysicalStorageBufferAddresses">
+            <enable struct="VkPhysicalDeviceVulkan12Features" feature="bufferDeviceAddress" requires="VK_VERSION_1_2,VK_KHR_buffer_device_address"/>
+            <enable struct="VkPhysicalDeviceBufferDeviceAddressFeaturesEXT" feature="bufferDeviceAddress" requires="VK_EXT_buffer_device_address" alias="bufferDeviceAddressEXT"/>
+        </spirvcapability>
+        <spirvcapability name="CooperativeMatrixNV">
+            <enable struct="VkPhysicalDeviceCooperativeMatrixFeaturesNV" feature="cooperativeMatrix" requires="VK_NV_cooperative_matrix"/>
+        </spirvcapability>
+        <spirvcapability name="IntegerFunctions2INTEL">
+            <enable struct="VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL" feature="shaderIntegerFunctions2" requires="VK_INTEL_shader_integer_functions2"/>
+        </spirvcapability>
+        <spirvcapability name="ShaderSMBuiltinsNV">
+            <enable struct="VkPhysicalDeviceShaderSMBuiltinsFeaturesNV" feature="shaderSMBuiltins" requires="VK_NV_shader_sm_builtins"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShaderSampleInterlockEXT">
+            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderSampleInterlock" requires="VK_EXT_fragment_shader_interlock"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShaderPixelInterlockEXT">
+            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderPixelInterlock" requires="VK_EXT_fragment_shader_interlock"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShaderShadingRateInterlockEXT">
+            <enable struct="VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT" feature="fragmentShaderShadingRateInterlock" requires="VK_EXT_fragment_shader_interlock"/>
+            <enable struct="VkPhysicalDeviceShadingRateImageFeaturesNV" feature="shadingRateImage" requires="VK_NV_shading_rate_image"/>
+        </spirvcapability>
+        <spirvcapability name="DemoteToHelperInvocationEXT">
+            <enable struct="VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT" feature="shaderDemoteToHelperInvocation" requires="VK_EXT_shader_demote_to_helper_invocation"/>
+        </spirvcapability>
+        <spirvcapability name="FragmentShadingRateKHR">
+            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="pipelineFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
+            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="primitiveFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
+            <enable struct="VkPhysicalDeviceFragmentShadingRateFeaturesKHR" feature="attachmentFragmentShadingRate" requires="VK_KHR_fragment_shading_rate"/>
+        </spirvcapability>
+        <spirvcapability name="WorkgroupMemoryExplicitLayoutKHR">
+            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout" requires="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvcapability>
+        <spirvcapability name="WorkgroupMemoryExplicitLayout8BitAccessKHR">
+            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout8BitAccess" requires="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvcapability>
+        <spirvcapability name="WorkgroupMemoryExplicitLayout16BitAccessKHR">
+            <enable struct="VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR" feature="workgroupMemoryExplicitLayout16BitAccess" requires="VK_KHR_workgroup_memory_explicit_layout"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductInputAllKHR">
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductInput4x8BitKHR">
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductInput4x8BitPackedKHR">
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+        <spirvcapability name="DotProductKHR">
+            <enable struct="VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" feature="shaderIntegerDotProduct" requires="VK_KHR_shader_integer_dot_product"/>
+        </spirvcapability>
+    </spirvcapabilities>
+</registry>
diff --git a/include/config.h.in b/include/config.h.in
index 0cfb7a81805..0335ea31d2d 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -95,6 +95,9 @@
 /* Define to 1 if you have the `futimesat' function. */
 #undef HAVE_FUTIMESAT
 
+/* Define to 1 if you have the <gcrypt.h> header file. */
+#undef HAVE_GCRYPT_H
+
 /* Define to 1 if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
@@ -296,9 +299,6 @@
 /* Define to 1 if you have the <mach-o/loader.h> header file. */
 #undef HAVE_MACH_O_LOADER_H
 
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
 /* Define to 1 if you have the <Metal/Metal.h> header file. */
 #undef HAVE_METAL_METAL_H
 
@@ -497,6 +497,9 @@
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
+/* Define to 1 if you have the <stdio.h> header file. */
+#undef HAVE_STDIO_H
+
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
@@ -811,6 +814,9 @@
 /* Define to 1 if you have the <X11/extensions/XInput.h> header file. */
 #undef HAVE_X11_EXTENSIONS_XINPUT_H
 
+/* Define to 1 if you have the <X11/extensions/Xpresent.h> header file. */
+#undef HAVE_X11_EXTENSIONS_XPRESENT_H
+
 /* Define to 1 if you have the <X11/extensions/Xrandr.h> header file. */
 #undef HAVE_X11_EXTENSIONS_XRANDR_H
 
@@ -898,6 +904,9 @@
 /* Define to the soname of the libfreetype library. */
 #undef SONAME_LIBFREETYPE
 
+/* Define to the soname of the libgcrypt library. */
+#undef SONAME_LIBGCRYPT
+
 /* Define to the soname of the libGL library. */
 #undef SONAME_LIBGL
 
@@ -970,6 +979,9 @@
 /* Define to the soname of the libXinerama library. */
 #undef SONAME_LIBXINERAMA
 
+/* Define to the soname of the libXpresent library. */
+#undef SONAME_LIBXPRESENT
+
 /* Define to the soname of the libXrandr library. */
 #undef SONAME_LIBXRANDR
 
@@ -982,17 +994,14 @@
 /* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
 #undef STAT_MACROS_BROKEN
 
-/* Define to 1 if you have the ANSI C header files. */
+/* Define to 1 if all of the C90 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
 #undef STDC_HEADERS
 
 /* Define to 1 if the X Window System is missing or not being used. */
 #undef X_DISPLAY_MISSING
 
-/* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef _DARWIN_USE_64_BIT_INODE
-# define _DARWIN_USE_64_BIT_INODE 1
-#endif
-
 /* Number of bits in a file offset, on hosts where this is settable. */
 #undef _FILE_OFFSET_BITS
 
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 9dd0b9ecb1e..436ae510006 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -910,6 +910,7 @@ struct get_startup_info_reply
 struct init_process_done_request
 {
     struct request_header __header;
+    /* VARARG(cpu_override,cpu_topology_override); */
     char __pad_12[4];
     client_ptr_t teb;
     client_ptr_t peb;
@@ -955,7 +956,6 @@ struct init_thread_request
     int          wait_fd;
     client_ptr_t teb;
     client_ptr_t entry;
-    /* VARARG(cpu_override,cpu_topology_override); */
 };
 struct init_thread_reply
 {
@@ -5429,6 +5429,177 @@ struct get_next_thread_reply
     char __pad_12[4];
 };
 
+enum esync_type
+{
+    ESYNC_SEMAPHORE = 1,
+    ESYNC_AUTO_EVENT,
+    ESYNC_MANUAL_EVENT,
+    ESYNC_MUTEX,
+    ESYNC_AUTO_SERVER,
+    ESYNC_MANUAL_SERVER,
+    ESYNC_QUEUE,
+};
+
+
+struct create_esync_request
+{
+    struct request_header __header;
+    unsigned int access;
+    int          initval;
+    int          type;
+    int          max;
+    /* VARARG(objattr,object_attributes); */
+    char __pad_28[4];
+};
+struct create_esync_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    int          type;
+    unsigned int shm_idx;
+    char __pad_20[4];
+};
+
+struct open_esync_request
+{
+    struct request_header __header;
+    unsigned int access;
+    unsigned int attributes;
+    obj_handle_t rootdir;
+    int          type;
+    /* VARARG(name,unicode_str); */
+    char __pad_28[4];
+};
+struct open_esync_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    int          type;
+    unsigned int shm_idx;
+    char __pad_20[4];
+};
+
+
+struct get_esync_fd_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_esync_fd_reply
+{
+    struct reply_header __header;
+    int          type;
+    unsigned int shm_idx;
+};
+
+
+struct esync_msgwait_request
+{
+    struct request_header __header;
+    int          in_msgwait;
+};
+struct esync_msgwait_reply
+{
+    struct reply_header __header;
+};
+
+
+struct get_esync_apc_fd_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct get_esync_apc_fd_reply
+{
+    struct reply_header __header;
+};
+
+enum fsync_type
+{
+    FSYNC_SEMAPHORE = 1,
+    FSYNC_AUTO_EVENT,
+    FSYNC_MANUAL_EVENT,
+    FSYNC_MUTEX,
+    FSYNC_AUTO_SERVER,
+    FSYNC_MANUAL_SERVER,
+    FSYNC_QUEUE,
+};
+
+
+struct create_fsync_request
+{
+    struct request_header __header;
+    unsigned int access;
+    int low;
+    int high;
+    int type;
+    /* VARARG(objattr,object_attributes); */
+    char __pad_28[4];
+};
+struct create_fsync_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    int type;
+    unsigned int shm_idx;
+    char __pad_20[4];
+};
+
+
+struct open_fsync_request
+{
+    struct request_header __header;
+    unsigned int access;
+    unsigned int attributes;
+    obj_handle_t rootdir;
+    int          type;
+    /* VARARG(name,unicode_str); */
+    char __pad_28[4];
+};
+struct open_fsync_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    int          type;
+    unsigned int shm_idx;
+    char __pad_20[4];
+};
+
+
+struct get_fsync_idx_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_fsync_idx_reply
+{
+    struct reply_header __header;
+    int          type;
+    unsigned int shm_idx;
+};
+
+struct fsync_msgwait_request
+{
+    struct request_header __header;
+    int          in_msgwait;
+};
+struct fsync_msgwait_reply
+{
+    struct reply_header __header;
+};
+
+struct get_fsync_apc_idx_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct get_fsync_apc_idx_reply
+{
+    struct reply_header __header;
+    unsigned int shm_idx;
+    char __pad_12[4];
+};
+
 
 enum request
 {
@@ -5706,6 +5877,16 @@ enum request
     REQ_suspend_process,
     REQ_resume_process,
     REQ_get_next_thread,
+    REQ_create_esync,
+    REQ_open_esync,
+    REQ_get_esync_fd,
+    REQ_esync_msgwait,
+    REQ_get_esync_apc_fd,
+    REQ_create_fsync,
+    REQ_open_fsync,
+    REQ_get_fsync_idx,
+    REQ_fsync_msgwait,
+    REQ_get_fsync_apc_idx,
     REQ_NB_REQUESTS
 };
 
@@ -5987,6 +6168,16 @@ union generic_request
     struct suspend_process_request suspend_process_request;
     struct resume_process_request resume_process_request;
     struct get_next_thread_request get_next_thread_request;
+    struct create_esync_request create_esync_request;
+    struct open_esync_request open_esync_request;
+    struct get_esync_fd_request get_esync_fd_request;
+    struct esync_msgwait_request esync_msgwait_request;
+    struct get_esync_apc_fd_request get_esync_apc_fd_request;
+    struct create_fsync_request create_fsync_request;
+    struct open_fsync_request open_fsync_request;
+    struct get_fsync_idx_request get_fsync_idx_request;
+    struct fsync_msgwait_request fsync_msgwait_request;
+    struct get_fsync_apc_idx_request get_fsync_apc_idx_request;
 };
 union generic_reply
 {
@@ -6266,11 +6457,21 @@ union generic_reply
     struct suspend_process_reply suspend_process_reply;
     struct resume_process_reply resume_process_reply;
     struct get_next_thread_reply get_next_thread_reply;
+    struct create_esync_reply create_esync_reply;
+    struct open_esync_reply open_esync_reply;
+    struct get_esync_fd_reply get_esync_fd_reply;
+    struct esync_msgwait_reply esync_msgwait_reply;
+    struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
+    struct create_fsync_reply create_fsync_reply;
+    struct open_fsync_reply open_fsync_reply;
+    struct get_fsync_idx_reply get_fsync_idx_reply;
+    struct fsync_msgwait_reply fsync_msgwait_reply;
+    struct get_fsync_apc_idx_reply get_fsync_apc_idx_reply;
 };
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 735
+#define SERVER_PROTOCOL_VERSION 736
 
 /* ### protocol_version end ### */
 
diff --git a/include/wine/vulkan.h b/include/wine/vulkan.h
index 3f131466735..c4e8b350f65 100644
--- a/include/wine/vulkan.h
+++ b/include/wine/vulkan.h
@@ -507,26 +507,26 @@
 #define VK_USE_64_BIT_PTR_DEFINES 0
 
 #ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
-#if (VK_USE_64_BIT_PTR_DEFINES==1)
-#if (defined(__cplusplus) && (__cplusplus >= 201103L)) || (defined(_MSVC_LANG) && (_MSVC_LANG >= 201103L))
-#define VK_NULL_HANDLE nullptr
-#else
-#define VK_NULL_HANDLE ((void*)0)
-#endif
-#else
-#define VK_NULL_HANDLE 0ULL
-#endif
+    #if (VK_USE_64_BIT_PTR_DEFINES==1)
+        #if (defined(__cplusplus) && (__cplusplus >= 201103L)) || (defined(_MSVC_LANG) && (_MSVC_LANG >= 201103L))
+            #define VK_NULL_HANDLE nullptr
+        #else
+            #define VK_NULL_HANDLE ((void*)0)
+        #endif
+    #else
+        #define VK_NULL_HANDLE 0ULL
+    #endif
 #endif
 #ifndef VK_NULL_HANDLE
-#define VK_NULL_HANDLE 0
+    #define VK_NULL_HANDLE 0
 #endif
 
 #ifndef VK_DEFINE_NON_DISPATCHABLE_HANDLE
-#if (VK_USE_64_BIT_PTR_DEFINES==1)
-#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
-#else
-#define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
-#endif
+    #if (VK_USE_64_BIT_PTR_DEFINES==1)
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
+    #else
+        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
+    #endif
 #endif
 VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureKHR)
 VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkAccelerationStructureNV)
diff --git a/server/request.h b/server/request.h
index 33d4237f49f..2fe59ab3bbc 100644
--- a/server/request.h
+++ b/server/request.h
@@ -393,6 +393,16 @@ DECL_HANDLER(terminate_job);
 DECL_HANDLER(suspend_process);
 DECL_HANDLER(resume_process);
 DECL_HANDLER(get_next_thread);
+DECL_HANDLER(create_esync);
+DECL_HANDLER(open_esync);
+DECL_HANDLER(get_esync_fd);
+DECL_HANDLER(esync_msgwait);
+DECL_HANDLER(get_esync_apc_fd);
+DECL_HANDLER(create_fsync);
+DECL_HANDLER(open_fsync);
+DECL_HANDLER(get_fsync_idx);
+DECL_HANDLER(fsync_msgwait);
+DECL_HANDLER(get_fsync_apc_idx);
 
 #ifdef WANT_REQUEST_HANDLERS
 
@@ -673,6 +683,16 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_suspend_process,
     (req_handler)req_resume_process,
     (req_handler)req_get_next_thread,
+    (req_handler)req_create_esync,
+    (req_handler)req_open_esync,
+    (req_handler)req_get_esync_fd,
+    (req_handler)req_esync_msgwait,
+    (req_handler)req_get_esync_apc_fd,
+    (req_handler)req_create_fsync,
+    (req_handler)req_open_fsync,
+    (req_handler)req_get_fsync_idx,
+    (req_handler)req_fsync_msgwait,
+    (req_handler)req_get_fsync_apc_idx,
 };
 
 C_ASSERT( sizeof(abstime_t) == 8 );
@@ -2248,6 +2268,60 @@ C_ASSERT( FIELD_OFFSET(struct get_next_thread_request, flags) == 28 );
 C_ASSERT( sizeof(struct get_next_thread_request) == 32 );
 C_ASSERT( FIELD_OFFSET(struct get_next_thread_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_next_thread_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, access) == 12 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, initval) == 16 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, type) == 20 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_request, max) == 24 );
+C_ASSERT( sizeof(struct create_esync_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_reply, type) == 12 );
+C_ASSERT( FIELD_OFFSET(struct create_esync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct create_esync_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, access) == 12 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, attributes) == 16 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, rootdir) == 20 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_request, type) == 24 );
+C_ASSERT( sizeof(struct open_esync_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_reply, type) == 12 );
+C_ASSERT( FIELD_OFFSET(struct open_esync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct open_esync_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_esync_fd_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, type) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_esync_fd_reply, shm_idx) == 12 );
+C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct esync_msgwait_request, in_msgwait) == 12 );
+C_ASSERT( sizeof(struct esync_msgwait_request) == 16 );
+C_ASSERT( sizeof(struct get_esync_apc_fd_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct create_fsync_request, access) == 12 );
+C_ASSERT( FIELD_OFFSET(struct create_fsync_request, low) == 16 );
+C_ASSERT( FIELD_OFFSET(struct create_fsync_request, high) == 20 );
+C_ASSERT( FIELD_OFFSET(struct create_fsync_request, type) == 24 );
+C_ASSERT( sizeof(struct create_fsync_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct create_fsync_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct create_fsync_reply, type) == 12 );
+C_ASSERT( FIELD_OFFSET(struct create_fsync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct create_fsync_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct open_fsync_request, access) == 12 );
+C_ASSERT( FIELD_OFFSET(struct open_fsync_request, attributes) == 16 );
+C_ASSERT( FIELD_OFFSET(struct open_fsync_request, rootdir) == 20 );
+C_ASSERT( FIELD_OFFSET(struct open_fsync_request, type) == 24 );
+C_ASSERT( sizeof(struct open_fsync_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct open_fsync_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct open_fsync_reply, type) == 12 );
+C_ASSERT( FIELD_OFFSET(struct open_fsync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct open_fsync_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_fsync_idx_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_fsync_idx_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_fsync_idx_reply, type) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_fsync_idx_reply, shm_idx) == 12 );
+C_ASSERT( sizeof(struct get_fsync_idx_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct fsync_msgwait_request, in_msgwait) == 12 );
+C_ASSERT( sizeof(struct fsync_msgwait_request) == 16 );
+C_ASSERT( sizeof(struct get_fsync_apc_idx_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_fsync_apc_idx_reply, shm_idx) == 8 );
+C_ASSERT( sizeof(struct get_fsync_apc_idx_reply) == 16 );
 
 #endif  /* WANT_REQUEST_HANDLERS */
 
diff --git a/server/trace.c b/server/trace.c
index 0acb54471e6..ed3221bc378 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1520,7 +1520,8 @@ static void dump_get_startup_info_reply( const struct get_startup_info_reply *re
 
 static void dump_init_process_done_request( const struct init_process_done_request *req )
 {
-    dump_uint64( " teb=", &req->teb );
+    dump_varargs_cpu_topology_override( " cpu_override=", cur_size );
+    dump_uint64( ", teb=", &req->teb );
     dump_uint64( ", peb=", &req->peb );
     dump_uint64( ", ldt_copy=", &req->ldt_copy );
 }
@@ -1557,7 +1558,6 @@ static void dump_init_thread_request( const struct init_thread_request *req )
     fprintf( stderr, ", wait_fd=%d", req->wait_fd );
     dump_uint64( ", teb=", &req->teb );
     dump_uint64( ", entry=", &req->entry );
-    dump_varargs_cpu_topology_override( ", cpu_override=", cur_size );
 }
 
 static void dump_init_thread_reply( const struct init_thread_reply *req )
@@ -4581,6 +4581,115 @@ static void dump_get_next_thread_reply( const struct get_next_thread_reply *req
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
+static void dump_create_esync_request( const struct create_esync_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", initval=%d", req->initval );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", max=%d", req->max );
+    dump_varargs_object_attributes( ", objattr=", cur_size );
+}
+
+static void dump_create_esync_reply( const struct create_esync_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+}
+
+static void dump_open_esync_request( const struct open_esync_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", attributes=%08x", req->attributes );
+    fprintf( stderr, ", rootdir=%04x", req->rootdir );
+    fprintf( stderr, ", type=%d", req->type );
+    dump_varargs_unicode_str( ", name=", cur_size );
+}
+
+static void dump_open_esync_reply( const struct open_esync_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+}
+
+static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_esync_fd_reply( const struct get_esync_fd_reply *req )
+{
+    fprintf( stderr, " type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+}
+
+static void dump_esync_msgwait_request( const struct esync_msgwait_request *req )
+{
+    fprintf( stderr, " in_msgwait=%d", req->in_msgwait );
+}
+
+static void dump_get_esync_apc_fd_request( const struct get_esync_apc_fd_request *req )
+{
+}
+
+static void dump_create_fsync_request( const struct create_fsync_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", low=%d", req->low );
+    fprintf( stderr, ", high=%d", req->high );
+    fprintf( stderr, ", type=%d", req->type );
+    dump_varargs_object_attributes( ", objattr=", cur_size );
+}
+
+static void dump_create_fsync_reply( const struct create_fsync_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+}
+
+static void dump_open_fsync_request( const struct open_fsync_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", attributes=%08x", req->attributes );
+    fprintf( stderr, ", rootdir=%04x", req->rootdir );
+    fprintf( stderr, ", type=%d", req->type );
+    dump_varargs_unicode_str( ", name=", cur_size );
+}
+
+static void dump_open_fsync_reply( const struct open_fsync_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+}
+
+static void dump_get_fsync_idx_request( const struct get_fsync_idx_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_fsync_idx_reply( const struct get_fsync_idx_reply *req )
+{
+    fprintf( stderr, " type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+}
+
+static void dump_fsync_msgwait_request( const struct fsync_msgwait_request *req )
+{
+    fprintf( stderr, " in_msgwait=%d", req->in_msgwait );
+}
+
+static void dump_get_fsync_apc_idx_request( const struct get_fsync_apc_idx_request *req )
+{
+}
+
+static void dump_get_fsync_apc_idx_reply( const struct get_fsync_apc_idx_reply *req )
+{
+    fprintf( stderr, " shm_idx=%08x", req->shm_idx );
+}
+
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
     (dump_func)dump_get_new_process_info_request,
@@ -4856,6 +4965,16 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_suspend_process_request,
     (dump_func)dump_resume_process_request,
     (dump_func)dump_get_next_thread_request,
+    (dump_func)dump_create_esync_request,
+    (dump_func)dump_open_esync_request,
+    (dump_func)dump_get_esync_fd_request,
+    (dump_func)dump_esync_msgwait_request,
+    (dump_func)dump_get_esync_apc_fd_request,
+    (dump_func)dump_create_fsync_request,
+    (dump_func)dump_open_fsync_request,
+    (dump_func)dump_get_fsync_idx_request,
+    (dump_func)dump_fsync_msgwait_request,
+    (dump_func)dump_get_fsync_apc_idx_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
@@ -5133,6 +5252,16 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     NULL,
     (dump_func)dump_get_next_thread_reply,
+    (dump_func)dump_create_esync_reply,
+    (dump_func)dump_open_esync_reply,
+    (dump_func)dump_get_esync_fd_reply,
+    NULL,
+    NULL,
+    (dump_func)dump_create_fsync_reply,
+    (dump_func)dump_open_fsync_reply,
+    (dump_func)dump_get_fsync_idx_reply,
+    NULL,
+    (dump_func)dump_get_fsync_apc_idx_reply,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
@@ -5410,6 +5539,16 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "suspend_process",
     "resume_process",
     "get_next_thread",
+    "create_esync",
+    "open_esync",
+    "get_esync_fd",
+    "esync_msgwait",
+    "get_esync_apc_fd",
+    "create_fsync",
+    "open_fsync",
+    "get_fsync_idx",
+    "fsync_msgwait",
+    "get_fsync_apc_idx",
 };
 
 static const struct
diff --git a/tools/config.guess b/tools/config.guess
index e94095c5fbe..1972fda8eb0 100755
--- a/tools/config.guess
+++ b/tools/config.guess
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2020 Free Software Foundation, Inc.
+#   Copyright 1992-2021 Free Software Foundation, Inc.
 
-timestamp='2020-07-12'
+timestamp='2021-01-25'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -27,12 +27,12 @@ timestamp='2020-07-12'
 # Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
 #
 # Please send patches to <config-patches@gnu.org>.
 
 
-me=`echo "$0" | sed -e 's,.*/,,'`
+me=$(echo "$0" | sed -e 's,.*/,,')
 
 usage="\
 Usage: $0 [OPTION]
@@ -50,7 +50,7 @@ version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2020 Free Software Foundation, Inc.
+Copyright 1992-2021 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -103,7 +103,7 @@ set_cc_for_build() {
     test "$tmp" && return 0
     : "${TMPDIR=/tmp}"
     # shellcheck disable=SC2039
-    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+    { tmp=$( (umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null) && test -n "$tmp" && test -d "$tmp" ; } ||
 	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
 	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
 	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
@@ -131,16 +131,14 @@ if test -f /.attbin/uname ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
-UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
-UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
-UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+UNAME_MACHINE=$( (uname -m) 2>/dev/null) || UNAME_MACHINE=unknown
+UNAME_RELEASE=$( (uname -r) 2>/dev/null) || UNAME_RELEASE=unknown
+UNAME_SYSTEM=$( (uname -s) 2>/dev/null) || UNAME_SYSTEM=unknown
+UNAME_VERSION=$( (uname -v) 2>/dev/null) || UNAME_VERSION=unknown
 
 case "$UNAME_SYSTEM" in
 Linux|GNU|GNU/*)
-	# If the system lacks a compiler, then just pick glibc.
-	# We could probably try harder.
-	LIBC=gnu
+	LIBC=unknown
 
 	set_cc_for_build
 	cat <<-EOF > "$dummy.c"
@@ -149,17 +147,29 @@ Linux|GNU|GNU/*)
 	LIBC=uclibc
 	#elif defined(__dietlibc__)
 	LIBC=dietlibc
-	#else
+	#elif defined(__GLIBC__)
 	LIBC=gnu
+	#else
+	#include <stdarg.h>
+	/* First heuristic to detect musl libc.  */
+	#ifdef __DEFINED_va_list
+	LIBC=musl
+	#endif
 	#endif
 	EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
+	eval "$($CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g')"
 
-	# If ldd exists, use it to detect musl libc.
-	if command -v ldd >/dev/null && \
-		ldd --version 2>&1 | grep -q ^musl
-	then
-	    LIBC=musl
+	# Second heuristic to detect musl libc.
+	if [ "$LIBC" = unknown ] &&
+	   command -v ldd >/dev/null &&
+	   ldd --version 2>&1 | grep -q ^musl; then
+		LIBC=musl
+	fi
+
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	if [ "$LIBC" = unknown ]; then
+		LIBC=gnu
 	fi
 	;;
 esac
@@ -178,20 +188,20 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	#
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
-	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
-	    "/sbin/$sysctl" 2>/dev/null || \
-	    "/usr/sbin/$sysctl" 2>/dev/null || \
-	    echo unknown)`
+	UNAME_MACHINE_ARCH=$( (uname -p 2>/dev/null || \
+	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    echo unknown))
 	case "$UNAME_MACHINE_ARCH" in
+	    aarch64eb) machine=aarch64_be-unknown ;;
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
 	    earmv*)
-		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
-		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		arch=$(echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,')
+		endian=$(echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p')
 		machine="${arch}${endian}"-unknown
 		;;
 	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
@@ -222,7 +232,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	case "$UNAME_MACHINE_ARCH" in
 	    earm*)
 		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
-		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+		abi=$(echo "$UNAME_MACHINE_ARCH" | sed -e "$expr")
 		;;
 	esac
 	# The OS release
@@ -235,7 +245,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 		release='-gnu'
 		;;
 	    *)
-		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
+		release=$(echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2)
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
@@ -244,15 +254,15 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	echo "$machine-${os}${release}${abi-}"
 	exit ;;
     *:Bitrig:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	UNAME_MACHINE_ARCH=$(arch | sed 's/Bitrig.//')
 	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
 	exit ;;
     *:OpenBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	UNAME_MACHINE_ARCH=$(arch | sed 's/OpenBSD.//')
 	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
 	exit ;;
     *:LibertyBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	UNAME_MACHINE_ARCH=$(arch | sed 's/^.*BSD\.//')
 	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
 	exit ;;
     *:MidnightBSD:*:*)
@@ -288,17 +298,17 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		UNAME_RELEASE=$(/usr/sbin/sizer -v | awk '{print $3}')
 		;;
 	*5.*)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		UNAME_RELEASE=$(/usr/sbin/sizer -v | awk '{print $4}')
 		;;
 	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
 	# OSF/1 and Tru64 systems produced since 1995.  I hope that
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
-	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	ALPHA_CPU_TYPE=$(/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1)
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
 		UNAME_MACHINE=alpha ;;
@@ -336,7 +346,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
+	echo "$UNAME_MACHINE"-dec-osf"$(echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz)"
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
@@ -370,7 +380,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	exit ;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+	if test "$( (/bin/universe) 2>/dev/null)" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
@@ -383,17 +393,17 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	echo sparc-icl-nx6
 	exit ;;
     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
-	case `/usr/bin/uname -p` in
+	case $(/usr/bin/uname -p) in
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     s390x:SunOS:*:*)
-	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	echo "$UNAME_MACHINE"-ibm-solaris2"$(echo "$UNAME_RELEASE" | sed -e 's/[^.]*//')"
 	exit ;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo sparc-hal-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	echo sparc-sun-solaris2"$(echo "$UNAME_RELEASE" | sed -e 's/[^.]*//')"
 	exit ;;
     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
 	echo i386-pc-auroraux"$UNAME_RELEASE"
@@ -404,7 +414,7 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
 		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
@@ -412,30 +422,30 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo "$SUN_ARCH"-pc-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo sparc-sun-solaris3"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
+	case "$(/usr/bin/arch -k)" in
 	    Series*|S4*)
-		UNAME_RELEASE=`uname -v`
+		UNAME_RELEASE=$(uname -v)
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
+	echo sparc-sun-sunos"$(echo "$UNAME_RELEASE"|sed -e 's/-/_/')"
 	exit ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos"$UNAME_RELEASE"
 	exit ;;
     sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	UNAME_RELEASE=$( (sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null)
 	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
-	case "`/bin/arch`" in
+	case "$(/bin/arch)" in
 	    sun3)
 		echo m68k-sun-sunos"$UNAME_RELEASE"
 		;;
@@ -515,8 +525,8 @@ case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
 	}
 EOF
 	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
-	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
+	  dummyarg=$(echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p') &&
+	  SYSTEM_NAME=$("$dummy" "$dummyarg") &&
 	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos"$UNAME_RELEASE"
 	exit ;;
@@ -543,11 +553,11 @@ EOF
 	exit ;;
     AViiON:dgux:*:*)
 	# DG/UX returns AViiON for all architectures
-	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
+	UNAME_PROCESSOR=$(/usr/bin/uname -p)
+	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
 	then
-	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
-	       [ "$TARGET_BINARY_INTERFACE"x = x ]
+	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
+	       test "$TARGET_BINARY_INTERFACE"x = x
 	    then
 		echo m88k-dg-dgux"$UNAME_RELEASE"
 	    else
@@ -571,17 +581,17 @@ EOF
 	echo m68k-tektronix-bsd
 	exit ;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
+	echo mips-sgi-irix"$(echo "$UNAME_RELEASE"|sed -e 's/-/_/g')"
 	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
 	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+	exit ;;               # Note that: echo "'$(uname -s)'" gives 'AIX '
     i*86:AIX:*:*)
 	echo i386-ibm-aix
 	exit ;;
     ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if test -x /usr/bin/oslevel ; then
+		IBM_REV=$(/usr/bin/oslevel)
 	else
 		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
@@ -601,7 +611,7 @@ EOF
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=$("$dummy")
 		then
 			echo "$SYSTEM_NAME"
 		else
@@ -614,15 +624,15 @@ EOF
 	fi
 	exit ;;
     *:AIX:*:[4567])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	IBM_CPU_ID=$(/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }')
 	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/lslpp ] ; then
-		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
-			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
+	if test -x /usr/bin/lslpp ; then
+		IBM_REV=$(/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/)
 	else
 		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
@@ -650,14 +660,14 @@ EOF
 	echo m68k-hp-bsd4.4
 	exit ;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	HPUX_REV=$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//')
 	case "$UNAME_MACHINE" in
 	    9000/31?)            HP_ARCH=m68000 ;;
 	    9000/[34]??)         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
-		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		if test -x /usr/bin/getconf; then
+		    sc_cpu_version=$(/usr/bin/getconf SC_CPU_VERSION 2>/dev/null)
+		    sc_kernel_bits=$(/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null)
 		    case "$sc_cpu_version" in
 		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
 		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
@@ -669,7 +679,7 @@ EOF
 			esac ;;
 		    esac
 		fi
-		if [ "$HP_ARCH" = "" ]; then
+		if test "$HP_ARCH" = ""; then
 		    set_cc_for_build
 		    sed 's/^		//' << EOF > "$dummy.c"
 
@@ -704,11 +714,11 @@ EOF
 		    exit (0);
 		}
 EOF
-		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=$("$dummy")
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ "$HP_ARCH" = hppa2.0w ]
+	if test "$HP_ARCH" = hppa2.0w
 	then
 	    set_cc_for_build
 
@@ -732,7 +742,7 @@ EOF
 	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
 	exit ;;
     ia64:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	HPUX_REV=$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//')
 	echo ia64-hp-hpux"$HPUX_REV"
 	exit ;;
     3050*:HI-UX:*:*)
@@ -762,7 +772,7 @@ EOF
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=$("$dummy") &&
 		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
 	exit ;;
@@ -782,7 +792,7 @@ EOF
 	echo hppa1.0-hp-osf
 	exit ;;
     i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
+	if test -x /usr/sbin/sysversion ; then
 	    echo "$UNAME_MACHINE"-unknown-osf1mk
 	else
 	    echo "$UNAME_MACHINE"-unknown-osf1
@@ -831,14 +841,14 @@ EOF
 	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
-	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
-	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	FUJITSU_PROC=$(uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz)
+	FUJITSU_SYS=$(uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///')
+	FUJITSU_REL=$(echo "$UNAME_RELEASE" | sed -e 's/ /_/')
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
-	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	FUJITSU_SYS=$(uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///')
+	FUJITSU_REL=$(echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/')
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
@@ -851,25 +861,25 @@ EOF
 	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
 	exit ;;
     arm:FreeBSD:*:*)
-	UNAME_PROCESSOR=`uname -p`
+	UNAME_PROCESSOR=$(uname -p)
 	set_cc_for_build
 	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_PCS_VFP
 	then
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabi
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"$(echo ${UNAME_RELEASE}|sed -e 's/[-(].*//')"-gnueabi
 	else
-	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabihf
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"$(echo ${UNAME_RELEASE}|sed -e 's/[-(].*//')"-gnueabihf
 	fi
 	exit ;;
     *:FreeBSD:*:*)
-	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	UNAME_PROCESSOR=$(/usr/bin/uname -p)
 	case "$UNAME_PROCESSOR" in
 	    amd64)
 		UNAME_PROCESSOR=x86_64 ;;
 	    i386)
 		UNAME_PROCESSOR=i586 ;;
 	esac
-	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+	echo "$UNAME_PROCESSOR"-unknown-freebsd"$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')"
 	exit ;;
     i*:CYGWIN*:*)
 	echo "$UNAME_MACHINE"-pc-cygwin
@@ -905,15 +915,15 @@ EOF
 	echo x86_64-pc-cygwin
 	exit ;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo powerpcle-unknown-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
+	echo "$(echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,')-unknown-$LIBC$(echo "$UNAME_RELEASE"|sed -e 's,/.*$,,')"
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
+	echo "$UNAME_MACHINE-unknown-$(echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]")$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')-$LIBC"
 	exit ;;
     *:Minix:*:*)
 	echo "$UNAME_MACHINE"-unknown-minix
@@ -926,7 +936,7 @@ EOF
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
+	case $(sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null) in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
@@ -985,6 +995,9 @@ EOF
     k1om:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+    loongarch32:Linux:*:* | loongarch64:Linux:*:* | loongarchx32:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     m32r*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
@@ -1035,7 +1048,7 @@ EOF
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`"
+	eval "$($CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI')"
 	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
 	;;
     mips64el:Linux:*:*)
@@ -1055,7 +1068,7 @@ EOF
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
-	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	case $(grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2) in
 	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
 	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
 	  *)    echo hppa-unknown-linux-"$LIBC" ;;
@@ -1073,7 +1086,7 @@ EOF
     ppcle:Linux:*:*)
 	echo powerpcle-unknown-linux-"$LIBC"
 	exit ;;
-    riscv32:Linux:*:* | riscv64:Linux:*:*)
+    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
@@ -1097,7 +1110,7 @@ EOF
     x86_64:Linux:*:*)
 	set_cc_for_build
 	LIBCABI=$LIBC
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __ILP32__'; echo IS_X32; echo '#endif') | \
 		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_X32 >/dev/null
@@ -1145,7 +1158,7 @@ EOF
 	echo "$UNAME_MACHINE"-pc-msdosdjgpp
 	exit ;;
     i*86:*:4.*:*)
-	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
+	UNAME_REL=$(echo "$UNAME_RELEASE" | sed 's/\/MP$//')
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
 		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
 	else
@@ -1154,7 +1167,7 @@ EOF
 	exit ;;
     i*86:*:5:[678]*)
 	# UnixWare 7.x, OpenUNIX and OpenServer 6.
-	case `/bin/uname -X | grep "^Machine"` in
+	case $(/bin/uname -X | grep "^Machine") in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
@@ -1163,10 +1176,10 @@ EOF
 	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
-		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		UNAME_REL=$(sed -n 's/.*Version //p' </usr/options/cb.name)
 		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		UNAME_REL=$( (/bin/uname -X|grep Release|sed -e 's/.*= //'))
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
 			&& UNAME_MACHINE=i586
@@ -1216,7 +1229,7 @@ EOF
     3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
-	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	&& OS_REL=.$(sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid)
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
@@ -1227,7 +1240,7 @@ EOF
     NCR*:*:4.2:* | MPRAS*:*:4.2:*)
 	OS_REL='.3'
 	test -r /etc/.relid \
-	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	    && OS_REL=.$(sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid)
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
@@ -1260,7 +1273,7 @@ EOF
 	exit ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
-		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		UNAME_MACHINE=$( (uname -p) 2>/dev/null)
 		echo "$UNAME_MACHINE"-sni-sysv4
 	else
 		echo ns32k-sni-sysv
@@ -1294,7 +1307,7 @@ EOF
 	echo mips-sony-newsos6
 	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
+	if test -d /usr/nec; then
 		echo mips-nec-sysv"$UNAME_RELEASE"
 	else
 		echo mips-unknown-sysv"$UNAME_RELEASE"
@@ -1346,7 +1359,7 @@ EOF
 	echo aarch64-apple-darwin"$UNAME_RELEASE"
 	exit ;;
     *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p`
+	UNAME_PROCESSOR=$(uname -p)
 	case $UNAME_PROCESSOR in
 	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
@@ -1359,7 +1372,7 @@ EOF
 	else
 	    set_cc_for_build
 	fi
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
 		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		   grep IS_64BIT_ARCH >/dev/null
@@ -1383,7 +1396,7 @@ EOF
 	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	UNAME_PROCESSOR=`uname -p`
+	UNAME_PROCESSOR=$(uname -p)
 	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
@@ -1451,10 +1464,10 @@ EOF
 	echo mips-sei-seiux"$UNAME_RELEASE"
 	exit ;;
     *:DragonFly:*:*)
-	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+	echo "$UNAME_MACHINE"-unknown-dragonfly"$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')"
 	exit ;;
     *:*VMS:*:*)
-	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	UNAME_MACHINE=$( (uname -p) 2>/dev/null)
 	case "$UNAME_MACHINE" in
 	    A*) echo alpha-dec-vms ; exit ;;
 	    I*) echo ia64-dec-vms ; exit ;;
@@ -1464,13 +1477,13 @@ EOF
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
+	echo "$UNAME_MACHINE"-pc-skyos"$(echo "$UNAME_RELEASE" | sed -e 's/ .*$//')"
 	exit ;;
     i*86:rdos:*:*)
 	echo "$UNAME_MACHINE"-pc-rdos
 	exit ;;
-    i*86:AROS:*:*)
-	echo "$UNAME_MACHINE"-pc-aros
+    *:AROS:*:*)
+	echo "$UNAME_MACHINE"-unknown-aros
 	exit ;;
     x86_64:VMkernel:*:*)
 	echo "$UNAME_MACHINE"-unknown-esx
@@ -1522,7 +1535,7 @@ main ()
 #define __ARCHITECTURE__ "m68k"
 #endif
   int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  version=$( (hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null);
   if (version < 4)
     printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
   else
@@ -1614,7 +1627,7 @@ main ()
 }
 EOF
 
-$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=$($dummy) &&
 	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
@@ -1639,14 +1652,14 @@ This script (version $timestamp), has failed to recognize the
 operating system you are using. If your script is old, overwrite *all*
 copies of config.guess and config.sub with the latest versions from:
 
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
 and
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
 EOF
 
-year=`echo $timestamp | sed 's,-.*,,'`
+year=$(echo $timestamp | sed 's,-.*,,')
 # shellcheck disable=SC2003
-if test "`expr "\`date +%Y\`" - "$year"`" -lt 3 ; then
+if test "$(expr "$(date +%Y)" - "$year")" -lt 3 ; then
    cat >&2 <<EOF
 
 If $0 has already been updated, send the following data and any
@@ -1655,20 +1668,20 @@ provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
+uname -m = $( (uname -m) 2>/dev/null || echo unknown)
+uname -r = $( (uname -r) 2>/dev/null || echo unknown)
+uname -s = $( (uname -s) 2>/dev/null || echo unknown)
+uname -v = $( (uname -v) 2>/dev/null || echo unknown)
 
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+/usr/bin/uname -p = $( (/usr/bin/uname -p) 2>/dev/null)
+/bin/uname -X     = $( (/bin/uname -X) 2>/dev/null)
 
-hostinfo               = `(hostinfo) 2>/dev/null`
-/bin/universe          = `(/bin/universe) 2>/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
-/bin/arch              = `(/bin/arch) 2>/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+hostinfo               = $( (hostinfo) 2>/dev/null)
+/bin/universe          = $( (/bin/universe) 2>/dev/null)
+/usr/bin/arch -k       = $( (/usr/bin/arch -k) 2>/dev/null)
+/bin/arch              = $( (/bin/arch) 2>/dev/null)
+/usr/bin/oslevel       = $( (/usr/bin/oslevel) 2>/dev/null)
+/usr/convex/getsysinfo = $( (/usr/convex/getsysinfo) 2>/dev/null)
 
 UNAME_MACHINE = "$UNAME_MACHINE"
 UNAME_RELEASE = "$UNAME_RELEASE"
diff --git a/tools/config.sub b/tools/config.sub
index 3d9a8dc3d5a..63c1f1c8b5e 100755
--- a/tools/config.sub
+++ b/tools/config.sub
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2020 Free Software Foundation, Inc.
+#   Copyright 1992-2021 Free Software Foundation, Inc.
 
-timestamp='2020-07-10'
+timestamp='2021-01-08'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -33,7 +33,7 @@ timestamp='2020-07-10'
 # Otherwise, we print the canonical config type on stdout and succeed.
 
 # You can get the latest version of this script from:
-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
 
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
@@ -50,7 +50,7 @@ timestamp='2020-07-10'
 #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
-me=`echo "$0" | sed -e 's,.*/,,'`
+me=$(echo "$0" | sed -e 's,.*/,,')
 
 usage="\
 Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
@@ -67,7 +67,7 @@ Report bugs and patches to <config-patches@gnu.org>."
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2020 Free Software Foundation, Inc.
+Copyright 1992-2021 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -769,22 +769,22 @@ case $basic_machine in
 		vendor=hp
 		;;
 	i*86v32)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		cpu=$(echo "$1" | sed -e 's/86.*/86/')
 		vendor=pc
 		basic_os=sysv32
 		;;
 	i*86v4*)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		cpu=$(echo "$1" | sed -e 's/86.*/86/')
 		vendor=pc
 		basic_os=sysv4
 		;;
 	i*86v)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		cpu=$(echo "$1" | sed -e 's/86.*/86/')
 		vendor=pc
 		basic_os=sysv
 		;;
 	i*86sol2)
-		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		cpu=$(echo "$1" | sed -e 's/86.*/86/')
 		vendor=pc
 		basic_os=solaris2
 		;;
@@ -917,7 +917,7 @@ case $basic_machine in
 		;;
 	leon-*|leon[3-9]-*)
 		cpu=sparc
-		vendor=`echo "$basic_machine" | sed 's/-.*//'`
+		vendor=$(echo "$basic_machine" | sed 's/-.*//')
 		;;
 
 	*-*)
@@ -1084,7 +1084,7 @@ case $cpu-$vendor in
 		cpu=mipsisa64sb1el
 		;;
 	sh5e[lb]-*)
-		cpu=`echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/'`
+		cpu=$(echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/')
 		;;
 	spur-*)
 		cpu=spur
@@ -1102,7 +1102,7 @@ case $cpu-$vendor in
 		cpu=x86_64
 		;;
 	xscale-* | xscalee[bl]-*)
-		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
+		cpu=$(echo "$cpu" | sed 's/^xscale/arm/')
 		;;
 	arm64-*)
 		cpu=aarch64
@@ -1185,6 +1185,7 @@ case $cpu-$vendor in
 			| k1om \
 			| le32 | le64 \
 			| lm32 \
+			| loongarch32 | loongarch64 | loongarchx32 \
 			| m32c | m32r | m32rle \
 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
 			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
@@ -1229,7 +1230,7 @@ case $cpu-$vendor in
 			| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \
 			| pru \
 			| pyramid \
-			| riscv | riscv32 | riscv64 \
+			| riscv | riscv32 | riscv32be | riscv64 | riscv64be \
 			| rl78 | romp | rs6000 | rx \
 			| s390 | s390x \
 			| score \
@@ -1241,6 +1242,7 @@ case $cpu-$vendor in
 			| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \
 			| spu \
 			| tahoe \
+			| thumbv7* \
 			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
 			| tron \
 			| ubicom32 \
@@ -1278,7 +1280,7 @@ esac
 
 # Decode manufacturer-specific aliases for certain operating systems.
 
-if [ x$basic_os != x ]
+if test x$basic_os != x
 then
 
 # First recognize some ad-hoc caes, or perhaps split kernel-os, or else just
@@ -1286,11 +1288,15 @@ then
 case $basic_os in
 	gnu/linux*)
 		kernel=linux
-		os=`echo $basic_os | sed -e 's|gnu/linux|gnu|'`
+		os=$(echo $basic_os | sed -e 's|gnu/linux|gnu|')
+		;;
+	os2-emx)
+		kernel=os2
+		os=$(echo $basic_os | sed -e 's|os2-emx|emx|')
 		;;
 	nto-qnx*)
 		kernel=nto
-		os=`echo $basic_os | sed -e 's|nto-qnx|qnx|'`
+		os=$(echo $basic_os | sed -e 's|nto-qnx|qnx|')
 		;;
 	*-*)
 		# shellcheck disable=SC2162
@@ -1301,11 +1307,11 @@ EOF
 	# Default OS when just kernel was specified
 	nto*)
 		kernel=nto
-		os=`echo $basic_os | sed -e 's|nto|qnx|'`
+		os=$(echo $basic_os | sed -e 's|nto|qnx|')
 		;;
 	linux*)
 		kernel=linux
-		os=`echo $basic_os | sed -e 's|linux|gnu|'`
+		os=$(echo $basic_os | sed -e 's|linux|gnu|')
 		;;
 	*)
 		kernel=
@@ -1326,7 +1332,7 @@ case $os in
 		os=cnk
 		;;
 	solaris1 | solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		os=$(echo $os | sed -e 's|solaris1|sunos4|')
 		;;
 	solaris)
 		os=solaris2
@@ -1355,7 +1361,7 @@ case $os in
 		os=sco3.2v4
 		;;
 	sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		os=$(echo $os | sed -e 's/sco3.2./sco3.2v/')
 		;;
 	sco*v* | scout)
 		# Don't match below
@@ -1367,13 +1373,7 @@ case $os in
 		os=psos
 		;;
 	qnx*)
-		case $cpu in
-		    x86 | i*86)
-			;;
-		    *)
-			os=nto-$os
-			;;
-		esac
+		os=qnx
 		;;
 	hiux*)
 		os=hiuxwe2
@@ -1391,7 +1391,7 @@ case $os in
 		os=lynxos
 		;;
 	mac[0-9]*)
-		os=`echo "$os" | sed -e 's|mac|macos|'`
+		os=$(echo "$os" | sed -e 's|mac|macos|')
 		;;
 	opened*)
 		os=openedition
@@ -1400,10 +1400,10 @@ case $os in
 		os=os400
 		;;
 	sunos5*)
-		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
+		os=$(echo "$os" | sed -e 's|sunos5|solaris2|')
 		;;
 	sunos6*)
-		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
+		os=$(echo "$os" | sed -e 's|sunos6|solaris3|')
 		;;
 	wince*)
 		os=wince
@@ -1437,7 +1437,7 @@ case $os in
 		;;
 	# Preserve the version number of sinix5.
 	sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
+		os=$(echo $os | sed -e 's|sinix|sysv|')
 		;;
 	sinix*)
 		os=sysv4
@@ -1683,11 +1683,14 @@ fi
 
 # Now, validate our (potentially fixed-up) OS.
 case $os in
-	# Sometimes we do "kernel-abi", so those need to count as OSes.
+	# Sometimes we do "kernel-libc", so those need to count as OSes.
 	musl* | newlib* | uclibc*)
 		;;
-	# Likewise for "kernel-libc"
-	eabi | eabihf | gnueabi | gnueabihf)
+	# Likewise for "kernel-abi"
+	eabi* | gnueabi*)
+		;;
+	# VxWorks passes extra cpu info in the 4th filed.
+	simlinux | simwindows | spe)
 		;;
 	# Now accept the basic system types.
 	# The portable systems comes first.
@@ -1722,7 +1725,7 @@ case $os in
 	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
 	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
 	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
-	     | nsk* | powerunix* | genode* | zvmoe* )
+	     | nsk* | powerunix* | genode* | zvmoe* | qnx* | emx*)
 		;;
 	# This one is extra strict with allowed versions
 	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
@@ -1741,6 +1744,8 @@ esac
 case $kernel-$os in
 	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* | linux-musl* | linux-uclibc* )
 		;;
+	uclinux-uclibc* )
+		;;
 	-dietlibc* | -newlib* | -musl* | -uclibc* )
 		# These are just libc implementations, not actual OSes, and thus
 		# require a kernel.
@@ -1749,8 +1754,12 @@ case $kernel-$os in
 		;;
 	kfreebsd*-gnu* | kopensolaris*-gnu*)
 		;;
+	vxworks-simlinux | vxworks-simwindows | vxworks-spe)
+		;;
 	nto-qnx*)
 		;;
+	os2-emx)
+		;;
 	*-eabi* | *-gnueabi*)
 		;;
 	-*)
-- 
2.33.0

